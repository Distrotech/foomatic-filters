#!@PERL@
# The above Perl path may vary on your system; fix it!!!

# ==========================================================================
#
# foomatic-rip spooler-independent PS->Printer filter (RIP) of Foomatic
#
# Copyright 2002 Grant Taylor <gtaylor@picante.com>
#		 & Till Kamppeter <till.kamppeter@gmx.net>
#        Modified by Patrick Powell <papowell@lprng.com>
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2 of the License, or (at your
#  option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#  Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#  USA.
#

=head1 NAME

foomatic-rip - Universal print filter/RIP wrapper

=head1 SYNOPSIS

=over 4

=item General Options:

foomatic-rip [--config configfile][-qvd][--debug level]
  [--log logfile][--genppd] <filter specific options>

=item Spooler-less printing/CPS (older versions) filter:

 foomatic-rip [-P <printer>|--ppd  <ppdfile>] [-J <jobtitle>]
  [-o <option>=<value> [...]] [<files>]

=item CUPS filter:

 foomatic-rip <jobid> <user> <jobtitle> <numcopies>
  <options> [<file>]


=item LPRng filter:

 foomatic-rip  [-J<jobtitle>]
  [-Z<option>=<value>[,<option>=<value>]*] [... lpd options ]
  (printcap specifies PPD file using:
   :if=foomatic-rip
   :pdd=<ppdfile> )

 foomatic-rip --ppd <ppdfile> [-J<jobtitle>]
  [-Z<option>=<value>[,<option>=<value>]*] [... lpd options ]
  (printcap specifies filter using:
     :if=foomatic-rip -ppd ppdfile )

 foomatic-rip --lprng [-J<jobtitle>]
  [-Z<option>=<value>[,<option>=<value>]*] [... lpd options ]
  ppdfile
  (legacy foomatic-rip, printcap specifies PPD file using:
   to specify PPD file)
   :if=foomatic-rip
   :af=ppdfile


=item LPD/GNUlpr filter:

 foomatic-rip [-w <number>] [-l <number>] [-x <number>]
  [-y <number>] [-i <number>] [-c] [-n <string>]
  [-h <string>] [-j|-J <jobtitle>|<options>] <ppdfile>

=item PPR RIP:

 foomatic-rip [<option>=<value> [...]]

=item PPR interface:

 foomatic-rip <queue> <destaddress> <options> <jobbreak>
   <feedback> <codes> <jobname>
   <routing_for_filetype> [<file>]


=item PDQ driver file generation:

 foomatic-rip [--ppd <ppdfile>]
   [-o <option>=<value> [...]]
   --genpdq|--appendpdq|--genrawpdq|--appendrawpdq


=item PDQ filter:

 foomatic-rip --pdq --ppd <ppdfile>]
   [-o <option>=<value> [...]]
   <file>


=item CPS (newer versions) filter:

foomatic-rip --cps -P <printer> [-J <jobtitle>]
  [-o <option>=<value> [...]] [<files>]

=back


=head1 DESCRIPTION

foomatic-rip is a universal print filter which works with  every  known
free software printer spooler. It has the following features:

=over 4

=item o

It  translates PostScript (and other file formats) from standard
input to the printer's native language (usually put to standard  out-
put).

=item o

The   translation   is   done  with  an  external  renderer,  usually
GhostScript (gs(1)). If no translation is needed (PostScript printer)
the  renderer's  command  line  reduces  to  cat(1). The way how this
translation is done is described in a PPD file.


=item o

Printer capabilities, how to handle user options, and  how  to  build
the renderer command line are described by PPD files. These PPD
files can come from Foomatic or can be the ones supplied by the manufacturers
of PostScript printers. The PPD files are the same for all spoolers.

=item o

Foomatic-rip works  with  every  known  spooler  (CUPS,  LPRng,  LPD,
GNUlpr,  PPR,  PDQ,  CPS,  and  without spooler). It auto-detects the
spooler from which it was called by  the  command  line  options  and
environment variables which were supplied by the spooler.

=item o

Non-PostScript files  are  translated  to PostScript before they are
passed to the renderer. This is usually done by a2ps(1), enscript(1),
or  mpage(1).  At installation time
foomatic-rip detects which program is installed,
but manual configuration is also possible.

=item o

Foomatic-rip not only applies option settings supplied by the user
on the  command line of the printing command, but also also searches
a PostScript job for embedded option settings.
Here  not  only  settings  affectimg  the  whole  job  are taken into
account, but also settings in the page headers, which are only  valid
for  the  page  where  they were found, so applications which produce
PostScript code with page-specific printer option settings are  fully
supported.

=item o

Foomatic-rip can use a configuration file  to obtain site specific
configuration information.

=back

=head1 SPOOLER-LESS PRINTING

=head2 Options

=over 4

=item --config <configfile>

Specify a configuration file.  See later sections for
details about the configuration file.  This option
must be the first command line option.

=item --debug <level>

Specify a level of debugging.  Each binary bit of the <level>
value is used to enable a debugging option.
See the
CONFIGURATION FILE information on how to enable debugging.

=item --log <logfile>

Put logging or trace information in logfile.  If logfile has
XXX in it, a unique file will be created a la the POSIX
mktemp function.  This file is meant for debugging and tracing
purposes and can be a security loophole.  See the
CONFIGURATION FILE information on how to enable debugging.

=item --ppd <ppdfile> or -p <ppdfile>

The PPD file <ppdfile> for processing this job.

=item --genppd

Regenerate the PPD file and print to STDOUT

=item -q

Quiet mode - minimal information output.
Suppresses verbose trace information.

=item -v

Verbose mode - generate verbose trace information output.

=item -d

Same effect as using the 'opts' option,
but information is send to STDOUT instead of the printer.
Meant for non-spooler operation.

=item -P <printer>

<printer> is the printer which should be used for this job.
The other functions of this option depend
on the printing system in use.  See the foomatic-rip code for
details.


=item -J <jobtitle>

The <jobtitle> will be printed in the head line of every page
of a plain text job.
The other functions of this option depend
on the printing system in use.  See the foomatic-rip code for
details.

=item -o opts

print an summary of the supported options on the output.

=item -o <option>[=<value>]

Option settings for this job.

=item <files>

The file(s) to be printed.
If none are specified, then input is taken from STDIN.

=back

=head1 Option Formats

Options are used to select printer specific operations.
The following option formats are use:

=over 4

=item Boolean Options

A Boolean can have values True and False
(the values 1 and 0 or Yes and No are alternatives).
Also, the prefix 'no' can be used if no other alternative
is available.

Examples:
  CoverPage=True  CoverPage    CoverPage=1 CoverPage=yes
  CoverPage=False noCoverPage  CoverPage=0 CoverPage=no

=item Pick One or Enumerated options.

The option and value has the format <option>=<value>.
The value can optionally be enclosed in quotes.
Enumerated option values cannot contain spaces.

Examples:
  PageSize=Letter PageSize='Letter' PageSize="Letter"

=item Pick Many

This option allows the specification of multiple
choices.  The option value consists of a list of
option value selections.  If a value is prefixed with 'no'
then the option value is unselected.

Examples:
  Send=Mail  Send=Mail,User  Send=noMail,User

=back

=head1 PPD File Location

The location of the PPD file is either specified on the command line
using the --ppd or -p options, or may
depend on the printing system in use.

For example,
if you are using the 'direct' printing support,
then the printer PPD file is stored as
@ETCDIR@/direct/<printer>.ppd or
~/.foomatic/direct/<printer>.ppd.
You can select this by specifying
"-P <printer>".

See the source code of the foomatic-rip program for details.

=head1 Output Redirection (Backend Support)

The output of the foomatic-rip filter can be
further processed by a backend filter.
This should be treated as a desperation option,
and is usually not used in normal spooling operation.
However,
when using foomatic-rip in standalone mode, it can be quite useful.

The PPD entry:

*FoomaticRIPPostPipe: "| <command>"

specifies a command  into  which  you wnat to re-direct the output data.
Due to the
restictions of PPD files <, >, and " are not allowed in the  <command> and
have to be HTML escaped.

 Character Replacement
 ---------------------
 <    &lt;
 >    &gt;
 "    &quot;
 '    &apos;
 &    &amp;
 C    &#xHEX;  where HEX is the hexadecimal value of character C

Example:
   *FoomaticRIPPostPipe: "| cat &gt; /dev/lp0"
   *FoomaticRIPPostPipe: "| cat &gt; /dev/usb/lp0"

The printer device file /dev/... must be writeable by the user if this
method is used.

For a TCP/Socket/JetDirect printer with the host name printer listening
on port 9100 use the nc or 'netcat' program:

*FoomaticRIPPostPipe: "| /usr/bin/nc -w 1 printer 9100"

Note the "-w 1" in  the  "nc"  command  line.  It  causes  "nc" to exit
after 1 second after transfering the file to the printer.

Example:
    *FoomaticRIPPostPipe: "| rlpr -Plp@printserver"
    *FoomaticRIPPostPipe: "| lpr -Plp@printserver"

directs  your  output  to  the  LPD printer queue lp on the machine named
printserver.

See also http://www.linuxprinting.org/direct-doc.html

=head1 PRINTING WITH SPOOLER

foomatic-rip is a spooler-independent filter script which takes
PostScript as standard input and generates the printer's page
description language (PDL)/raster format as standard output. This
kind of filter is usually called Raster Image Processor (RIP),
therefore the name "foomatic-rip".

By default, it is installed in one of the standard executable locations. 
However,
you may need to make a symbolic link to it
from a a spooler-specific directories when you use CUPS or PPR:

ln -s /usr/bin/foomatic-rip /usr/lib/cups/filter/
ln -s /usr/bin/foomatic-rip /usr/lib/ppr/lib/
ln -s /usr/bin/foomatic-rip /usr/lib/ppr/interfaces/

It can be used as a standard filter for almost any print spooling
system.

For more information, see the
documentation on the Linux Printing Web site:

http://www.linuxprinting.org

=head1 CONFIGURATION FILE

The foomatic configuration file, usually named filter.conf,
contains options that control some of the foomatic operations.

The configuration file contains some entries that enable
debugging and tracing.

The following is a sample configuration file.

#INCLUDE filter.conf
 
=head1 FILES

 @ETCDIR@/cups/<printer>.ppd
 @ETCDIR@/lpd/<printer>.ppd
 @ETCDIR@/ppr/<printer>.ppd
 @ETCDIR@/pdq/<printer>.ppd
 @ETCDIR@/direct/<printer>.ppd

    The PPD files of the currently defined printers.

 @ETCDIR@/foomatic/filter.conf
    foomatic-rip configuration information

=head1 EXIT STATUS

=item 0

foomatic-rip returns 0 on normal exit.

=item 1

a transient error, perhaps a retry is called for

=item  any other status

A more permanent error. Usually user or administrator intervention
is required.

=head1 RUN TIME VALUE SUBSTITUTION 

The foomatic-rip support provides a method for making run-time
substitutions of command line or option values into the information
placed in the output file.  The substitution method is simlar to
that of the Perl SPRINTF format, with the restriction that the
'*' (length specified at run time) field is not supported.

A scan for substition values is performed on PostScript,
PJL, and PCL output strings prior to their use as option values.

=head2 Substitution Format

The following formats are supported:

 String:
   \%[sprintf format]s{variable}
   Example:
     \%s{env.TMP}
     \%10s{option.J}
     \%-5s{PageSize}
     \%-*s{PageSize,-5}
 Integer
   Example:
   \%[sprintf format]d{variable}
     \%{env.w}
 Float
   Example:
   \%[sprintf format]f{variable}

When processing a string, integer, or flag value,  the value of the variable is
cast to the appropriate type and then processed by the sprintf function.

The variable entries have the following format.  The notation used here
is based on Perl for discussion purposes.

  Term:
    "string"   - a literal string value.  Integers and floats are represented
                 as strings, i.e. "10" and "10.0".
    DATE       - the current date in YYYY-MM-DD-HH:MM:SS
                 eg-    2003-12-12-07:10:19
    cmd.X  -    value of the command line single character option 'X'
                Note: if the -c option is present, the value will be
                reported as 1; if not, as 0.  This makes the usage consistent
                with the LPD filter option convension.
    Option     - the current value of an option.

  Variable:
   term
   test?variable:variable

  Test:
   Test Format   Meaning
   term      Perl test for TRUE string value
   !term     Perl test for FALSE string value
   term (eq, ne, gt, lt, ge, le) term
   term (==, !=, <, >, >=, <=) term


The cmd options are taken from current command
line options, assuming the LPD option passing conventions.  This is basically
that options have the form:  -X value  or -Xvalue.

=head2 Example

A common example is for adding a watermark to output based on the user job name.
You can also modify the watermark facilities of other PPDs to provide a similar
functionality.

 *DefaultWatermark: True
 *OrderDependency: 99 PageSetup *Watermark
 *Watermark True: "
 <<
   /EndPage
   {
     2 copy
     dup 0 eq exch 1 eq or exch 0 eq and
     {
       save
       10 dict begin
       /rvideo { currentpoint 1 sub 2 index stringwidth pop 6 0 setgray rectfill 1
         setgray show 0 setgray } bind def
       initmatrix initclip clippath pathbbox /ymax exch def
         /xmax exch def /ymin exch def /xmin exch def
       /fontsize 6 def /ymin ymax fontsize sub 1 sub def /ybase ymin 2 add def
       initclip 1 setgray xmin ymin xmax fontsize 1 add rectfill 0 setgray
       xmin ybase moveto /TimesNewRoman-BoldItalic findfont 
         [8 0 0 6 0 0] makefont setfont
       ( Net-Print ) rvideo xmax ( Net-Print ) stringwidth pop sub ybase moveto
       ( Net-Print ) rvideo 64 ybase moveto /Helvetica-Bold findfont
        fontsize scalefont setfont
       ( \%s{cmd.P} \%s{cmd.L} ) rvideo
       100 ybase moveto
       ( \%s{cmd.J} ) show
       527 ybase moveto
       ( \%s{DATE} ) show
       end
       restore
     } if
     exch pop dup 0 eq exch 1 eq or
   }
 >> setpagedevice "
 *End

=head1 PPD FILE OPTIONS

The following options can be specified in the PPD file using the
FoomaticSystemOption capability.

=head2 Option Aliases

Example:

 *FoomaticSystemOption Aliases: "
   duplex=Duplex&#x3d;DuplexNoTumble
   simplex=Duplex&#x3d;None
   DuplexNoTumble=Duplex&#x3d;DuplexNoTumble "

   Note: &#x3d; is the URL escape code for '=' (equal sign)

Syntax:
   
   option[&#x3d;value] = option[&#x3d;value]
   

The 'Aliases' value specifies a list of (case insenstive) command
line option aliases.
During option checking, foomatic-rip will check to see if the current
option or option value combination has a match.  If it does, then the
option and/or value is replaced by the specified one.
This allows a standard set of command line options such as 'duplex', 'simplex',
etc. to be defined, and translated to a Printer specific set of PostScript commands.

For example:

    duplex  = Duplex=DuplexNoTumble

will cause the command line 'duplex' to be translated to Duplex=DuplexNoTumble.
This will then cause the code for the DuplexNoTumble value to be used.

=head2 Forcing Option Value Insertion

Example:

 *FoomaticSystemOption ForceInsert: "
   0,Prolog:JobPatchFile=*  0,JCLSetup:JCLSetup=* "

 %% force this to be put into Prolog
 %% The initial Deferred MediaSelection value is not predictible
 *JobPatchFile 1: "
  << /DeferredMediaSelection true /MediaPosition 9 /ManualFeed false >> setpagedevice"
 *End
 %% force this to be put into JCL (PJL) Setup
 *JCLSetup 1: "
  @PJL COMMENT SETUP OPTIONS<0a>"
 *End

Entry Syntax:

   [[Order,]Section:]<language>OptionName[=Value]
   <language> - JCL, PJL, PCL; if missing then use PostScript
   Order    - order in section; default is 0 (i.e. - start)
   Section  - the section to use;  default is AnySetup
     possible values:
         Prolog, DocumentSetup, PageSetup, AnySetup, JCLSetup, etc.

   OptionName - (case insensitive) Option name

     Value    Action
     (none)   Adds the current option value to the section
              (i.e.- PickOne option)
     value    Adds the specified option value to the section
              (i.e. - PickOne option with non-changeable value)
     *        Adds all values to the section
              (i.e. - PickMany, all selected, and non-changeable)

This is used to cause the values for an option is to be placed in
the indicated section.  As shown in the  example,  this can be used
to place setup code or other values into the Prolog.

=head2 PageSize and PageRegion Control

Examples:

 *FoomaticSystemOption UsePageRegion: " InputSlot!=Auto Punch=On "

Syntax:
  Value         Action
  Option=Value  Use PageRegion when this option has this value
  Option!=Value Use PageRegion when this option does not have this value


This option is used to supplement the actions of the predefined
*RequiresPageRegion PPD variable.  The *RequiresPageRegion usage is:

*RequiresPageRegion InputSlot: [True,False]
*RequiresPageRegion All: True
*RequiresPageRegion All: False

where input slot is the value of the *InputSlot option.
The purpose of this option is to cause the PageRegion selection
code to be put into the PostScript file when the selection is True
and the specified input slot is chosen.
The All value indicates any of the input slots;
if the selection is True then the PageRegion selection is always
put into the PostScript file.

However, experiments with various printers has shown that when
you specify an Input Slot, you must NOT use the PageSize selection
code.  This is slightly different than the *RequiresPageRegion
PPD variable.

The value of the /PageSize variable is used by the PostScript
setpagedevice operator to determine the input media size requirements.
The details of how this is used are very complex, and users are
referred to the PostScript Language Reference Manual for details.

In the PPD file, there are usually both PageSize and PageRegion
options that apparently have the same effect.  The reason for the
two sets of options is that the PostScript code used for the PageSize
option may conflict with input tray selection selection.  When you
select an input tray, you may need to use the code for PageRegion
selection, rather than PageSize selection.

The UsePageRegion option allows us to control the replacement of
PageSize by PageRegion.  When the current options values match any
one of the specified tests, then the PageSize option is replaced
by the PageRegion option, if it is present.

=head2

=head1 EXTENDED PPD FILE FORMAT FOR FOOMATIC RIP

The original Postscript Printer Description (PPD) file format
was designed around a PostScript only printer, and little consideration
was given to supporting other non-PostScript features that
might be needed for particular printer applications.

One of the first of these to surface was the need to provide
support for Printer Job Language (PJL) commands.  These commands
are needed to enable various options that are not provided by
the PostScript Interpreter.  The Foomatic-RIP filter extends
this to PCL 5 and PXL (PCL 6) as follows:

 Common Entries:

 *OpenUI *PageSize: PickOne
 *DefaultPageSize: Letter

 PostScript Specific:

 *OrderDependency: 30 AnySetup *PageSize
 *PageSize Letter/Letter: "
    <</PageSize [612 792] /ImagingBBox null>>
    setpagedevice"
 *End

 PJL Specific:

 *OrderDependency: 30 JCLAnySetup *JCLPageSize
 *JCLPageSize Letter/Letter: "@PJL MEDIASIZE = LETTER<0a>"

 PCL Specific:

 *OrderDependency: 30 PCLAnySetup *PCLPageSize
 *PCLPageSize Letter/Letter: "<1b>l&3H"

 PXL (PCL 6) Specific:
 *OrderDependency: 30 PXLAnySetup *PXLPageSize
 *PXLPageSize Letter/Letter: "
    _uchar_array['LETTER'] @MediaSize BeginPage "

 *CloseUI

The *Default entries are used to set default selections
or values for an option.  The *OrderDependency entry
is then used to set the order in which the options are
to be placed into the output data stream.  While
PJL, PCL and PXL do not have the same ordering restrictions
that PostScript has,  this entry is used to cause the
insertion of the appropriate language entry.

The PJL, PCL, and PLX command information is escaped using
the PJL escape mechanism.  As described in the PPD standard,
only a subset of printable ASCII characters can be used
for option values.  Non-printiable or other characters are
represented by the <XX> sequence, where XX is the hexadecimal
value of the character.

Any whitespace in the PCL 5 escape sequences are deleted
before <XX> character conversion.  Thus, <20> must be used
to insert spaces where needed.

The PXL command sequences are expressed in an assembler language
format, similar to that used in the PCL XL Feature Reference
document, available from Hewlett-Packard.
This document is HP Company Confidential,  and will have to be
obtained on an individual basis.  The reason for using this
format is to deal with the various binary representations used
by PXL.  It is easier to translate the high level textual
format into the appropriate binary data streams than to
try to provide a mechanism to deal with the multitudinous
possible data encodings.

=head1 START OF PAGE AND WATERMARK SUPPORT

For various reasons,
it is sometimes desireable to have some Postscript, PCL, or PXL
code be executed at the start of each page.  This is usually
done for WaterMark or other purposes, such as putting the user's
name or other information on the first page.

The Foomatic-RIP filter supports this by reserving the special
StartOfPage option.

 Defaults:

 *OpenUI *StartOfPage: PickOne
 *DefaultStartOfPage: None

 *OrderDependency: 100 PageSetup *StartOfPage
 *StartOfPage None/None: ''
 *OrderDependency: 100 PageSetup *PCLStartOfPage
 *PCLStartOfPage None/None: ''
 *OrderDependency: 100 PageSetup *PXLStartOfPage
 *PXLStartOfPage None/None: ''
  
 To Cause Insertion:

 *StartOfPage Setup1/Setup1: "PostScript"
 *StartOfPage PCLSetup1/Setup1: " PCL 5 Escape or Text"
 *StartOfPage PXLSetup1/Setup1: " PXL command sequence"

This option can be used with the Page Range facility and
the command line:
  
  -o1:StartOfPage=Setup1 -o2-:StartOfPage=None

=head1 FINE CONTROL OF FILTERING OPERATION

The original Foomatic-RIP filter was designed to operate
with PostScript input files,
or with ASCII text files that would be converted to PostScript.
The Foomatic-RIP filter could not be used with legacy
text printers that required some simple CR to CRLF
conversions.

The current version of Foomatic-RIP can also operate on
PCL, PXL, and text files.
The method used to implement this is to expand the use of the
Foomatic-RIP filter specification in the PPD file.


=head1 AUTHOR

Till   Kamppeter   <till.kamppeter@gmx.net>   with   parts  of
Manfred Wassmanns's <manolo@NCC-1701.B.Shuttle.de> man pages for
the  Foomatic 2.0.x filters.

Revised by Patrick Powell <papowell@lprng.com>.

=head1 BUGS

Most likely there are some.  But testing has been thorough.

Please send bug reports to foomatic-devel@linuxprinting.org.


=head1 FOOMATIC-RIP OPERATION

The following describes the internals of the foomatic-rip
filter.

=head1 PPD File Information

The first part of the foomatic-rip operation is to parse the PPD file.
This results in a hash structure ($dat) which is used throughout
the program, and is passed to most routines.

The information and format in the $dat structure is described later.

=head1 Process Structure

To process a file without loading the whole file into memory we work
on a data stream. We read the data line by line, analyse it to decide what
filters to use, and then start the filters.
We buffer the data only as long as we didn't determing which filters to
use for this piece of data and with which options. There are no temporary
files used.

foomatic-rip splits into multiple parallel processes to do the whole
filtering (listed in the order of the data flow):

   STDIN ->
     [* gendocument   -> ]   - optional
     [* fileconverter -> ]   - optional
     MAIN ->
     * renderer -> fixup ->  - multiple sets created
                               possibly one per page
     [* postpipe      -> ]   - optional
       -> STDOUT


Each of the filters marked with * actually are multiple processes.
The structure is:

     (input provided from parent via a pipe
     STDIN ->  child - does exec of filter or conversion program
                      STDOUT -> pipe (to parent) 
                      STDERR -> logger process -> STDERR
                      
The parent (MAIN) process will fork the middle process, which in
turn will fork a child process.  The child process will do an EXEC
of the specified program.  The middle process reads all error
messages written to the child's STDERR,  labels them, and writes
them to the parent processes STDERR.  When the child process exits
the middle will 'wait' for the child exit status, process it and
log the value if necessary, and then exit with the processed status
to the parent process.

This arrangement provides a high degree of control over error messages.

=head2  Document Generator: gendocument

Generate documentation pages (only jobs with "docs" option).
It discards the input on the foomatic STDIN.

=head2 File Converter: fileconverter

Runs a file conversion filter to convert non-PostScript
input into PostScript (only non-PostScript and "docs" jobs).

=head2 MAIN: main loop

This is the top level process, and creates the children.
It will also monitor their exit status.

First, it parses the PPD file(s), and then extracts
the command line options.

If the command line options request generating a
document describing the options
then MAIN creates the 'gendocument' process and binds
the STDOUT of the 'gendocument' process to MAIN's STDIN.
MAIN then checks to see if the options are to be
sent directly to STDOUT, and if so, reads them from its
STDIN, prints them, and then exits.

Next, MAIN reads the first part of the document to
decide if file conversion is needed.
If it is,  then MAIN will create the 'fileconverter' process
to reprocess the incoming job.  If the 'fileconverter'
fails to convert the program to an acceptable input
format,  then MAIN will exit with an error message.

At this point we have:

   STDIN ->
     [* gendocument   -> ]   - optional
     [* fileconverter -> ]   - optional
      -> MAIN's STDIN

      MAIN's STDOUT ->
       -> STDOUT

MAIN will now read the PostScript input (from its STDIN)
and will either decide that it cannot massage the input
or that enough has been read to print a page.
It will now
create the 'postpipe', 'render' and 'fixup' processes:

At this point we have:

   STDIN ->
     [* gendocument   -> ]   - optional
     [* fileconverter -> ]   - optional
      -> MAIN's STDIN

      MAIN's STDOUT->
     * render -> fixup ->
     [* postpipe      -> ]   - optional
       -> STDOUT


MAIN will write the accumulated PostScript to the 'render'
process, which will create rendered output.  The 'fixup'
process will then massage the rendered output, inserting
PJL or other information in order to make the output
compatible with the 'postpipe' or printer.

The render and fixup process structure is a little complicated:

Process Struction:
  Main:
    render logger process (for render STDERR processing)
       render
    fixup

    
IO Structure:

  Main WRITE_PIPE ->
     STDIN of render ->
       STDIN of fixup ->
	 STDIN of postpipe ->
	   
      STDERR of render->
	 STDIN of render logger 
	      which writes error messages
	      to STDERR of MAIN


As MAIN reads the input,  it may discover that different
pages of the input job have different options.  If this
is the case, at the point where the options change,
MAIN will close the input to the 'render' pipe and wait
for it to exit.  The 'render' and 'fixup'
processes will exit, and then MAIN will create a new
'render' and 'fixup' process, and send the new options
and following job pages to them.

At the end of the job, the 'render' STDIN is closed,
and then after it has exited (actually, after the
'fixup' process has exited), MAIN will close the
'postpipe' STDIN and wait for it to exit.

Periodically throughout filtering process the MAIN process will
check to see if any process has exited with an error status.
If any does, it will terminate processing.

=head2 Render: render

The rendering process. In most cases GhostScript, "cat"
for native PostScript printers with their manufacturer's
PPD files.  It may be created multiple times, depending on
the complexity of the print job.

=head2 Fixup: fixup

This process will add any PJL or other information necessary
for correct printer operation.

=head2 PostPipe: postpipe

This process is a last gasp, desperation, horrible kludge
(every system needs at least one) to allow those little problems
that cannot be solved any other way, to be attacked.

It is responsible for the final processing before a job
is sent to the printer.

=head1 Debugging Support

The '--debug' command line option can enable various levels
of traces to be placed in the debug output file.
Each bit positition of the debug value is used to enable
one or more sets of statements

   
 Hex Value      Enables
 01    High level tracing of overall operation
 02    Details about parsing PPD Files
 04    More details about parsing PPD Files
 08    Even more details about parsing PPD files.
      Note: --debug 1, 3, 7, 0xF  are useful
 10    Information about processing input files
 20    More details about processing input files
 40    Even more details about processing
      Note: --debug 0x11, 0x31, 0x71 are useful

=head1 Options

Options are set either in the PPD file, the command line, or by BeginFeature
entries in the PostScript file.
The source of the option and its format determine the effect of the option
on the job procesing.


=head2 Option Precedence

The order of precedence is:

=over 4

=item 1

Lowest precedence is the PPD file default values
and the values set by the

 *FoomaticSystemOption: Defaults = " ... ".

entry in the PPD file.
This value is used to modify the defaults of the PPD file
as an alternative to modifying multiple option default values
in the PPD file.

=item 2

Next highest precedence are the options
found in the the PostScript file
specified by the %%BeginFeature: Name=Value options.

=item 3

Next highest precedence are the command line options.

=item 4

The highest precedence are the options and values set by the

 *FoomaticSystemOption: Permanent = " ... "

entry in 
These cannot be modified or changed by the command line
or PostScript file.

=back

=head2 Composite Options

Composite options set the values or one or more other options.
The options whose values are set by the composite
are marked as 'controlled_by' the composite option.

=head2 Option Values and Stages of Processing

During the processing of a job, the values of options can be changed.
Each stage stage of processing has a corresponding set of entries
in the $dat data structure.

The major processing stages are the 'default',
'userval', 'header', and 'currentpage' options.

The 'default' values are the values that are a result of processing
the PPD files and updating the various option values.

The 'userval' values are the result of processing the user command
line options.  These values start with the 'default' values and
then are modified according to the user options.

The 'header' values are the option values that correspond to the
options set by the 'userval' options, together with those found in
the PostScript file Setup section.  These values are supposed to
be the basic or reference values for each page of the PostScript
file output.

Each page of the PostScript file can specify per-page specific
options.  The values of these options start with the 'header' values,
and are updated according to option settings found in each per-page
section.

For example, let the $arg value be the hash entry for the PageSize option.

  $arg = $dat->{args_byname}{PageSize};

Assume that the PPD file specifies the default PageSize=Letter:

  $arg->{'default'} = 'Letter';  (precedence 'ppd')

If we have a command line option that sets PageSize=Legal, then we would have:
 
  $arg->{'default'} = 'Letter';  
  $arg->{'userval'} = 'Legal';   (precedence 'user')

At the start of processing the PostScript file, and just before
the start of individual page processing, we would have:

  $arg->{'default'} = 'Letter';  
  $arg->{'userval'} = 'Legal';
  $arg->{'header'} = 'Legal';   (precedence 'user')

And finally, when processing the individual page, we would have:

  $arg->{'default'} = 'Letter';  
  $arg->{'userval'} = 'Legal';
  $arg->{'header'} = 'Legal';   (precedence 'user')
  $arg->{'currentpage'} = 'Legal';   (precedence 'user')


If we assume that we do not have a command line option setting
the page size, but the PostScript file does have options, we can
have at the start of processing:

  $arg->{'default'} = 'Letter';
  $arg->{'userval'} = 'Letter';  (precedence 'ppd')

Now, when reading the PostScript file, we encounter a

*BeginFeature PageSize=Legal

entry.  Then we would have:

  $arg->{'default'} = 'Letter';
  $arg->{'userval'} = 'Letter';
  $arg->{'header'} = 'Legal';  (precedence 'file')

Now suppose that Page 1 had a per-page *BeginFeature PageSize=Tabloid
entry.  We would have, when processing Page 1,

  $arg->{'default'} = 'Letter';
  $arg->{'userval'} = 'Letter';
  $arg->{'header'} = 'Legal';
  $arg->{'currentpage'} = 'Tabloid';  (precedence 'file')

When processing Page 2, the 'currentpage' values would be initialized to the
current 'header' values,  and unless another *BeginFeature option is found,
we would have:

  $arg->{'default'} = 'Letter';
  $arg->{'userval'} = 'Letter';
  $arg->{'header'} = 'Legal';
  $arg->{'currentpage'} = 'Legal';  (precedence 'file')


=head1 Option Processing - expandoptions routine

The 'expandoptions' routine is responsible for processing options
and assigning values to the entries in the $dat hash.

 ($found_list) =
    expandoptions( $dat, $options, $optionset, $verbose,
        $precedence, $warning_header )

     $dat is the information hash
     $options = [ "key=value", "key=value" ... ];
        option list
     $optionset = 'key'
        The the hash key where we set the value
        for the option
     $verbose = 0 - not tracing
              != 0 - show action of expansion
     $precedence = numerical value of the precedence to set for
        this option.
     $warning_header = header for warning message.

     $found_list is a hash with the keys corresponding
        to the option names which were found in the
        option list and whose values are entries in the
        $dat hash for the option.

The $options parameter is an array of strings whose format
represent the requested option values.  These strings can
have the format:

=head2 Basic Option

 option=value
  PageSize=Legal   

Sets the specified option to the specified value.

=head2 PickMany Option

 option=value1,value2,...
 option=value1:value2:...
 option=value1;value2;...
  Menu=Column1,noColumn2,Column3   
  Menu=Column1;noColumn2;Column3   
  Menu=Column1:noColumn2:Column3   

Selects or deselects the specified value for the option.
The form 'noValue' deselects the value.  The choices
are processed in left to right order.  Due to various
command line and other restrictions, the selections can
be separated by comma (,), colons (:) or semicolons (;).

=head2 Option with PageRange

 pagerange:option=value  Page Range
  1:PageSize=Tabloid 2-:Pagesize=Legal

This adds the page range and values to the set of page ranges for
the option. Note that it does not set the current value
for the option. For example, if the current option set is 'default',
then processing the following options would result in:

 PageSize=Letter 1:PageSize=Tabloid 2-:PageSize=Legal 

 $arg = $dat->{args_byname}{PageSize};
 $arg->{'default'} = Letter
 $arg->{'pagerange'} = [
     1:PageSize=Tabloid, 2-:PageSize=Legal 
   ]

This allows the setting of page ranges that are different than the
default option value.

=head2 Controlled By Option

  @controlled_by@[pagerange:]option:value
   @BannerPage@1:PageSize=Tabloid

This form of an option is used by the 'expandoption' routine when
expanding an option.  For example,  suppose that the BannerPage
option was defined to be:

BannerPage=True
 1:PageSize=Tabloid 2-:PageSize=Letter 

When the 'expandoption' routine processes the BannerPage
option and its value is True, then it will process the

   @BannerPage@1:PageSize=Tabloid
   @BannerPage@2-:PageSize=Letter

entries in turn.  The PageSize option would be marked as
'controlled_by' the BannerPage option,  and would not be
allowed to be changed by any other option setting.

If this option was set by a default in the PPD file, then
users would not be able to change the page sizes, either by
a command line option.  This action may not be suitable,
especially when the purpose of the option is to set a basic
template and then allow it to be modified.

To do this,  the RemoveControlledBy=True option can be specified
as part of the composite option value:


BannerPage=True
 1:PageSize=Tabloid RemoveControlledBy=True  2-:PageSize=Letter 

This would have the effect of removing the 'controlled_by'
information for any options following the RemoveControlledBy
option.  The result would be:
   @BannerPage@1:PageSize=Tabloid
   2-:PageSize=Letter

Now users could override the page sizes for later pages using,
for example:
   2:-Pagesize=Legal

=head2 Option Processing Order

The expandoptions routine processes the options in the
$options array from left to right (first to last) order.
Before processing,  if any of the specified options are
composite options then the expandoptions routine
will remove any 'controlled_by' information for these options
from the $dat hash.

At system initialization we process the PPD file arguements, and
then use 'expandoption' to set the 'default' value for the option.

=head2 Option Precedence Order

The $precedence level is used to control whether an option value
is set to a new value.
If the 'expandoption' routine is requested to change the value
of an option whose current precedence value is lower  than
the $precedence level, the option will be changed and the
option's precedence value will be set to $precedence.

=head2 Implementation Notes

The 'expandoptions' keeps the current set of options in the
@option array.
This array is initialized with the values from the $options
parameter.
Any option which has a composite value causes any 'controlled_by'
information  which indicates that an option value is controlled
by the composite option to be removed.  This allows a different
set of options to be used for different composite option values.


The options are processed by 'shifting' the first option from the
@opton array.  As described above,  depending on the option format,
the current precedence level, and the current option 'controlled_by'
value the 'expandoption' routine will set the new option value.

If the option was a compound option,  its dependent option values
will be placed on the stack in turn.

We set an arbitrary limit of 1000 options to be processed
by the expandoption routine.
When the @option array is empty (success) or the
the loop count exceeds 1000 (failure) we terminate option processing.

=head1 PostScript File Conversion

We assume that we are going to get either a 'good' file for conversion
or a total mess of junk.  In the later case, we simply toss it to the
fileconverter and hope for the best.

A 'good' file will contain

  [UEL [PJL]]   - standard UEL/PJL header
             [^D]%!       - postscript
             <esc>E<esc>  - pcl

We have a problem if we try to use the <STDIN> operator
as some PCL files have a zillion bytes of input before the first
LF, or may not even have an LF.  Since, however, this is valid
PCL we should be able to handle this.

We will save the PJL in the hopes that at a later time we
may be able to read it and salvage some information from it.

Supported file converters are "a2ps", "enscript",
"mpage", and spooler-specific filters. All filters should convert
plain text to PostScript; "a2ps" also handle other formats. The
conversion filter is always used when one prints the
documentation pages, as they are created as plain text.

When CUPS is the spooler "pstops" is executed after the converter
so that the default option settings from the PPD file
and CUPS-specific options as N-up get applied.

If the file converter fails or does not produce PostScript,
then an error message is issued and the job aborted.

=head1 Details of PostScript File Handling


A PostScript that meets the Adobe PostScript Document Format
standard has the following sections.  Note: DSC stands for
Doment Structuring Conventions.

   %!PS-Adobe-3.X       [PROLOG START]
   DSC comments
   - information only, such as user name, etc.
   -- comments about the prolog
   %%Pages: N M  - numbers of pages
   %%End Comments]  <- this is supposed to be present
   %%EndProlog     - all lines up to here are saved in
                     @psheader.
                     $insertoptions = @psheader
   %%BeginSetup
   %%EndSetup
                  <- all of the stuff up to here
		    is common to all the pages
                    $insertoptions = @psheader

   %%Page: 
   %%BeginPageSetup 
   %%EndPageSetup   <- per page setup
   <stuff>
   %%PageTrailer

   %%Page: 
   %%BeginPageSetup <- per pages setup
   %%EndPageSetup 
   <stuff>
   %%PageTrailer

   %%Trailer       <- end of jobs

   %%EOF

After reading and parsing the PPD file, we call the
'expandoptions' routines to set the values of the 'default'
entries for each option.  Next we process the command line
options and set the 'userval' options.  Thus, 

First, we copy the values of the options set by the user
into the 'header' option set, i.e. -
  for all options $arg do
    $arg->{'header'} = $arg->{'userval'}
  done

These are the option values we will assume that are to be used
for the PostScript job.

We now read the input until an %%EndSetup or %%BeginPageSetup
is found.  During this scanning process we may encounter
option settings in the PostScript file:
  
 %%BeginFeature:  *OptionName=OptionValue
 %%FoomaticRIPOptionSetting:  OptionName=OptionValue

We check the OptionName to determine if it is valid for this
printer and then the OptionValue to determine if it is acceptable.
We then update the 'header' information with the new option value.

At this point we know what the overall option values will be.
We save these values into the 'currentpage' settings.

Now we continue scanning until we reach
a %%Page: entry, after which we will find the PostScript code
to generate the page information.
We call 'expandoptions'
to fix up an changed option values.

We now generate a 'Prolog', 'Setup', and 'PageSetup' PostScript
code sections using the values 'currentpage' options, 
and send the code for the page to the 'render' process for
processing.

We continue reading until we reach the end of the code for the page.
We save the previous pages option values in 'lastpage' and
then copy the 'header' options to the the 'currentpage'.
We read and store the postscript code for the next page until we reach
the %%EndPageSetup or the next page.
We call 'expandoptions'
to fix up an changed option values and then compare the 'currentpage'
to 'lastpage' option values.  If they are the same, then we
simply send our PostScript code to the current 'render' process.
However, if they are different,  then we terminate the current render
process and start a new process up.

We could avoid starting this process up and simply add the changed option
values to the %%PageSetup section for the next page,
but there may also be settings that require PJL code to be
inserted into the output.

Needless to say, there are a huge number of broken PostScript
generators that fail to meet the PDC standard, and much
of the scanning code is concerned with dealing with these problems.

While it may appear that this is not necessary, as all we need to do
is resend the PostScript,  in actual fact there may also be PJL options
that need to be modified as well.

After the last page the trailer (%%Trailer) is sent.

Non DSC-conforming documents will have a Prolog and Setup
generated and affixed to the start of the file.  There is
little else that can be done as there is no way to tell
where the option values are defined without the DSC comments.

If CUPS is the spooler, the option settings may have been
inserted by the "pstops" filter.  As "pstops" does not support "real" numerical
options, it sees these settings as an invalid choice and inserts
the default options.

=head1 Page Range Settings

We assume that the only way that a page range can be set is either
through the system level defaults or by user options.  We assume that
the PostScript file has no methodology to set page ranges.

The page ranges are recorded in a list:

   [ even:PageSize=Letter  10-30PageSize=Legal ]

Each time we process a page, we update the options based on the
values in the page ranges.  The code for doing this is:

  for each option that has pagerange do
    for each pagerange value in the list do
       if the current page fits the range then
          if allowed by the precedence level,
            push @list option=value
       endif
    endfor
  endfor

Now we update the page options using the 'expandoptions' routine.

=cut

use strict;
use lib qw(.);
use POSIX;
use Symbol;
use FileHandle;
use Data::Dumper;
use IO::Handle;
use IO::Pipe;
use Time::HiRes qw( gettimeofday time );

## include START
use Foomatic::Debugging;
use Foomatic::Subprocess;
use Foomatic::ParsePPD;
use Foomatic::ParsePCL;
## include END

sub buildpdqdriver( $ $ ) ;
sub buildcommandline( $ $ ) ;
sub setoptionsforpage( $ $ $ ) ;
sub parsepageranges( $ $ ) ;
sub makepagesetupsection( $ $ $ ) ;
sub makesetupsection( $ $ $ ) ;
sub makeprologsection( $ $ $ ) ;
sub deleteoptions ( $ $ ) ;
sub copyoptions( $ $ $ ) ;
sub readConfFile( $ ) ;
sub set_exit_engaged() ;
sub set_exit_prnerr_noretry() ;
sub set_exit_prnerr() ;
sub docgenerator( $ ) ;
sub getfileconverter( $ $ ) ;
sub startrender( $ ) ;
sub getrendercommand( $ $ ) ;
sub closerenderhandle( $ $ $ ) ;
sub childwait( $ $ );
sub expandoptions( $ $ $ $ $ $);
sub checkchild();
sub startpostpipe( $ );
sub sendpjloutput( $ $ $ );
sub trim_options( $ $ $ );
sub trim_options_stdout( $ $ $ );
sub checkconstraints( $ $ );
sub chkconstr( $ $ $ $ );
sub fixopts(  $ $ $ );
sub repval(  $ $ $ $ $ );
sub termval(  $ $ $ );

my $ripversion='$Revision$';
#'# Fix emacs syntax highlighting


# ==========================================================================
#
#    Set Up General Perl Program Functionality
#
# ==========================================================================


# Flush everything immediately.
$| = 1;

# Tidy up a bit at end

END {
	close STDERR;
	close STDOUT;
}

# Set the signal handler
# If you get a signal, you might as well terminate
# as there is nothing much you can do.
#
# You should make a valiant attempt to kill the children -
# killing off GhostScript is easy - getting rid of the junk
# in the pipe to the output device is almost impossible to do
# in a sane and sensible manner - oh for a tcflush that worked on all
# connections.  Patrick ("yet another IOCTL call") Powell
#

use sigtrap qw(handler set_exit_prnerr USR1
	       handler set_exit_prnerr_noretry USR2
	       handler set_exit_engaged TTIN);

# ==========================================================================
#
#    configure utility - sets paths and other options
#    Warning: @@xxx@@ should not match any option set by configure
#
# ==========================================================================


# What path to use for filter programs and such.
# The default path is often fine on Linux, but
# may not be on other systems.
#

my $prefix = "@prefix@";
my $sysconfdir = "@ETCDIR@";
my $execpath = "$prefix/bin:/usr/local/bin:/usr/bin:/bin";
my $configfile = "$sysconfdir/foomatic/filter.conf";

# ==========================================================================
#
#    Preliminary command option processing
#
# ==========================================================================

# We do not use Getopt::Long because it does not work when between the
# option and the argument is no space ("-w80" instead of "-w 80"). This
# happens in the command line of LPRng, but also users could type in
# options this way when printing without spooler.

# Make one option string with a non-printable character as separator,
# So we can parse it more easily.  We make sure that the
# nonprintable character is not in the argument
if( grep {m/\x01/} @ARGV ){
    rip_die( "SECURITY ATTACK! Hex 01 chars in options\n",
	$EXIT_PRNERR_NORETRY_BAD_SETTINGS);
}
my $argstr = "\x01" . join("\x01",@ARGV) . "\x01";

# ==========================================================================
#
#    Config file filter.conf settings - defaults
#
# ==========================================================================

## Config file

# Read config file if present
# Location of the configuration file "filter.conf", this file can be
# used to change the settings of foomatic-rip without editing
# foomatic-rip. itself. This variable must contain the full pathname
# of the directory which contains the configuration file, usually
# "/etc/foomatic".

while ($argstr =~ s/^\x01+\s*--config(\x01+|=|)([^\x01]+)[\x01]/\x01/) {
    $configfile = $2;
}
if ($argstr =~ s/\x01\s*--config(\x01+|=|)([^\x01]+)[\x01]/\x01/) {
	rip_die("SECURITY ATTACK! --config option not first option\n",
	    $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
}

my %conf = readConfFile($configfile);

# Get execution path from config file
$execpath = $conf{execpath} if defined $conf{execpath};
$ENV{'PATH'} = $execpath;
# For the stuff below, the settings in the configuration file have priority.

# Get TMPDIR setting from configuration information

my $tmpdir = ($conf{TMPDIR} || $conf{tmpdir} ||
	$ENV{TMPDIR} || $ENV{TEMP} || $ENV{TMP} );
if( not $tmpdir ){
	rip_die("SECURITY LOOPHOLE! no explicit or inherited TMPDIR set\n",
	     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
}

$ENV{TMPDIR} = $tmpdir;
$ENV{TEMP} = $tmpdir;
$ENV{TMP} = $tmpdir;


# Set to 1 to insert postscript code for page accounting (CUPS only).
my $ps_accounting = ($conf{ps_accounting} || 1 );
my $accounting_prolog = '';

# Enter here your personal command for converting non-postscript files
# (especially text) to PostScript. If you leave it blank, at first the
# line "textfilter: ..." from /etc/foomatic/filter.conf is read and
# then the commands given on the list below are tried, beginning with
# the first one.
# You can set this to "a2ps", "enscript" or "mpage" to select one of the
# default command strings.

# What 'echo' program to use.  It needs -n.  Linux's builtin
# and /bin/echo echo work. You may need to install gnu echo
# and specify gecho in the config file.
#

my $myecho = ($conf{echo} || 'echo');

# End interesting enduser options

## Some important variables

# We don't know yet, which spooler will be used. If we don't detect
# one.  we assume that we do spooler-less printing. Supported spoolers
# are currently:

#    cups    - CUPS - Common Unix Printing System
#    lpd     - LPD - Line Printer Daemon
#    lprng   - LPRng - LPR - New Generation
#    gnulpr  - GNUlpr, an enhanced LPD (development stopped)
#    ppr     - PPR (foomatic-rip runs as a PPR RIP)
#    ppr_int - PPR (foomatic-rip runs as an interface)
#    cps     - CPS - Coherent Printing System
#    pdq     - PDQ - Print, Don't Queue (development stopped)
#    direct  - Direct, spooler-less printing


# processes and file handles

my( $debugpid, $docgeneratorpid, $postpipepid, $fileconverterpid, $renderpid, $fixuppid )
  = (0,0,0,0,0,0,0);
my( $renderhandle );

# debugging control
$Data::Dumper::Indent=1;

$spooler = 'direct';

# PPD file name
my $ppdfile = '';

# Printer model
my $model = '';

# Printer queue name
$printer = '';

# Printing options
my $optstr = '';

# Command line options;
my $xcmd_option = {};

# Job title
my $jobtitle = '';

# Post pipe (command into which the output of this filter should be piped)
my $postpipe = '';

# Files to be printed
my @filelist = ();

# JCL prefix to put before the JCL options (Can be modified by a
# "*JCLBegin:" keyword in the PPD file):
my $jclbegin = "\033%-12345X\@PJL\n";

# JCL command to switch the printer to the PostScript interpreter (Can
# be modified by a "*JCLToPSInterpreter:" keyword in the PPD file):
my $jcltointerpreter = '';

# JCL command to close a print job (Can be modified by a "*JCLEnd:"
# keyword in the PPD file):
my $jclend = "\033%-12345X\@PJL RESET\n";

# Under which name were we called and in which directory do we reside
$0 =~ m!^(.*/)([^/]+)$!;
my $programdir = $1;
my $programname = $2;

# Filters to convert non-PostScript files
# spooler specific

# default filters  - try in this order

my @fileconverters = (
   # a2ps (converts also other files than text)
   'a2ps -1 @@--medium=@@PAGESIZE@@ @@--center-title=@@JOBTITLE@@ -o -',
   # enscript
   'enscript -G @@-M @@PAGESIZE@@ @@-b "Page $%|@@JOBTITLE@@ ' .
   '--margins=36:36:36:36 --mark-wrapped-lines=arrow --word-wrap -p-',
   # mpage
   'mpage -o -1 @@-b @@PAGESIZE@@ @@-H -h @@JOBTITLE@@ -m36l36b36t36r ' .
   '-f -P- -'
);

# for filter support
my @fixed_args = (
	defined($ARGV[0])?$ARGV[0]:'',
	defined($ARGV[1])?$ARGV[1]:'',
	defined($ARGV[2])?$ARGV[2]:'',
	defined($ARGV[3])?$ARGV[3]:'',
	defined($ARGV[4])?$ARGV[4]:'' );

my $spoolerfileconverters = {
    'cups' =>
	"texttops '$fixed_args[0]' '$fixed_args[1]' '$fixed_args[2]' " .
	" '$fixed_args[3]' '$fixed_args[4] page-top=36 page-bottom=36 " .
	" page-left=36 page-right=36 nolandscape cpi=12 lpi=7 " .
	" columns=1 wrap'"

    };

# Determine which filter to use for non-PostScript files to be converted
# to PostScript.  We can specify a full path or simply
# the name of one of the filters

my $fileconverter = ($conf{textfilter} || '');

## Environment variables;

# "PPD": PPD file name for CUPS or PPR (if we run as PPR RIP)
if (defined($ENV{'PPD'})) {
    $ppdfile = $ENV{'PPD'};
    # CUPS and PPR (RIP filter) use the "PPD" environment variable to
    # make the PPD file name available (we set CUPS here preliminarily,
    # in the next step we check for PPR
    $spooler = 'cups';
}

# "PPR_VERSION": PPR
if (defined($ENV{'PPR_VERSION'})) {
    # We have PPR
    $spooler = 'ppr';
}

# "PPR_RIPOPTS": PPR
if (defined($ENV{'PPR_RIPOPTS'})) {
    # PPR 1.5 allows the user to specify options for the PPR RIP with the
    # "--ripopts" option on the "ppr" command line. They are provided to
    # the RIP via the "PPR_RIPOPTS" environment variable.
    $optstr .= "$ENV{'PPR_RIPOPTS'} ";
    # We have PPR
    $spooler = 'ppr';
}

# "LPOPTS": Option settings for some LPD implementations (ex: GNUlpr)
if (defined($ENV{'LPOPTS'})) {
    my @lpopts = split(/,/, $ENV{'LPOPTS'});
    foreach my $opt (@lpopts) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We have an LPD which accepts "-o" for options
    $spooler = 'gnulpr';
}

############## Precedence ################
# Set the precedence of option setting methods:
#  PPD file (lowest)
#  *FoomaticSystemOption Defaults: "key=value key=value"
#  Postscript file BeginFeature or FoomaticRIPOptionSetting
#  command line
#  *FoomaticSystemOption Permanent: "key=value key=value"

my %Precedence_values = (
	ppd => 1,
	optionsdefault => 2,
	file => 3,
	command => 4,
	optionspermanent => 5
);

## Named command line options


# Set up the debugging and logging

# Set debug to 1 to enable the debug logfile for this filter; it will
# appear as defined by $logfile. It will contain status from this
# filter, plus the renderer's stderr output. You can also add a line
# "debug: 1" to your /etc/foomatic/filter.conf to get all your
# Foomatic filters into debug mode.
#
# This is the location of the debug logfile (and also the copy of the
# processed PostScript data) in case you have enabled debugging above.
# The logfile will get the extension ".log", the PostScript data ".ps".

# Set debug mode
$debug = oct($conf{debug} || 0);

# Debug mode activated via command line
while ($argstr =~ s/\x01\s*--debug(=|\x01+)([\da-fA-Fx]+)\x01/\x01/) {
    $debug = oct($2);
}
$debug = 0 if not $conf{enabledebug};

# Command line options for verbosity.  Handle duplicates
my $quiet = (($argstr =~ s/\x01-q\x01/\x01/g) ||0);
my $verbose = (($argstr =~ s/\x01-v\x01/\x01/g) ||0);
my $show_docs = (($argstr =~ s/\x01-d\x01/\x01/g) || 0);
$quiet = 0 if( $verbose );

my $logfile = ($conf{logfile} || "/tmp/foomatic-rip");
# use the last specified logfile
while( $argstr =~ s/\x01--log(=|\x01+)([^\x01]+)\x01/\x01/ ){
    $logfile = $2;
}

my $genppd;
while( $argstr =~ s/\x01--genppd\x01/\x01/ ){
    $genppd = 1;
}

my $do_docs = $show_docs;

$debugpid = (InitDebugging( $debug, $logfile, $quiet ) or 0);

## Start debug logging
if ($debug) {
    # If we are not debug mode, we do this later, as we must find out at
    # first which spooler is used. When printing without spooler we
    # suppress logging because foomatic-rip is called directly on the
    # command line and so we avoid logging onto the console.
    D0("foomatic-rip version $ripversion running...\n");
    # Print the command line only in debug mode. Mac OS X adds very many
    # options so that CUPS cannot handle the output of the command line
    # in its log files. If CUPS encounters a line with more than 1024
    # characters sent into its log files, it aborts the job with an error.
    my $line =  "'" . join("', '",@ARGV) . "'";
    # D1("LINE $line");
    trim_options( "Options: " . $line, 60, "   ");
}

{ my @t = gettimeofday(); D0("START XX " . localtime($t[0]) . " " . $t[1]); }

## Continue with named options

# Check for LPRng first so we do not pick up bogus ppd files by the -p option
if ($argstr =~ s/\x01--lprng\x01/\x01/g) {
    # We have LPRng
    $spooler = 'lprng';
}

# if 'PRINTCAP_ENTRY' environment variable is set we have LPRng
# the :ppd=/path/to/ppdfile printcap entry should be used if present
if (defined($ENV{'PRINTCAP_ENTRY'})){
    $spooler = 'lprng';
    my( @pc);
    @pc = split( /\s*(?<!\\):\s*/, $ENV{'PRINTCAP_ENTRY'} );
    shift @pc;
    foreach (@pc) {
	s/\@$/=0/; s/\#/=/g; if( not /=/ ){ s/$/=1/; }
	my( $key, $value ) = split('=', $_, 2 );
	$ppdfile = $value if $key eq 'ppd' or $key eq 'ppdfile';
    }
}

if ($argstr =~ s/\x01--lprng\x01/\x01/g) {
    # We have LPRng
    $spooler = 'lprng';
}


# PPD file name given via the command line
# allow duplicates, and use the last specified one
# command line overrides the printcap PPD for LPRng
while ( ($spooler ne 'lprng') and ($argstr =~ s/\x01-p(\x01|)([^\x01]+)\x01/\x01/)) {
    $ppdfile = $2;
}
while ($argstr =~ s/\x01--ppd(\x01|=)([^\x01]+)\x01/\x01/) {
    $ppdfile = $2;
}

# Check for LPD/GNUlpr by typical options which the spooler puts onto
# the filter's command line (options "-w": text width, "-l": text
# length, "-i": indent, "-x", "-y": graphics size, "-c": raw printing,
# "-n": user name, "-h": host name)
if (($argstr =~ s/\x01-w(\x01|)\d+\x01/\x01/) ||
    ($argstr =~ s/\x01-l(\x01|)\d+\x01/\x01/) ||
    ($argstr =~ s/\x01-x(\x01|)\d+\x01/\x01/) ||
    ($argstr =~ s/\x01-y(\x01|)\d+\x01/\x01/) ||
    ($argstr =~ s/\x01-i(\x01|)\d+\x01/\x01/) ||
    ($argstr =~ s/\x01-c\x01/\x01/) ||
    ($argstr =~ s/\x01-n(\x01|)[^\x01]+\x01/\x01/) ||
    ($argstr =~ s/\x01-h(\x01|)[^\x01]+\x01/\x01/)) {
    # We have LPD or GNUlpr
    if (($spooler ne 'lpd') && ($spooler ne 'gnulpr') && ($spooler ne 'lprng')) {
	$spooler = 'lpd';
    }
}

# LPRng delivers the option settings via the "-Z" argument
while ($argstr =~ s/\x01-Z(\x01|)([^\x01]+)\x01/\x01/) {
    my @lpopts = split(/,/, $2);
    foreach my $opt (@lpopts) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We have LPRng
    $spooler = 'lprng';
}

# Job title and options for stock LPD
if ($argstr =~ s/\x01-[J](\x01|)([^\x01]+)\x01/\x01/) {
    # An LPD option
	$xcmd_option->{'J'} = $2;
	$jobtitle = $2;
	# Classic LPD hack
	if ($spooler eq "lpd" and $jobtitle ) {
		$optstr .= "$jobtitle ";
	}
}

# Check for CPS
if ($argstr =~ s/\x01--cps\x01/\x01/) {
    # We have cps
    $spooler = 'cps';
}

# Options for spooler-less printing, CPS, or PDQ
while ($argstr =~ s/\x01-o(\x01|)([^\x01]+)\x01/\x01/) {
    my $opt = $2;
    $opt =~ s/^\s+//;
    $opt =~ s/\s+$//;
    if ($opt =~ /\s+/) {
	$opt = "\"$opt\"";
    }
    $optstr .= "$opt ";
    # If we don't print as a PPR RIP or as a CPS filter, we print without
    # spooler (we check for PDQ later)
    if (($spooler ne 'ppr') && ($spooler ne 'cps')) {
	$spooler = 'direct';
    }
}

# Printer for spooler-less printing or PDQ
if ($argstr =~ s/\x01-d(\x01|)([^\x01]+)\x01/\x01/) {
    $printer = $2;
}
# Printer for spooler-less printing, PDQ, or LPRng
if ($argstr =~ s/\x01-P(\x01|)([^\x01]+)\x01/\x01/) {
    $printer = $2;
}

# Were we called from a PDQ wrapper?
if ($argstr =~ s/\x01--pdq\x01/\x01/) {
    # We have PDQ
    $spooler = 'pdq';
}


# Were we called to build the PDQ driver declaration file?
# "--appendpdq=<file>" appends the data to the <file>,
# "--genpdq=<file>" creates/overwrites <file> for the data, and
# "--genpdq" writes to standard output
my $genpdqfile = '';
if (($argstr =~ s/\x01--(gen)(raw|)pdq(\x01|=|)([^\x01]*)\x01/\x01/) ||
    ($argstr =~ s/\x01--(append)(raw|)pdq(\x01|=|)([^\x01]+)\x01/\x01/)) {
    # Determine output file name
    if (!$4) {
	$genpdqfile = ">&STDOUT";
    } else {
	if ($1 eq 'gen') {
	    $genpdqfile = "> $4";
	} else {
	    $genpdqfile = ">> $4";
	}
    }
    # Do we want to have a PDQ driver declaration for a raw printer?
    if ($2 eq 'raw') {
	my $time = time();
	open PDQFILE, $genpdqfile or
	    rip_die("Cannot write PDQ driver declaration file '$genpdqfile' - $!",
		    $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	print PDQFILE <<EOF;
driver \"Raw-Printer-$time\" {
  # This PDQ driver declaration file was generated automatically by
  # foomatic-rip to allow raw (filter-less) printing.
  language_driver all {
    # We accept all file types and pass them through without any changes
    filetype_regx \"\"
    convert_exec {
      ln -s \$INPUT \$OUTPUT
    }
  }
  filter_exec {
    ln -s \$INPUT \$OUTPUT
  }
}
EOF
	close PDQFILE;
	exit $EXIT_PRINTED;
    }
    # We have PDQ
    $spooler = 'pdq';
}

# we tidy up the last arguments and remove any LPD options
if( $spooler eq 'lpd' or $spooler eq 'lprng' or $spooler eq 'gnulpr' ){
	if ($argstr =~ s/\x01-([a-bd-zA-Z])(\x01|)([^\x01]+)\x01/\x01/) {
		# An LPD option
		$xcmd_option->{$1} = $3;
	}
}

my @rargs = split(/\x01/, $argstr);
shift @rargs;


## When we print without spooler or with CPS do not log onto STDERR unless
## the "-v" ('Verbose') is set or the debug mode is used
if ((($spooler eq 'direct') || ($spooler eq 'cps') || ($genpdqfile)) &&
    (!$verbose) && (!$debug)) {
	$quiet = 1;
	InitDebugging( $debug, $logfile, $quiet );
}


# remove extra spacing if running as LPRng filter
$added_lf = '' if $spooler eq 'lprng';

## Command line arguments without name


# Load definitions for PPR error messages, check whether we run as
# PPR interface or as PPR RIP
my( $ppr_printer, $ppr_address, $ppr_options, $ppr_jobbreak, $ppr_feedback,
	$ppr_codes, $ppr_jobname, $ppr_routing, $ppr_for, $ppr_filetype,
	$ppr_filetoprint );

if ($spooler eq 'ppr') {
    # Read interface.sh so we will know the correct exit codes and
    # also signal.sh for the signal codes
    my $deffound = 0; # Did we find one of the definition files
    my @definitions;
    for my $file (("lib/interface.sh", "lib/signal.sh")) {
	
	open FILE, "$file" || do {
	    D0("error opening $file.\n");
	    next;
	};
	
	$deffound = 1;
	while(my $line = <FILE>) {
	    # Translate the shell script to Perl
	    if (($line !~ m/^\s*$/) && ($line !~ m/^\s*\#/)) {
		$line =~ s/^\s*([^\#\s]*)/\$$1;/;
		push (@definitions, $line);
	    }
	}
	close FILE;
    }

    if ($deffound) {
	# Apply the definitions loaded from PPR
	eval join('',@definitions) || do {
	    D0("unable to evaluate definitions\n");
	    rip_die ("Error in definitions evaluation",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	};
    }

    # Check whether we run as a PPR interface (if not, we run as a PPR RIP)
    if (($rargs[3] =~ /^\s*\d\d?\s*$/) &&
	($rargs[5] =~ /^\s*\d\d?\s*$/) &&
	(($#rargs == 10) || ($#rargs == 9) || ($#rargs == 7))) {
	# PPR calls interfaces with many command line parameters,
	# where the forth and the sixth is a small integer
	# number. In addition, we have 8 (PPR <= 1.31), 10
	# (PPR>=1.32), 11 (PPR >= 1.50) command line parameters.
	# We also check whether the current working directory is a
	# PPR directory.
	
	# Get all command line parameters
	$ppr_printer = $rargs[0];
	$ppr_address = $rargs[1];
	$ppr_options = $rargs[2];
	$ppr_jobbreak = $rargs[3];
	$ppr_feedback = $rargs[4];
	$ppr_codes = $rargs[5];
	$ppr_jobname = $rargs[6];
	$ppr_routing = $rargs[7];
	$ppr_for = $rargs[8];
	$ppr_filetype = $rargs[9];
	$ppr_filetoprint = $rargs[10];
	
	# Common job parameters
	$printer = $ppr_printer;
	$jobtitle = $ppr_jobname;
	if ((!$jobtitle) && ($ppr_filetoprint)) {
	    $jobtitle = $ppr_filetoprint;
	}
	$optstr .= "$ppr_options $ppr_routing";
	
	# Get the path of the PPD file from the queue configuration
	$ppdfile = `LANG=en_US; ppad show $ppr_printer | grep PPDFile`;
	$ppdfile =~ s/PPDFile:\s+//;
	if ($ppdfile !~ m!^/!) {
	    $ppdfile = "../../share/ppr/PPDFiles/$ppdfile";
	}
	chomp($ppdfile);
	
	# We have PPR and run as an interface
	$spooler = 'ppr_int';
    }
}

# CUPS
if ($spooler eq 'cups') {
    my( $cups_jobid, $cups_user, $cups_jobtitle, $cups_copies, $cups_options,
	$cups_filename );
    # Get all command line parameters
    $cups_jobid = $rargs[0];
    $cups_user = $rargs[1];
    $cups_jobtitle = $rargs[2];
    $cups_copies = $rargs[3];
    $cups_options = $rargs[4];
    $cups_filename = $rargs[5];

    # Common job parameters
    $jobtitle = $cups_jobtitle;
    $optstr .= $cups_options;

    # Check for and handle inputfile vs stdin
    if ((defined($cups_filename)) && ($cups_filename) &&
	($cups_filename ne '-')) {
	# We get the input from a file
	@filelist = ($cups_filename);
	D0("Getting input from file $cups_filename\n");
    }
}

# LPD/LPRng/GNUlpr
if (($spooler eq 'lpd') ||
    ($spooler eq 'lprng' and !$ppdfile) ||
    ($spooler eq 'gnulpr')) {

    # Get PPD file name as the last command line argument
    $ppdfile = pop @rargs;
}


# No spooler, CPS, or PDQ
if (($spooler eq 'direct') || ($spooler eq 'cps') || ($spooler eq 'pdq')) {
    # Which files do we want to print?
    @filelist = @rargs;
}



## Additional spooler-specific preparations

# CUPS

if ($spooler eq 'cups') {

    # This piece of PostScript code (initial idea 2001 by Michael
    # Allerhand (michael.allerhand at ed dot ac dot uk, vastly
    # improved by Till Kamppeter in 2002) lets GhostScript output
    # the page accounting information which CUPS needs on standard
    # error.

    if( $ps_accounting ){
	$accounting_prolog = <<'EOF';
[{
%% Code for writing CUPS accounting tags on standard error

/cupsPSLevel2 % Determine whether we can do PostScript level 2 or newer
    systemdict/languagelevel 2 copy
    known{get exec}{pop pop 1}ifelse 2 ge
def

/cupsGetNumCopies { % Read the number of Copies requested for the current
		    % page
    cupsPSLevel2
    {
	% PS Level 2+: Get number of copies from Page Device dictionary
	currentpagedevice /NumCopies get
    }
    {
	% PS Level 1: Number of copies not in Page Device dictionary
	null
    }
    ifelse
    % Check whether the number is defined, if it is "null" use #copies
    % instead
    dup null eq {
	pop #copies
    }
    if
    % Check whether the number is defined now, if it is still "null" use 1
    % instead
    dup null eq {
	pop 1
    } if
} bind def

/cupsWrite { % write a string onto standard error
    (%stderr) (w) file
    exch writestring
} bind def

/cupsEndPage { % write page log info when we were invoked by "showpage"
	       % or "copypage" return "true" or "false" as we had no
	       % redefinition of "EndPage"

    2 ne % If the reason code is 0 or 1, we have finshed a page
	 % (we were invoked by "showpage" or "copypage"),
         % write log info and exit with "true" to push out the page.
	 % In case of reason code 2, we are invoked during device
	 % deactivation (happens also at a "setpagedevice" call),
	 % here we should not log and return "false"
    {
	% write "Page <# of page> <# of copies><LF>" to stderr
	(PAGE: ) cupsWrite
	% we must add 1 here, the number on the stack is the number
	% of "showpage" already executed during this job
	1 add 40 string cvs cupsWrite
	% space
	( ) cupsWrite
	% get the number of copies for this page
	cupsGetNumCopies 40 string cvs cupsWrite
	% line feed
	(n) cupsWrite
	% page should be ejected
	true
    }
    {
	pop % ignore the number of pages already printed
	% do not eject paper
	false
    }
    ifelse
} bind def

<</EndPage{cupsEndPage}>>setpagedevice
} stopped cleartomark

EOF
    }
    # On which queue are we printing?
    # CUPS gives the PPD file the same name as the printer queue,
    # so we can get the queue name from the name of the PPD file.
    $ppdfile =~ m!^(.*/)([^/]+)\.ppd$!;
    $printer = $2;
}

# No spooler, CPS, or PDQ

if (($spooler eq 'direct') || ($spooler eq 'cps') || ($spooler eq 'pdq')) {

    # Path for personal Foomatic configuration
    my $user_default_path = "$ENV{'HOME'}/.foomatic";

    if (!$ppdfile) {
	if (!$printer) {
	    # No printer definition file selected, check whether we have a
	    # default printer defined.
	    for my $conf_file (("./.directconfig",
				"./directconfig",
				"./.config",
				"$user_default_path/direct/.config",
				"$user_default_path/direct.conf",
				"$sysconfdir/direct/.config",
				"$sysconfdir/direct.conf")) {
		if (open CONFIG, "< $conf_file") {
		    while (my $line = <CONFIG>) {
			chomp $line;
			if ($line =~ /^default\s*:\s*([^:\s]+)\s*$/) {
			    $printer = $1;
			    last;
			}
		    }
		    close CONFIG;
		}
		if ($printer) {
		    last;
		}
	    }
	}

	# Neither in a config file nor on the command line a printer was
	# selected.
	if (!$printer) {
	    rip_die("No printer definition (option \"-P <name>\") " .
		    "specified!", $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
	
	# Search for the PPD file
	
	# Search also common spooler-specific locations, this way a printer
	# configured under a certain spooler can also be used without
	# spooler

	if (-r $printer) {
	    $ppdfile = $printer;
	# CPS can have the PPD in the spool directory
	} elsif (($spooler eq 'cps') &&
		 (-r "/var/spool/lpd/${printer}/${printer}.ppd")) {
	    $ppdfile = "/var/spool/lpd/${printer}/${printer}.ppd";
	} elsif (($spooler eq 'cps') &&
		 (-r "/var/local/spool/lpd/${printer}/${printer}.ppd")) {
	    $ppdfile = "/var/local/spool/lpd/${printer}/${printer}.ppd";
	} elsif (($spooler eq 'cps') &&
		 (-r "/var/local/lpd/${printer}/${printer}.ppd")) {
	    $ppdfile = "/var/local/lpd/${printer}/${printer}.ppd";
	} elsif (($spooler eq 'cps') &&
		 (-r "/var/spool/lpd/${printer}.ppd")) {
	    $ppdfile = "/var/spool/lpd/${printer}.ppd";
	} elsif (($spooler eq 'cps') &&
		 (-r "/var/local/spool/lpd/${printer}.ppd")) {
	    $ppdfile = "/var/local/spool/lpd/${printer}.ppd";
	} elsif (($spooler eq 'cps') &&
		 (-r "/var/local/lpd/${printer}.ppd")) {
	    $ppdfile = "/var/local/lpd/${printer}.ppd";
	} elsif (-r "${printer}.ppd") { # current dir
	    $ppdfile = "${printer}.ppd";
	} elsif (-r "$user_default_path/${printer}.ppd") { # user dir
	    $ppdfile = "$user_default_path/${printer}.ppd";
	} elsif (-r "$sysconfdir/direct/${printer}.ppd") { # system dir
	    $ppdfile = "$sysconfdir/direct/${printer}.ppd";
	} elsif (-r "$sysconfdir/${printer}.ppd") { # system dir
	    $ppdfile = "$sysconfdir/${printer}.ppd";
	} elsif (-r "/etc/cups/ppd/${printer}.ppd") { # CUPS config dir
	    $ppdfile = "/etc/cups/ppd/${printer}.ppd";
	} elsif (-r "/usr/local/etc/cups/ppd/${printer}.ppd") {
	    $ppdfile = "/usr/local/etc/cups/ppd/${printer}.ppd";
	} elsif (-r "/usr/share/ppr/PPDFiles/${printer}.ppd") { # PPR PPDs
	    $ppdfile = "/usr/share/ppr/PPDFiles/${printer}.ppd";
	} elsif (-r "/usr/local/share/ppr/PPDFiles/${printer}.ppd") {
	    $ppdfile = "/usr/local/share/ppr/PPDFiles/${printer}.ppd";
	} else {
	    rip_die ("There is no readable PPD file for the printer " .
		     "$printer, is it configured?",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
    }
}



## Files to be printed (can be more than one for spooler-less printing)

# Empty file list -> print STDIN
if (@filelist == 0) {
    push @filelist, "<STDIN>";
} else {
    my @f = grep { /^-/ } @filelist;
    if( @f ){
	rip_die ("Invalid argument: @f",
	     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
}


## Start logging
if (!$debug) {
    # If we are in debug mode, we do this earlier.
    D0("foomatic-rip version $ripversion running...\n");
    # Print the command line. Mac OS X adds very many
    # options so that CUPS cannot handle the output of the command line
    # in its log files. If CUPS encounters a line with more than 1024
    # characters sent into its log files, it aborts the job with an error.
    my $line = "Options: ". join("', '",@ARGV) . "'";
    trim_options(  $line, 60, "   ");
}



## PPD file
$ppdfile =~ s/^\s+//;
$ppdfile =~ s/\s+$//;

{ my @t = gettimeofday(); D0("START PARSING XX " . localtime($t[0]) . " " . $t[1]); }

D0("Parsing PPD file '$ppdfile' ...\n");
my $dat = {};

ppdtoperl($dat, $ppdfile, \%conf);              # data structure for the options
{ my @t = gettimeofday(); D0("END PARSING XX " . localtime($t[0]) . " " . $t[1]); }
if( $genppd ){
    { my @t = gettimeofday(); D0("START MAKE PPD XX " . localtime($t[0]) . " " . $t[1]); }
    ppdfromperl($dat,0,0);
    print $dat->{'out'};
    { my @t = gettimeofday(); D0("END MAKE PPD XX " . localtime($t[0]) . " " . $t[1]); }
    exit 0;
}

# We now fix up the various values of system options and PPD specified precedence
{
    # save the xcmd_option
    $dat->{cmd_option} = $xcmd_option;

    # fix up the JobPatchFile precedence
    my( $arg );
    if( ($arg = argbyname($dat, 'JobPatchFile')) ){
	my $lang = 'ps';
	$arg->{'type'} = 'pickmany';
	my $val = fix_pickmany( $arg, '' );
	D10("Fix JobPatchFile: start pickmany default $val");
	$val =~ s/\,no/,/g;
	$val =~ s/^no//g;
	$arg->{'default'} = $val;
	$arg->{'section'}{$lang} = 'AnySetup';
	$arg->{'order'}{$lang} = 0;
	D10("Fix JobPatchFile: final pickmany default $arg->{default}, order 0");
	$arg->{'precedence'} = $Precedence_values{optionspermanent};
    }

    my $value = ($dat->{foomatic_option}{'aliases'} || '');
    foreach my $entry (split(' ', $value) ){
	D10("ALIAS: value '$entry'");
	my($key,$value) = split('=',$entry,2);
	$key = lc(unhtmlify($key));
	$value = lc(unhtmlify($value));
	D10("   alias '$key' = '$value'");
	$dat->{'aliases'}{$key} = $value;
    }
    # *FoomaticSystemOption ForceInsert: " 0,Prolog:JobPatchFile=* "
    #
    # %% force this to be put into Prolog
    # *JobPatchFile 1: "
    # %% The initial Deferred MediaSelection value is not predictible
    #  << /DeferredMediaSelection true /MediaPosition 9 /ManualFeed false >> setpagedevice"
    # *End
    #
    #
    #Syntax:
    #
    #   [[Order,]Section:](language)OptionName[=Value]
    #   Order    - order in section; default is 0 (i.e. - start)
    #   Section  - the section to use;  default is AnySetup
    #     possible values:
    #         Prolog, DocumentSetup, PageSetup, AnySetup, JCLSetup, etc.
    #
    #   OptionName - (case insensitive) Option name
    #
    #     Value    Action
    #     (none)   Adds the current option value to the section
    #              (i.e.- PickOne option)
    #     value    Adds the specified option value to the section
    #              (i.e. - PickOne option with non-changeable value)
    #     *        Adds all values to the section
    #              (i.e. - PickMany, all selected, and non-changeable)
    $value = ($dat->{foomatic_option}{'forceinsert'} || '');
    foreach my $entry ( split(' ', $value) ){
	#   [[Order,]Section:]OptionName[=Value]
	my($order, $section, $name,$set,$lang,$val);
	D1("ForceInsert: value $entry");
	if( not( ($name,$set,$val) = $entry =~ m!^([^=]*)(=?)(.*)$!x ) ){
	    D0("Bad ForceInsert option '$entry'");
	    next;
	}
	($order, $name) = ($1, $2) if( $name =~ m!^(.*?),(.*)$! );
	($section,$name) = ($1, $2) if $name =~ m!^(.*?):(.*)$!;
	($lang,$name) = ($1, $2) if $name =~ m!^(JCL|PJL|PCL|)(.*)$!;

	$lang = fix_lang($lang);
	$val = '' if not defined $val;
	$order = 0 if not defined $order;
	$section = 'AnySetup' if not defined $section;
	D10("ForceInsert: entry '$entry' <option> '$name' <value> '$val' <section> '$section'");
	my $arg = argbyname( $dat, $name );
	if( not $arg ){
	    D0("ForceInsert: $entry - unknown option name");
	    next;
	}
	$arg->{'section'}{$lang} = $section;
	$arg->{'order'}{$lang} = $order;
	if( $val ){
	    if( $val ne '*' ){
		$arg->{'type'} = 'enum';
		$arg->{'default'} = $val;
		$arg->{'precedence'} = $Precedence_values{optionspermanent};
	    } else {
		$arg->{'type'} = 'pickmany';
		$val = fix_pickmany( $arg, '' );
		$val =~ s/,no/,/g;
		$val =~ s/^no//g;
		$arg->{'default'} = $val;
		D10("ForceInsert: final pickmany default $arg->{default}");
		$arg->{'precedence'} = $Precedence_values{optionspermanent};
	    }
	}
    }

    # PageRegion
    #  *FoomaticSystemOption PageRegion: " True "
    #  *FoomaticSystemOption PageRegion: " InputSlot!=Auto "
    # 
    # Syntax:
    #   Value         Action
    #   Option=Value  Use PageRegion when Option has this Value
    #   Option!=Value Use PageRegion when Option does not have this Value
    $value = ($dat->{foomatic_option}{'usepageregion'} or '');
    foreach my $entry ( split(' ', $value) ){
	#   [[Order,]Section:]OptionName[=Value]
	my $other;
	D10("UsePageRegion: entry $entry");
	my($name,$set,$val) = $entry =~ m!^([^\!\=]*)(\!?\=)(.*)$!;
	D10("UsePageRegion: name '$name' set '$set' value '$val'");
	my $arg = argbyname( $dat, $name );
	if( not $arg ){
	    D0("PageRegion: $entry - unknown option name");
	    next;
	}
	$name = $arg->{'name'};
	if( $set eq "!=" ){
	    $set = 'False';
	    $other = 'True';
	} else {
	    $set = 'True';
	    $other = 'False';
	}
	if( $dat->{usepageregion}{$name}{$other} ){
	    D0("PageRegion: $entry - $other value already set");
	    next;
	}
	my $v = $dat->{usepageregion}{$name}{$set};
	if( $set eq 'False' ){
	    my @key = keys %{$v};
	    if( @key && $key[0] ne $val ){
		D0("PageRegion: $entry - $set value for @key already set");
		next;
	    }
	}
	$v->{$val}= 1;
	$dat->{usepageregion}{$name}{$set} = $v;
    }
}

D1("Parsed: " . Dumper($dat));

#
# we get the list of composite options and expand them
#
my @opts = ();

for my $argname (@{$dat->{'args'}}) {
    my $arg = $dat->{'args_byname'}{$argname};
    $arg->{'precedence'} = $Precedence_values{ppd};
}

foreach my $argname (@{$dat->{'args'}}){
    my $arg = $dat->{'args_byname'}{$argname};
    push @opts, "$arg->{name}=\"$arg->{default}\""
	if defined $arg->{'argstyle'}{'composite'};

}

# now we fix the defaults for the PPD file defaults
if( @opts ){
    D0("Expanding Composite Option Defaults\n");
    expandoptions( $dat, \@opts, 'default', 1, $Precedence_values{ppd}, "User Options: " );
}

# now we set the defaults from the PPD file
@opts = split(' ',($dat->{foomatic_option}{default} ||''));
if( @opts ){
    expandoptions( $dat, \@opts, 'default', 1, $Precedence_values{optionsdefault}, "User Options: " );
}

@opts = split(' ',($dat->{foomatic_option}{permanent}||''));
if( @opts ){
    expandoptions( $dat, \@opts, 'default', 1, $Precedence_values{optionspermanent}, "User Options: " );
}

# and we have no options
$dat->{'default'} = undef;

# set the model name
$model = ($dat->{'makemodel'} || $dat->{'make'}." ".$dat->{'model'});

## We do not need to parse the PostScript job when we don't have
## any options. If we have options, we must check whether the
## default settings from the PPD file are valid and correct them
## if nexessary.

## START OPTIONS PROCESSING


my $dontparse = 0;
if ( !@{$dat->{'args'}} ) {
    # We don't have any options, so we do not need to parse the
    # PostScript data
    D1("No PPD options");
    $dontparse = 1;
}

# Was the RIP command line defined in the PPD file? If not, we assume a
# PostScript printer and do not render/translate the input data
if (!defined($dat->{'cmd'})) {
    $dat->{'cmd'} =
	"cat ".(join('',(map { '%' . $_ } 'A' .. 'Z')));
    if ($dontparse) {
	# No command line, no options, we have a raw queue, don't check
	# whether the input is PostScript and ignore the "docs" option,
	# simply pass the input data to the backend.
	$dontparse = 2;
	$model = "Raw queue";
    }
}

## Summary for debugging
D0("${added_lf}Parameter Summary\n");
D0("-----------------${added_lf}\n");
D0("Spooler: $spooler\n");
D0("Printer: $printer\n");
D0("PPD file: $ppdfile\n");
D0("Printer model: $model\n");

# Print the options string only in debug mode.
# Split up the options into about 80 character or a bit longer pieces
#
if ($debug){
    my $line = $optstr;
    trim_options( "Options: " . $line, 60, "   ");
}

D0("Job title: $jobtitle\n");
D0("File(s) to be printed: ${added_lf}@filelist${added_lf}\n");


## Parse options from command line ($optstr)

# The options are "foo='bar nut'", "foo", "nofoo", "'bar nut'", or
# "foo:'bar nut'" (when GPR was used) all with spaces between...
# In addition they can be preceeded by page ranges, separated with a
# colon.

@opts = ();

# Variable for PPR's backend interface name (parallel, tcpip, atalk, ...)

my $backend = '';

# Array to collect unknown options so that they can get passed to the
# backend interface of PPR. For other spoolers we ignore them.

my @backendoptions = ();

$optstr =~ s/^\s+//;
D20("Option string: starting '$optstr'");
while( $optstr ){
    D20("Option string: LOOP '$optstr'");
    if
    # foo='bar nut'
	($optstr =~ s!^(((even|odd|[\d,-]+):|)\w+=[\'\"].*?[\'\"])( |$)!!i) {
	D20("Option X21: $1");
	push (@opts, $1);
    } elsif 
    # foo:'bar nut' (GPR separates option and setting with a colon ":")
	($optstr =~ s!^(((even|odd|[\d,-]+):|)\w+:[\'\"].*?[\'\"])( |$)!!i) {
	push (@opts, $1);
	D20("Option X22: $1");
    } elsif
    # 'bar nut', 'foo=bar nut', 'foo:bar nut'
    ($optstr =~ s!^([\'\"].+?[\'\"])( |$)!!) {
	my $opt = $1;
	$opt =~ s/[\'\"]//g; # Make only sure that we didn't quote
			     # the option for a second time when we read
			     # rge options from the command line or
			     # environment variable

	D20("Option X23: $opt");
	push (@opts, $opt);

    } elsif
	# unknown option?  foo nofoo
	($optstr =~ s!^(.*?)( |$)!!) {
	D20("Option X24: $1");
	push (@opts, $1);
    } else {
	rip_die("Unknown option format: '$optstr'",
		$EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
    $optstr =~ s/^\s+//;
}


# Now actually process those pesky options...

D1("Option List '" . join("', '", (@opts)) . "'");


## COPY OPTIONS AND SET DEFAULTS


copyoptions($dat, 'default', 'userval');

my $option_values;

if( grep { /^docs$/i or /^docs=\"?\s*true\s*\"?$/i } @opts ){
    # The second one is necessary becuase CUPS 1.1.15 or newer sees
    # "docs" as boolean option and modifies it to "docs=true"
    $do_docs = 1;
    D1("Option 'docs'" );
    $option_values = undef;
}

if( $do_docs ){
    @opts = ();
    $option_values = undef;
} elsif( @opts ){
    D0("Fixing User Options");
    $option_values = expandoptions( $dat, \@opts, 'userval', 1,
	$Precedence_values{'command'}, "User Options: " );
    $dat->{'userval'} = undef;
    D1("All Options Done: " . Dumper($dat));
    if( $option_values ){
	my $line = '';
	foreach my $opt ( sort keys %{$option_values} ){
	    my $v = $option_values->{$opt};
	    my $name = $v->{'name'};
	    my $value = $v->{'userval'};
	    $value = "'$value'" if $value =~ m/\s/;
	    my $range = $v->{'pagerange'};
	    $line .= " $name=$value";
	    if( defined $range and @{$range} ){
		$line .= " " . join(" ",@{$range});
	    }
	}
	if( $line ){
	    trim_options( "Final Options Values: " . $line, 60, "   " );
	}
    }
}


## Were we called to build the PDQ driver declaration file?

if ($genpdqfile) {
    my @pdqfile = buildpdqdriver($dat, 'userval');
    open PDQFILE, $genpdqfile or
	rip_die("Cannot write PDQ driver declaration file '$genpdqfile' - $!",
		$EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    print PDQFILE join('', @pdqfile);
    close PDQFILE;
    exit $EXIT_PRINTED;
}

## Set the $postpipe
$postpipe = $dat->{'postpipe'};

# $postpipe when running as a PPR RIP
if ($spooler eq 'ppr') {
    # The PPR RIP sends the data output to /dev/fd/3 instead of to STDOUT
    if (-w "/dev/fd/3") {
	$postpipe = "| cat - > /dev/fd/3";
    } else {
	$postpipe = "| cat - >&3";
    }
}

# Set up PPR backend (if we run as a PPR interface).
if ($spooler eq 'ppr_int') {

    # Is the chosen backend installed and executable
    if (!-x "interfaces/$backend") {
	my $pwd = getcwd;
	rip_die ("The backend interface $pwd/interfaces/$backend " .
		 "does not exist/is not executable!",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }

    # foomatic-rip cannot use foomatic-rip as backend
    if ($backend =~ /foomatic-rip/) {
	rip_die ( "\"foomatic-rip\" cannot use itself as backend interface!",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }

    # Put the backend interface into the $postpipe
    $postpipe = "| ( interfaces/$backend \"$ppr_printer\" ".
	"\"$ppr_address\" \"" . join(" ",@backendoptions) .
	"\" \"$ppr_jobbreak\" \"$ppr_feedback\" " .
	"\"$ppr_codes\" \"$ppr_jobname\" \"$ppr_routing\" " .
	"\"$ppr_for\" \"\" )";

}

# CUPS and PDQ have their own backends, they do not need a $postpipe
if (($spooler eq 'cups') || ($spooler eq 'pdq')) {
    # No $postpipe for CUPS or PDQ, even if one is defined in the PPD file
    $postpipe = '';
}

# CPS needs always a $postpipe, set the default one for local printing
# if none is set
if (($spooler eq 'cps') && !$postpipe) {
    $postpipe = "| cat - > \$LPDDEV";
}

$postpipe =~ s/^\s*|\s*// if $postpipe;
if ($postpipe) {
    D0("${added_lf}Output will be redirected to: ${added_lf}$postpipe${added_lf}\n");
}

if ($do_docs) {
    # Don't print the supplied files, STDIN will be redirected to the
    # documentation page generator
    @filelist = ("<STDIN>");
    my $fh;
    ($docgeneratorpid, $fh ) = run_subprocess( "Document Generator",
	undef, undef, \&docgenerator, $dat );
    if( not $docgeneratorpid){
	rip_die ("Error opening documentation page generator",
	     $EXIT_PRNERR);
    }
    D10("docgeneratorpid $docgeneratorpid");
    my $fd = fileno( $fh );
    open( STDIN, "<&$fd" ) or rip_die("do docs: cannot dup $fd to STDIN",$EXIT_PRNERR);
    dup2($fd,0)  or rip_die("do docs: cannot dup $fd to 0",$EXIT_PRNERR);
    close($fh);
    if( $show_docs ){
	while( <STDIN> ){
	    print $_;
	}
	childwait( $docgeneratorpid, "Doc generator" );
	exit(0);
    }
}


## In debug mode save the data supposed to be fed into the
## renderer also into a file.

unlink("${logfile}.ps") if ($debug);
## We now iterate over all of the input files
## we use the next READFILE to terminate stuff and start reading the next file.
## This is considered evil by some people and clever by the desperate.

READFILE:
for my $file (@filelist) {

    D0(
"${added_lf}================================================\n${added_lf}".
"File: $file\n${added_lf}" .
"================================================\n${added_lf}");

    ## If we do not print standard input, open the file to print
    if ($file ne "<STDIN>") {
	open STDIN, "<$file" or do {
	    D0("Cannot open $file, skipping.\n");
	    next;
	};
    }

    ## Do we have a raw queue
    if ($dontparse == 2) {
	# Raw queue, simply pass the input into the $postpipe (or to STDOUT
	# when there is no $postpipe)
	D0("Raw printing, copying $file to output${added_lf}\n");
	if( not $postpipepid and $postpipe ){
	    $postpipepid = startpostpipe( $postpipe );
	}
	my $line;
	while( read STDIN, $line, 1024 ){ print $line; };
	next;
    }

    my $conversionattempts = 0;  # We increment this each time we have a conversion attempt
    my $uel = '';                # uel at the end of a job

 AGAIN:

    # copy the 'userval' to 'header options'

    copyoptions($dat, 'userval', 'header');

    my $maxlines = 1000;            # Maximum number of lines to be read
                                    # when the documenent is not
                                    # DSC-conforming. "$maxlines = 0"
                                    # means that all will be read
                                    # and examined. If it is
                                    # discovered that the input file
                                    # is DSC-conforming, this will
                                    # be set to 0.

    my $maxlinestopsstart = 200;    # That many lines are allowed until the
                                    # "%!" indicating PS comes. These
                                    # additional lines in the
                                    # beginning are usually JCL
                                    # commands. The lines will be
                                    # ignored by our parsing but
                                    # passed through.

    my $maxlinesforpageoptions=200; # Unfortunately, CUPS does not bracket
                                    # "PageSetup" option with
                                    # "%%BeginPageSetup" and
                                    # "%%EndPageSetup", so the options
                                    # can simply stand after the
                                    # page header and before the
                                    # page code, without special
                                    # marking. So buffer this amount
                                    # of lines before printing the
                                    # page to check for options.

    my $maxnondsclinesinheader=1000; # If there is a block of more lines
                                    # than this in the document
                                    # header which is not in the
                                    # "%%BeginProlog...%%EndProlog"
                                    # or
                                    # "%%BeginSetup...%%EndSetup"
                                    # sections, the document is not
                                    # considered as DSC-conforming
                                    # and the rest gets passed
                                    # through to the renderer without
                                    # further parsing for options.

    my $nondsclines = 0;            # Amount of lines found which are not in
                                    # a section (see
                                    # $maxnondsclinesinheader).

    my $linect = 0;                 # how many lines have we examined?

    my $comment = 0;                # current line is a comment to be ignored

    my $onelinebefore = '';         # The line before the current line
                                    # (Non-DSC comments are ignored)

    my @psheader = ();              # The header of the PostScript file,
                                    # to be sent after each start of the
                                    # renderer

    my @psfifo = ();                # The input FIFO, data which we have
                                    # pulled from stdin for examination,
                                    # but not sent to the renderer yet.

    my $passthru = 0;               # 0: write data into @psfifo; 1: pass
                                    # data directly to the renderer

    my $isdscjob = 0;               # Is the job DSC conforming

    my $inheader = 1;               # Are we still in the header, before
                                    # first "%%Page:" comment?

    my $optionset = 'header';       # Where do the option settings, which
                                    # we have found, go?

    my $optionsalsointoheader = 0;  # 1: We are in a "%%BeginSetup...
                                    # %%EndSetup" section after the first
                                    # "%%Page:..." line (OpenOffice.org
                                    # does this and intends the options here
                                    # apply to the whole document and not
                                    # only to the current page). We have to
                                    # add all lines also to the end of the
                                    # @psheader now and we have to set
                                    # non-PostScript options also in the
                                    # "header" optionset. 0: otherwise.

    my $nestinglevel = 0;           # Are we in the main document (0) or
                                    # in an embedded document bracketed by
                                    # "%%BeginDocument" and "%%EndDocument"
                                    # (>0) We do not parse the PostScript
                                    # in an embedded document.

    my $inpageheader = 0;           # Are we in the header of a page,
                                    # between "%%BeginPageSetup" and
                                    # "%%EndPageSetup" (1) or not (0).

    my $lastpassthru = 0;           # State of $passthru in previous line
                                    # (to allow debug output when $passthru
                                    # switches.

    my $ignorepageheader = 0;       # Will be set to 1 as soon as active
                                    # code (not between "%%BeginPageSetup"
                                    # and "%%EndPageSetup") appears after a
                                    # "%%Page:" comment. In this case
                                    # "%%BeginPageSetup" and
                                    # "%%EndPageSetup" is not allowed any
                                    # more on this page and will be ignored.
                                    # Will be set to 0 when a new "%%Page:"
                                    # comment appears.

    my $printprevpage = 0;          # We set this when encountering
                                    # "%%Page:" and the previous page is not
                                    # printed yet. The previous page will be printed and
                                    # the new page will be prepared in the
                                    # next run of the loop (we don't read a
                                    # new line and don't increase the
                                    # $linect then).

    my $prologfound = 0;            # Did we find the
                                    # "%%BeginProlog...%%EndProlog" section?

    my $setupfound = 0;             # Did we find the
                                    # "%%BeginSetup...%%EndSetup" section?

    my $pagesetupfound = 0;         # special page setup handling needed

    my $inprolog = 0;               # We are between "%%BeginProlog" and
                                    # "%%EndProlog".

    my $insetup = 0;                # We are between "%%BeginSetup" and
                                    # "%%EndSetup".

    my $infeature = 0;              # We are between "%%BeginFeature" and
                                    # "%%EndFeature".

    $nondsclines = 0;               # Number of subsequent lines found which
                                    # are at a non-DSC-conforming place,
                                    # between the sections of the header.

    my $optionreplaced = 0;         # Will be set to 1 when we are in an
                                    # option ("%%BeginFeature...
                                    # %%EndFeature") which we have replaced.

    my $insertoptions = 0;          # If we find out that a file with
                                    # a DSC magic string
                                    # ("%!PS-Adobe-") is not really
                                    # DSC-conforming, we insert the
                                    # options directly after the line
                                    # with the magic string. We use
                                    # this variable to store the
                                    # number of the line with the
                                    # magic string.

    my $currentpage = 0;            # The page which we are currently
                                    # printing.

    my $ooo110 = 0;                 # Flag to work around an application
                                    # bug.

    my $have_uel = '';              # we have UEL at start
    my $pjl_info = undef;           # we have PJL information
    my $previous_command = '';      # previous render command
    my $previous_pjl = '';          # previous pjl
    my $previous_pcl = '';          # previous pcl
    my $previous_pxl = '';          # previous pxl
    my $previous_setupprepend = ''; # previous ps setup code
    my $previous_pagesetupprepend = ''; # previous ps pagesetup code




    my $line = "$uel";              # Line read from stdin
    my $read = '';		    # total amount read from STDIN
    $uel = '';                      # clear UEL

    D0("Reading PostScript input ...\n");
    D10("START maxlines '$maxlines' linect '$linect'\n");

    # File type testing
    # 
    # We assume that we are going to get either a 'good' file for conversion
    # or a total mess of junk.  In the later case, we simply toss it to the
    # fileconverter and hope for the best.
    # 
    # A good file will contain
    # ([UEL [PJL])*   - standard PJL/UEL header - you may have multiple of these
    # ^D%!       - postscript
    # <esc>E<esc>  - pcl
    # We have a problem if we try to use the <STDIN> operator
    # as some PCL files have a zillion bytes of input before the first
    # LF, or may not even have an LF.  Since, however, this is valid
    # PCL we should be able to handle this.
    # 
    # We will save the PJL in the hopes that at a later time we
    # may be able to read it and salvage some information from it.

         
    my $count = read STDIN, $line, 32, length($line);
    D10("READ: start of file '$line'"); 
    if( not defined $count ){
	D0("Error reading from STDIN- $!");
	next;
    } elsif( not $count ){
	D0("Zero length input");
	goto DONE;
    }
    ($line, $pjl_info) = Parse_PJL( $line, \*STDIN );
    $have_uel = ($pjl_info->{UEL_found} || 0);
    D10("READ: UEL, have_uel $have_uel '$line'"); 
    if( $line eq '' ){
	D0("End of data");
	next READFILE;
    }
    D10("We have ripped off the UEL and PJL - $line");

    # We have now read past the UEL and PJL
    if( length($line) < 4 ){
	$count = read STDIN, $line, 32, length($line);
	if( not defined $count ){
	    D0("Discarding file - error reading from STDIN- $!");
		next READFILE;
	}
    }
    # test for PCL
    if( $line =~ m/\x1bE\x1b/ ){
	# we have PCL file
	D0("Input is PCL");
	buildcommandline($dat, $optionset);
	if( not $postpipepid and $postpipe ){
	    $postpipepid = startpostpipe( $postpipe );
	}
	D0("Adding PJL to PCL File");
	sendpjloutput( $dat, \*STDIN, $read );
	next;
    }
    if( $line !~ m/^(\x04|)%!/ ){
	# This is not a PostScript job, we must convert it
	if( $conversionattempts > 0 ){
		rip_die ( "${added_lf}File converter has failed to " .
		    "produce PostScript! Terminating processing\n",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
	++$conversionattempts;
	D0("${added_lf}Job does not appear to be PostScript.\n");
	# we start the subprocess off for doing file conversion
	# write the current input to it and then read from the STDIN until
	# all is done.
	$read .= $line;
	($fileconverterpid) = getfileconverter($dat, $read);
	# Read the further data from the file converter and
	goto AGAIN;
    }

    D0("File contains PostScript" . (($have_uel)?" with PJL header":''));

    # we have PostScript file, but we may not need to parse it
    # we discard all of the PJL and other stuff before the PostScript

    # remove the leading ^D if present
    $line =~ s/^(\x04|)//;

    if ($dontparse) {
	D0("Sending PostScript contents of file directly to output\n");
	if( not $postpipepid and $postpipe ){
	    $postpipepid = startpostpipe( $postpipe );
	}
	#foreach my $line (@{$read}){
	#    print STDOUT $line;
	#}
	print STDOUT $line;
	if( not eof STDIN ){
	    while ( read STDIN, $line, 1024 ){
		print STDOUT $line or
		    rip_die ( "cannot write to STDOUT - $!\n", $EXIT_PRNERR);
	    }
	}
	next READFILE;
    }

    # make sure we have lines in list
    D40( "current input line '$line'"); 

    while( $line !~ m/\n$/s ){
	# we need to read character until we get EOF or a line end
	$count = read STDIN, $line, 1, length($line);
	if( not defined $count ){
	    D0("Discarding file - error reading from STDIN- $!");
	    next READFILE;
	} elsif( not $count ){
	    last;
	}
    }
    D40( "final input line '$line'"); 

    my @readlines;

    # now we split the lines that we read up
    while( $line =~ s/^([^\n]*\n)//s ){
	D40( "ripped off input line '$1'"); 
	push @readlines, $1;
    }
    if( $line ne '' ){
	D40( "final line '$1'"); 
	push @readlines, $line;
    }
    $line = shift @readlines;
	D10( "now using line '$line'");

    # Do we have a DSC-conforming document?
    if (($line =~ m/^%!PS-Adobe-/) &&
	($line !~ m/EPSF/)) {
	$maxlines = 0;
	$isdscjob = 1;
	# We have written into @psfifo before,
	# now we continue in @psheader and move
	# over the data which is already in @psfifo
	push (@psheader, @psfifo) if @psfifo;
	@psfifo = ();
	D0("--> This document is DSC-conforming!\n");
    } else {
	# Job is not DSC-conforming, stick in all PostScript
	# option settings in at the beginning
	D10("XX6");
	buildcommandline($dat, $optionset);
	$line .= makeprologsection($dat, $optionset, 1);
	$line .= makesetupsection($dat, $optionset, 1);
	$line .= makepagesetupsection($dat, $optionset, 1);
	$prologfound = 1;
	$setupfound = 1;
	$pagesetupfound = 1;
	D0("--> This document is NOT DSC-conforming!\n");
    }
    push @psheader, $line;

    $insertoptions = @psheader;
    D20("Start insertoptions $insertoptions");

    # we start counting from the start of the PostScript
    # not the start of the file
    $linect = 1;

    while ( @readlines 
	or ( (($maxlines == 0) or ($linect < $maxlines)) 
	    and not eof(STDIN) and not $uel) ) {

	D40( "PSH psheader " . scalar(@psheader) . "\nPSH " . join('PSH ',@psheader) . 'END PSH' ) if @psheader;
	D40( "PSF psfifo " . scalar(@psfifo) . "\nPSF " . join('FSF ',@psfifo) . 'END PSF' ) if @psfifo;
	my $xx = 1;

	if (($printprevpage) || ($line = shift(@readlines)) || ($line=<STDIN>)) {
	    if( !$printprevpage ){
		++$linect;
		D10("READ linect $linect '$line'");
		if( $line =~ m/^(\x04|)(\x1b\%-12345X.*)$/ ){
		    $uel = $2 . join( '', (@readlines) ); 
		    $line = '';
		    next;
		}
	    }
	    if ($line =~ m/^\s*\%\%BeginDocument[: ]/) {
		# Beginning of an embedded document
		# Note that Adobe Acrobat has a bug and so uses
		# "%%BeginDocument " instead of "%%BeginDocument:"
		$nestinglevel++;
		D0("Embedded document, nesting level now: $nestinglevel\n");
	    } elsif (($line =~ m/^\s*\%\%EndDocument/) &&
		     ($nestinglevel > 0)) {
		# End of an embedded document
		$nestinglevel --;
		D0("End of Embedded document, nesting level now: $nestinglevel\n");
	    } elsif( $nestinglevel > 0 ){
		# we pass the document through
	    } elsif (($line =~ m/^\s*\%\%Creator[: ](.*)$/) ) {
		# Here we set flags to treat particular bugs of the
		# PostScript produced by certain applications
		my $creator = $1;
		D10("Creator '$creator' found");
		if ($creator =~ /^\s*OpenOffice.org\s+1.1.0\s*$/) {
		    # OpenOffice.org 1.1.0
		    # The option settings supposed to affect the
		    # whole document are put into the "%%PageSetup"
		    # section of the first page
		    D0("Document created with OpenOffice.org 1.1.0\n");
		    $ooo110 = 1;
		}
	    } elsif (($line =~ m/^\%\%BeginProlog/) ) {
		# Note: Below is another place where a "Prolog"
		# section start will be considered. There we assume
		# start of the "Prolog" if the job is DSC-Conformimg,
		# but an arbitrary comment starting with "%%Begin", but
		# not a comment explicitly treated here, is found. This
		# is done because many "dvips" (TeX/LaTeX) files miss
		# the "%%BeginProlog" comment.
		# Beginning of Prolog
		D0("${added_lf}-----------\nFound: \%\%BeginProlog\n");
		$inprolog = 1;
		$nondsclines = 0;
		# Insert options for "Prolog"
		if (!$prologfound) {
		    buildcommandline($dat, $optionset);
		    $line .= makeprologsection($dat, $optionset, 0);
		}
		$prologfound = 1;
	    } elsif (($line =~ m/^\%\%EndProlog/) ) {
		# End of Prolog
		D0("Found: \%\%EndProlog\n");
		$inprolog = 0;
		$insertoptions = @psheader+1;
		D20("EndProlog insertoptions $insertoptions");
	    } elsif (($line =~ m/^\%\%BeginSetup/) ) {
		# Beginning of Setup
		D0("${added_lf}-----------\nFound: \%\%BeginSetup\n");
		$insetup = 1;
		# We need to distinguish with the $inheader variable
		# here whether we are in the header or on a page, as
		# OpenOffice.org inserts a "%%BeginSetup...%%EndSetup"
		# section after the first "%%Page:..." line and then assumes
		# this section to be valid for all pages.
		$nondsclines = 0;
		if ($inheader) {
		    if( !$prologfound or !$setupfound ){
			# If there was no "Prolog" but there may be
			# options for the "Prolog". push a "Prolog"
			# with these options onto the @psfifo here
			buildcommandline($dat, $optionset);
			if (!$prologfound) {
			    # "Prolog" missing, insert it here
			    $line = makeprologsection($dat, $optionset, 1) .
				$line;
			    # Now we have a "Prolog"
			    $prologfound = 1;
			}

			# Insert options for "DocumentSetup" or "AnySetup"
			# These will be set according to the default and/or user
			# options.
			if (!$setupfound) {
			    $line .= makesetupsection($dat, $optionset, 0);
			    $setupfound = 1;
			}
		    }
		} else {
		    # Found option settings must be stuffed into both
		    # the header and the currrent page now. They will
		    # be written into both the "header" and the
		    # "currentpage" optionsets and the PostScript code
		    # lines of this section will not only go into the
		    # output stream, but also added to the end of the
		    # @psheader, so that they get repeated (to preserve
		    # the embedded PostScript option settings) on a
		    # restart of the renderer due to command line
		    # option changes
		    D0("\"%%BeginSetup\" in page header\n");
		    $optionsalsointoheader = 1;
		}
	    } elsif (($line =~ m/^\%\%EndSetup/) ) {
		# End of Setup
		D0("Found: \%\%EndSetup\n");
		$insetup = 0;
		if ($inheader) {
		    $insertoptions = @psheader+1;
		    D20("EndSetup insertoptions $insertoptions");
		} else {
		    # The "%%BeginSetup...%%EndSetup" which
		    # OpenOffice.org has inserted after the first
		    # "%%Page:..." line ends here, so the following
		    # options go only onto the current page again
		    $optionsalsointoheader = 0;
		}
	    } elsif (($line =~ m/^\%\%Page:(.*)$/) ) {
		# At this point we have the end of the header information
		# and the start of the per-page information.
		#
		# Except that due to bugs in the various PostScript
		# generators we may actually have Begin/EndSetup and
		# Begin/EndPageSetup sections which have to be treated
		# as headers.   So we will TRY to set up a job with
		# the current Setup options and then delay putting
		# out the actual job until we get the REAL output.
		# Sheesh! What a mess.
		#

		# This is handled by setting a flag to HINT that we
		# want to print the page ($passthru).  Then we
		# try to print the previous page which might be
		# stored in the @psfifo.  When we arrive at the
		# point where we are going to actually start the
		# printing, we check to see if we are going to
		# start sending data out ($passthru == 1 and
		# $lastpassthru != $passthru), which triggers
		# (re)starting a render process.

		if ((!$lastpassthru) && (!$inheader)) {
		    # In the last pass we were not in passthru mode,
		    # so the last page was not printed. Prepare to do
		    # it now.
		    $printprevpage = 1;
		    # Print the previous page
		    $passthru = 1;
		    D0("Start of new page found and previous not printed; print it now.\n");
		} else {
		    # The previous page is finished or printed,
		    # so we can prepare to print the next one.
		    $printprevpage = 0;
		    D0("${added_lf}-----------\nNew page: $1\n");
		    # Count pages
		    $currentpage ++;
		    # We consider this the beginning of the page, rather than
		    # the page setup section, as some apps do not use
		    # "%%PageSetup" tags.
		    # Here begins a new page
		    D1("XX1 - inheader $inheader");
		    if ($inheader) {
			if (!$setupfound or !$prologfound) {
			    # Here we add some stuff which still belongs
			    # into the header
			    my $stillforheader = '';
			    buildcommandline($dat, $optionset);
			    if (!$prologfound) {
				# "Prolog" missing, insert it here
				$stillforheader =
				    makeprologsection($dat, $optionset, 1);
				# Now we have a "Prolog"
				$prologfound = 1;
			    }
			    if (!$setupfound) {
				# "Setup" missing, insert it here
				$stillforheader .=
				    makesetupsection($dat, $optionset, 1);
				# Now we have a "Setup"
				$setupfound = 1;
			    }
			    # Now we push this onto the header
			    push (@psheader, $stillforheader) if $stillforheader;
			}
			# note that this will have the options set for the
			# The first page starts, so the header ends
			$inheader = 0;
			$nondsclines = 0;
			# Option setting should go into the
			# page-specific option set now
		    } else {
			# Save the option settings of the previous page
			copyoptions($dat, $optionset, 'previouspage');
		    }
		    # Initialize the optionset to the start of the header section
		    deleteoptions( $dat, 'currentpage' );
		    copyoptions($dat, 'header', 'currentpage');
		    $optionset = 'currentpage';
		    $pagesetupfound = 0;

		    # Now the page header comes, so buffer the data,
		    # because we must perhaps shut down and restart
		    # the renderer.  In any case, we will want to
		    # check for new options, etc. in the page
		    $passthru = 0;
		    $ignorepageheader = 0;
		    $optionsalsointoheader = 0;
		}
	    } elsif (($line =~ m/^\%\%BeginPageSetup/)  &&
		     (!$ignorepageheader))  {
		# Start of the page header, up to %%EndPageSetup
		# nothing of the page will be drawn, page-specific
		# option settngs (as letter-head paper for page 1)
		# go here
		D0("${added_lf}Found: \%\%BeginPageSetup\n");
		$passthru = 0;
		$inpageheader = 1;		

		# We deal with the defective Open Office PostScript
		# If we are on the first page, then we need to save
		# the PageSetup section as the Setup section.
		#
		if (($ooo110) && ($currentpage == 1)) {
		    $optionsalsointoheader = 1;
		} else {
		    $optionsalsointoheader = 0;
		}
		if( $optionset ne 'currentpage' ){
		    copyoptions($dat, $optionset, 'currentpage');
		    $optionset = 'currentpage';
		}
	    } elsif (($line =~ m/^\%\%EndPageSetup/) &&
		     (!$ignorepageheader)) {
		# End of the page header, the page is ready to be
		# printed
		D0("Found: \%\%EndPageSetup\n");
		D0("End of page header\n");
		# We cannot for sure say that the page header ends here
		# OpenOffice.org puts (due to a bug) a "%%BeginSetup...
		# %%EndSetup" section after the first "%%Page:...". It
		# is possible that CUPS inserts multiple "%%BeginPageSetup...
		# %%EndPageSetup" sections.  There could be options in a
		# "%%BeginSetup...%%EndSetup" section
		# after the "%%EndPageSetup", so we continue for
		# searching options up to the buffer size limit
		# $maxlinesforpageoptions.
		$passthru = 0;
		$inpageheader = 0;
		$optionsalsointoheader = 0;
	    } elsif ((
		($line =~ m/^\%\%(BeginFeature):
		    \s*\*?([^\*\s=]+)\s+()(.*?)\s*\r?\n?$/x)
		|| ($line =~ m/^\s*\%\%\s*(FoomaticRIPOptionSetting):
		    \s*\*?([^\*\s=]+)\s*=\s*(\@?)([^\@]*?)\s*\r?\n?$/x)
		) && ((!$passthru) || (!$isdscjob)) ) {
		my ($linetype, $option, $fromcomposite, $value) =
		    ($1, $2, $3, $4);
		D10("type '$linetype' option '$option' composite '$fromcomposite' value '$value'");

		# Mark that we are in a "Feature" section
		++$infeature;
		next if ($optionreplaced);

		# OK, we have an option.  Set the value if it has changed

		my $arg=argbyname($dat, $option);
		my $name = $arg->{'name'};
		my $val = checkoptionvalue($arg, $value, 0 );
		if( $fromcomposite ){
		    # set by a composite option
		    # we ignore the settings for this value
		    $optionreplaced = $infeature;
		} elsif( not defined $arg ) {
		    # This option is unknown to us.  WTF?
		    D0("Unknown option '$option' found - $line");
		} elsif( not defined $val ){
		    # We have an illegal option value.  This is possible if we
		    # are trying to do a conversion from one printer to another.
		    # we punt and use the default value for the option
		    my $default = $arg->{$optionset};
		    D0("Option '$name' unknown value '$value'; using '$default'");
		} else {
		    # we have a valid option
		    # we now put the option in the list of options
		    # that may have changed
		    if ( ($inheader)
			||($arg->{section}{ps} eq 'PageSetup')
			||($arg->{section}{ps} eq 'AnySetup') ) {
			# we add this option to the list for this set
			$optionreplaced = $infeature;
			if( ! $fromcomposite
				and $Precedence_values{file} >= $arg->{'precedence'} ){
			    # we will update this option
			    push @{$dat->{$optionset}}, "$name=$val";
			    # If we are in a "%%BeginSetup...%%EndSetup" section after
			    # the first "%%Page:..." and the current line belongs to
			    # an option setting, we have to copy the line also to the
			    # @psheader. This is done by the making sure that the
			    # input line is pushed onto @psheader and not @psfifo
			    if ($optionsalsointoheader){
				push @{$dat->{'header'}}, "$name=$val";
			    }
			}
		    } else {
			D0 "Option not in header! $line";
		    }
		}
		# skip any more checking
		next if $optionreplaced;
	    } elsif (($line =~ m/^\%\%EndFeature/) ) {
		# End of Feature
		--$infeature if $infeature;
		
		# If the option setting was replaced, it ends here, too,
		# We also handle nested options which are really
		# not covered under the DSC. This is really a botch
		if( $optionreplaced ){
		    if( $infeature < $optionreplaced ){
			$optionreplaced = 0;
		    }
		    next;
		}
	    } elsif ($optionreplaced) {
		# we can skip the rest of the processing as we
		# really don't care if the 'EndFeature was missed.
		next;
	    } elsif (($line =~ m/^(\%\%BeginDefaults)/ or $line =~ m/^(\%\%BeginPreview).*/ ) ){
		D10(" IGNORING $1");

#  We can safely ignore this code as it tries to catch and warn about a
#  condition that appears to be a bit bogus.  Lots of PostScript with
#  no Prolog sections.
#	    } elsif (($line =~ m/^\%\%Begin/) &&
#		     ($isdscjob) &&
#		     (!$prologfound) ) {
#		# In some PostScript files (especially when generated
#		# by "dvips" of TeX/LaTeX) the "%%BeginProlog" is
#		# missing, so assume that it was before the current
#		# line (the first line starting with "%%Begin".
#		D0("Job claims to be DSC-conforming, but " .
#		    "\"%%BeginProlog\" missing before\n  first " .
#		    "\"%%Begin...\" comment.\n" .
#		    "  (Is this a TeX/LaTeX/dvips-generated PostScript " .
#		    "file?)\n  Assuming start of \"Prolog\" here.\n");
#		# Beginning of Prolog
#		$inprolog = 1;
#		$nondsclines = 0;
#		# Insert options for "Prolog" before the current line
#		if (!$prologfound) {
#		    buildcommandline($dat, $optionset);
#		    $line =
#			makeprologsection($dat, $optionset, 1) .
#			$line;
#		    $prologfound = 1;
#		}

	    } elsif (($line =~ m/^\s*\%/) or ($line =~ /^\s*$/) ) {
		D10( "COMMENT");
		$comment = 1;
	    } else {
		D10( "PSCODE - inheader '$inheader' inprolog '$inprolog' insetup '$insetup'");
		# This line is active PostScript code
		if ($inheader) {
		    if ((!$inprolog) && (!$insetup) ){
			# Outside the "Prolog" and "Setup" section
			# a correct DSC-conforming document has no
			# active PostScript code, so consider the
			# file as non-DSC-conforming when there are
			# too many of such lines.
			$nondsclines ++;
			if ($nondsclines > $maxnondsclinesinheader) {
			    # Consider document as not DSC-conforming
			    D0(
		"This file does not appear to be DSC-conforming.\n" .
		"There are more than $maxnondsclinesinheader lines\n" .
		"at the start of the job (i.e.- header)\n" .
		"that are not in a Prolog or Setup\n" .
		"section.  Generating a Prolog and Setup\n" .
		"section and then passing the\n" .
		"rest of the file directly to renderer.\n" );
			    # Stop scanning for further option settings
			    $maxlines = 1;
			    $isdscjob = 0;
			    # Insert defaults and command line settings
			    # in the beginning of the job or after the
			    # last valid section
			    buildcommandline($dat, $optionset);
			    D10("XX2 Splicing at insertoptions $insertoptions");
			    splice(@psheader, $insertoptions, 0,
				   ($prologfound ? () : makeprologsection($dat, $optionset, 1)),
				   ($setupfound ? () : makesetupsection($dat, $optionset, 1)),
				   ($pagesetupfound ? () : makepagesetupsection($dat, $optionset, 1)));
			    $prologfound = 1;
			    $setupfound = 1;
			    $pagesetupfound = 1;
			}
		    }
		} else {
		    if (!$inpageheader) {
			# PostScript code inside a page, but not between
			# "%%BeginPageSetup" and "%%EndPageSetup", so
			# we are perhaps already drawing onto a page now
			if ($onelinebefore =~ m/^\%\%Page:/) {
			    D0("No page header or page header not DSC-conforming\n");
			}
			# Stop buffering lines to use as Setup
			# Document is not DSC conforming
			if (scalar(@psfifo) > $maxlinesforpageoptions) {
			    D0("Stopping search for page header options. Document is not DSC conforming\n");
			    $passthru = 1;
			    # If there comes a page header now, ignore
			    # it
			    $ignorepageheader = 1;
			    $optionsalsointoheader = 0;
			}
		    }
		}
	    }
	
	    # Here is where we try do decide what to do with the line
	    # we have been given
	    # The 'passthru' value controls if we are sending
	    # the line to the renderer or not
	    if ($lastpassthru != $passthru) {
		if ($passthru) {
		    D0("Found: $line" .
			" --> Output going directly to the renderer now.\n${added_lf}");
		} else {
		    D0("Found:  $line" .
			" --> Output going to the FIFO buffer now.${added_lf}\n");
		}
	    }

	    # Store or send the current line
	    if (($inheader) && ($isdscjob)) {
		# We are still in the PostScript header, collect all lines
		# in @psheader
		D10( "  push onto psheader");
		push @psheader, ($line);
	    } else {
		D10( "XX2  passthru '$passthru', isdscjob '$isdscjob'");
		if (($passthru) && ($isdscjob)) {
		    D10( "XX3  lastpassthru $lastpassthru, $renderpid $renderpid");
		    if( !$lastpassthru or !$renderpid ){
			push( @{$dat->{$optionset}},
			    setoptionsforpage(
				$dat, $optionset, $currentpage ));
			my @options = @{$dat->{$optionset}};
			D10("Options for page $currentpage: @options");
			buildcommandline($dat, $optionset);
			getrendercommand($dat, $optionset);
		    }
		    if (!$lastpassthru) {
			D10(" multiple pages- render optionset $optionset");
			# first we get the options set by the page
			# We enter passthru mode with these options.
			# the command line can have changed so check to
			# see if this is the case and
			# close the renderer if needed
			if (($renderpid) && (
    ($dat->{'commandline'} ne $previous_command )
    or (($dat->{'prefix_pjl'} or $dat->{'pjl_change_restart'})
	and $dat->{'pjl_command'} ne $previous_pjl )
    or (($dat->{'pcl_change_restart'})
	and $dat->{'pcl_command'} ne $previous_pcl )
    or (($dat->{'pxl_change_restart'})
	and $dat->{'pxl_command'} ne $previous_pxl )
			) ){
			    D0("Command line/JCL options changed, restarting renderer\n");
			    closerenderhandle ($renderhandle, $renderpid, $fixuppid);
			    $renderpid = $fixuppid = 0;
			}
		    }
		    # Flush @psfifo and send line directly to the renderer
		    if (!$renderpid) {
			if( not $postpipepid and $postpipe ){
			    $postpipepid = startpostpipe( $postpipe );
			}
			D10( " XX1 - starting RENDER");
			# No renderer running, start it
			($renderhandle, $renderpid, $fixuppid) = startrender( $dat );
			D10( "renderpid '$renderpid'");
			$previous_command = $dat->{'commandline'};
			$previous_pjl = $dat->{'pjl_command'};
			$previous_pcl = $dat->{'pcl_command'};
			$previous_pxl = $dat->{'pxl_command'};
			$previous_setupprepend = $dat->{'setupprepend'};
			$previous_pagesetupprepend = $dat->{'pagesetupprepend'};
			D20("XXX psheader XX " . join("XXX ", @psheader) . "XXX END") if @psheader;
			if( $dat->{'prefix_pjl'} ){
			    print $renderhandle ($dat->{'pjl_command'});
			}
			print $renderhandle  @psheader;
			# we add this code to save the current
			# set of options and their states
			# print $renderhandle "/foomatic-saved-state save def\n";
		    }
		    # Send @psfifo to renderer
		    # If we are lucky, then we should have a %%Page as the
		    # First line in @psfifo, possiblly followed by a
		    # %%BeginPageSetup line.  If this is the case,
		    # stick our options after these lines
		    if( @psfifo ){
			D20("XXX psfifo XX " . join("XX ", @psfifo) . "XX END") if @psfifo;
			D10("XX7".$dat->{'setupprepend'} );
			D10("XX8".$dat->{'pagesetupprepend'} );
			while( @psfifo and $psfifo[0] =~ /^\%\%Page:/ ){
				print $renderhandle shift(@psfifo);
			}
			while( @psfifo and $psfifo[0] =~ /^\%\%BeginPageSetup/ ){
			    print $renderhandle shift(@psfifo);
			}
			# now we restore the state
			# print $renderhandle "foomatic-saved-state restore\n";
			D10("M current pagesetup " . $dat->{'pagesetupprepend'} . "\n");
			D10("M previous pagesetup " . $previous_pagesetupprepend . "\n");
			D10("M diff " . ($previous_pagesetupprepend ne $dat->{'pagesetupprepend'}) . "\n");
			if( ($previous_setupprepend ne $dat->{'setupprepend'})
			    or ($previous_pagesetupprepend
				ne $dat->{'pagesetupprepend'}) ){
			    print $renderhandle ($dat->{'setupprepend'});
			    $previous_setupprepend
				= ($dat->{'setupprepend'} || '');
			    $previous_pagesetupprepend
				= ($dat->{'pagesetupprepend'} || '');
			}
			print $renderhandle 
			    ($pagesetupfound ?():($dat->{'pagesetupprepend'}));
			print $renderhandle (@psfifo);
			@psfifo = ();
		    }
		    # Send line to renderer
		    if (!$printprevpage) {
			print $renderhandle $line;
		    }
		} else {
		    D10("  doing push onto psfifo");
		    # Push the line onto the stack for later spitting up...
		    push (@psfifo, $line);
		}
	    }
	}
	$lastpassthru = $passthru;
	
	if( not $comment ){
	    $onelinebefore = $line;
	}
	$comment = 0;

    }

    # Some buffer still containing data? Send it out to the renderer.
    D10("End of reading loop - optionset '$optionset' eof " . scalar(eof(STDIN)) . ", inheader '$inheader' psfifo '".scalar(@psfifo)."'");
    if ((not eof(STDIN)) || ($inheader) || (@psfifo > 0)) {

	# Flush @psfifo and send the remaining data to the renderer;
	# this  only happens with non-DSC-conforming jobs or non-Foomatic PPDs
	if (not eof(STDIN)) {
	    D0("Stopped parsing the PostScript data, ".
		"sending rest directly to renderer.\n");
	} else {
	    D0("Flushing FIFO.\n");
	}
	D10("  doing render - optionset $optionset");
	# you need to be careful about the various conditions
	# at this point.  Depending on the input, you may or may
	# not have started the renderer,  or may not even found
	# the header.  All of these cases need to be handled
	if ($inheader) {
	    # This can be a result of trying to find the end of
	    # the first page in a single page PostScript file
	    # or a non DSC compliant file
	    # No page initialized yet? Copy the "header" option set into the
	    # "currentpage" option set, so that the renderer will find the
	    # options settings.
	    if( $optionset ne $currentpage ){
		copyoptions($dat, $optionset, 'currentpage');
		$optionset = 'currentpage';
	    }
	    # If not done yet, insert defaults and command line settings
	    # in the beginning of the job or after the last valid section
	    D10("XX3 Splicing at insertoptions $insertoptions");
	    buildcommandline($dat, $optionset);
	    splice(@psheader, $insertoptions, 0,
	       ($prologfound ? () :
		    makeprologsection($dat, $optionset, 1)),
	       ($setupfound ? () :
		    makesetupsection($dat, $optionset, 1)),
	       ($pagesetupfound ? () :
		    makepagesetupsection($dat, $optionset, 1)));
	    $prologfound = 1;
	    $setupfound = 1;
	    $pagesetupfound = 1;
	} else {
	    push( @{$dat->{$optionset}},
		setoptionsforpage(
		    $dat, $optionset, $currentpage ));
	    my @options = @{$dat->{$optionset}};
	    D10("Options for page $currentpage: @options");
	    buildcommandline($dat, $optionset);
	}
	getrendercommand($dat, $optionset);
	# We enter passthru mode with these options.
	# the command line can have changed so check to
	# see if this is the case and
	# close the renderer if needed
	if (($renderpid) && (
    ($dat->{'commandline'} ne $previous_command )
    or (($dat->{'prefix_pjl'} or $dat->{'pjl_change_restart'})
	and $dat->{'pjl_command'} ne $previous_pjl )
    or (($dat->{'pcl_change_restart'})
	and $dat->{'pcl_command'} ne $previous_pcl )
    or (($dat->{'pxl_change_restart'})
	and $dat->{'pxl_command'} ne $previous_pxl )
			) ){
	    D0("Command line/JCL options changed, restarting renderer\n");
	    closerenderhandle ($renderhandle, $renderpid, $fixuppid);
	    $renderpid = $fixuppid = 0;
	}
	if (!$renderpid) {
	    D10( " XX2 - starting RENDER");
	    if( not $postpipepid and $postpipe ){
		$postpipepid = startpostpipe( $postpipe );
	    }
	    ($renderhandle, $renderpid, $fixuppid) = startrender($dat);
	    $previous_command = $dat->{'commandline'};
	    $previous_pjl = $dat->{'pjl_command'};
	    $previous_pcl = $dat->{'pcl_command'};
	    $previous_pxl = $dat->{'pxl_command'};
	    $previous_setupprepend = $dat->{'setupprepend'};
	    $previous_pagesetupprepend = $dat->{'pagesetupprepend'};
	    D10( "renderpid '$renderpid'");
	    if( $dat->{'prefix_pjl'} ){
		print $renderhandle ($dat->{'pjl_command'});
	    }
	    print $renderhandle  @psheader;
	    # print $renderhandle "/foomatic-saved-state save def\n";
	}
	if( @psfifo ){
	    D10("XX5");
	    while( @psfifo and $psfifo[0] =~ /^\%\%Page:/ ){
		print $renderhandle shift(@psfifo);
	    }
	    while( @psfifo and $psfifo[0] =~ /^\%\%BeginPageSetup/ ){
		print $renderhandle shift(@psfifo);
	    }
	    D20("XX5 E current pagesetup " . $dat->{'pagesetupprepend'} . "\n");
	    D20("XX5 E previous pagesetup " . $previous_pagesetupprepend . "\n");
	    D20("XX5 E diff " . ($previous_pagesetupprepend ne $dat->{'pagesetupprepend'}) . "\n");
	    if( ($previous_setupprepend ne $dat->{'setupprepend'})
		or ($previous_pagesetupprepend
		    ne $dat->{'pagesetupprepend'}) ){
		D10("E print " .  $dat->{'setupprepend'} ."\n");
		print $renderhandle ($dat->{'setupprepend'});
		$previous_setupprepend
		    = ($dat->{'setupprepend'} || '');
		$previous_pagesetupprepend
		    = ($dat->{'pagesetupprepend'} || '');
	    }
	    # print $renderhandle "foomatic-saved-state restore\n";
	    print $renderhandle 
		($pagesetupfound ? () : ($dat->{'pagesetupprepend'}));
	    print $renderhandle (@psfifo);
	    @psfifo = ();
	}
	# Print the rest of the input data
	if ( not $uel and not eof(STDIN) ) {
	    while (<STDIN>) {
		print $renderhandle $_;
	    }
	}
	goto AGAIN if( $uel );
    }

 DONE:
    # Close the renderer
    if( $fileconverterpid ){
	childwait( $fileconverterpid, "File converter" );
	$fileconverterpid = 0;
    }
    if ($renderpid) {
	closerenderhandle($renderhandle, $renderpid, $fixuppid);
	$renderpid = $fixuppid = 0;
    }
    checkchild();
}


## Close last input file
close STDIN;
close STDOUT;

if( $postpipepid ){
    childwait( $postpipepid, "PostPipe" );
}
checkchild();

## The End
D0("${added_lf}Closing foomatic-rip.\n");
exit 0;


	
# POSTPIPE
# Do we have a $postpipe? if yes, launch the command(s) and
# point our output into it/them


sub startpostpipe( $ ){
    my( $postpipe ) = @_;
    $postpipe =~ s/^\s*|\s*// if $postpipe;
    my $pid = 0;
    if ($postpipe) {
	D0("Starting postpipe \"$postpipe\"${added_lf}\n");
	# now we create the postpipe subprocess
	select STDOUT; $| = 1;
	pipe PP_READ_FH, PP_WRITE_FH
	    or rip_die("startpostpipe: pipe() failed - $!", $EXIT_PRNERR);
	($pid) = run_subprocess_with_logger( "PostPipe", [ \*PP_READ_FH, \*PP_WRITE_FH ], '',
			"Logger", "system", $postpipe  );
	# now bind Postpipe input to STDOUT
	my $fd = fileno( PP_WRITE_FH );
	dup2( $fd, 1 )
		or rip_die("startpostpipe: dup $fd to 1", $EXIT_PRNERR);
	close( PP_READ_FH );
	close( PP_WRITE_FH );
    }
    return($pid);
}


# This function runs the renderer command line (and if defined also
# the postpipe) and returns a file handle for stuffing in the
# PostScript data.

sub getrendercommand( $ $ ) {

    my ($dat, $optionset) = @_;

    # Build the command line and get the JCL commands
    my $commandline = ($dat->{'currentcmd'} || "");

    $commandline =~ s/^\s*\|//;
    $commandline =~ s/^\s+//;
    $commandline =~ s/\%[A-Z]//g;

    my $gspath = ($conf{gspath} || 'gs');
    if(
	$commandline =~ m:^\s*gs\s:
	or $commandline =~ m:(\|\s*)gs\s:
	or $commandline =~ m:(;\s*)gs\s:
    ){
	if( $gspath =~ m!^/! ){
	    -x $gspath or rip_die("getrendercommand: gs '$gspath' not executable",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	} else {
	    for (split(':', $ENV{'PATH'})) {
		my $p = $_ . "/". $gspath; 
		if(-x $p ) {
		    $gspath = $p;
		    last;
		}
	    }
	    -x $gspath or rip_die("getrendercommand: cannot find executable '$gspath'",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
    }
	
    D10("gspath '$gspath'");
    my $output_xlate = '-sOutputFile=\'' . ((-e '/dev/fd/3') ? '/dev/fd/3' : '| cat >&3') . '\' 3>&1 1>&2 ';
    D10("output_xlate '$output_xlate'");
    #my $input_xlate = ((-e "/dev/fd/0") ? "/dev/fd/0" : "-_");
    #D10("input_xlate '$input_xlate'");

    $commandline =~ s:^\s*gs\s:$gspath :g;
    $commandline =~ s:(\|\s*)gs\s:\| $gspath :g;
    $commandline =~ s:(;\s*)gs\s:; $gspath :g;
    $commandline =~ s:\-sOutputFile=\-:$output_xlate:g;
    #$commandline =~ s: \- :$input_xlate:g;
    # you may not want to do this, but modify the filter definition instead
    #$commandline =~ s: \-q  ::g;

    D0("Render command: $commandline\n");

    # If the renderer command line contains the "echo"
    # command, replace the "echo" by the user-chosen $myecho
    # (important for non-GNU systems where GNU echo is in a
    # special path
    $commandline =~ s!^\s*echo\s!$myecho !g;
    $commandline =~ s!(\|\s*)echo\s!\|$myecho !g;
    $commandline =~ s!(;\s*)echo\s!; $myecho !g;

    # In debug mode save the data supposed to be fed into the
    # renderer also into a file
    if ($debug) {
	$commandline = "tee -a ${logfile}.ps | ( $commandline )";
    }
    $dat->{'commandline'} = $commandline;

}

sub startrender( $ ) {
    my( $dat ) = @_;
    my $commandline = $dat->{'commandline'};

    D0("${added_lf}Starting renderer '$commandline'\n");
    # Actually run the thing...
    # we will first need to create a pipe that we will read from
    #  Then we will create a process that will read the output
    #  of the actual renderer process.  Thus we have:

    # -> ..... -> ghostscript --> fixup -->STDOUT
    #             ^
    #             child  of fixup
    #                              ^ child of main
    #                         we return pid of fixup
    # RENDER_WRITEH
    #              -> RENDER_READH
    #                (ghostscript STDIN)
    #                        (ghostscript STDOUT)
    #                             $fh      --> STDOUT
    #     we return RENDER_WRITEH


    my( $pid1, $pid2, $fh );

    pipe RENDER_READH, RENDER_WRITEH
	or rip_die("startrender: pipe() failed = $!",$EXIT_PRNERR);


    # now setup render process - i.e. -  ghostscript to RENDER_READH
    # create subprocess with STDIN set to RENDER_READH and STDOUT
    #  readable by fixup

    ($pid1, $fh) = run_subprocess_with_logger(
	"Render", [\*RENDER_READH, \*RENDER_WRITEH], undef,
		"Logger", "system", $commandline );
    close(RENDER_READH);
    # ghostscript output on $fh
    # now we start up the process for handling the output of
    # the renderer.  This process will read from $fh and write to STDOUT


    # Debug output
    ($pid2) = run_subprocess( "Fixup", [$fh, \*RENDER_WRITEH], '', \&sendpjloutput, $dat, \*STDIN, '');
    close($fh);
	sleep(0.125);
    return( \*RENDER_WRITEH, $pid1, $pid2 );
}

# we read the STDIN and update the PJL with our input.
# sub sendpjloutput( $dat, $prefixlines )
#   $dat = the standard $dat passed to everything
#   $input = the input lines we have already read from STDIN (if any).

sub sendpjloutput( $ $ $ ) {
    my( $dat, $fh, $line ) = @_;

    # wrap the JCL around the job data, if there are any
    # options specified...
    # Should the driver already have inserted JCL commands we merge
    # our JCL header with the one from the driver

    my @job_pjl = ();
    my $count;
    if( length($line) < 256 ){
	$count = read $fh, $line, 256;
	if( not defined $count ){
	    D0("Error reading from fh- $!");
	    next;
	}
    }
    D10("Fixup: starting");
    while( $line =~ s/^\x1b\%-12345X// ){
	# we have the UEL at the start, all right
	D10("Fixup: UEL at start");
	# we shall check for PJL
	while( $line =~ m/^\@PJL/ ){
	    D10("Fixup: PJL at start");
	    # we now read the PJL from the start of the line
	    while( $line =~ s/^(\@PJL[^\n]*\n)//s ){
		my $ln = $1;
		$ln =~s/\015//;
		push @job_pjl, $ln;
		$ln =~s/\n//;
		D10("Fixup: PJL '$ln'");
	    }
	    if( not eof($fh) and (length($line) < 6 or $line !~ m/\n/) ){
		$count = read $fh, $line, 256, length($line);
		if( not defined $count ){
		    rip_die("Fixup Process: error reading from fh- $!",
			 $EXIT_PRNERR );
		}
		D10("Fixup: READ '$line'");
	    }
	    last if( $line !~ m/^\@PJL[^\n]*\n/ );
	}
	if( $line =~ m/^\@PJL/ ){
	    rip_die("Fixup Process: inproperly formatted PJL - $line",
		 $EXIT_PRNERR );
	}
    }
    D10("Fixup: END '$line'");
    # we can try to determine the language
    my $lang = '';
    if( $line =~ /^.?%!/ ){
	$lang = 'ps';
    } elsif( $line =~ /\xb1E\b1/ ){
	$lang = 'pcl';
    }

    D10("PJL found: XX\n" . join("XX ", @job_pjl) . "XX END");
    # print the PJL if there is any to send
    if( $dat->{pjl} or @job_pjl ){
	push @job_pjl, $dat->{'jclprepend'} if $dat->{'jclprepend'};
	map { s/^\x1b\%-12345X//g } @job_pjl;
	unshift @job_pjl, "\x1b\%-12345X";
	print STDOUT @job_pjl;
	my $v = set_jcl_enterlanguage( $dat, $lang ) if $lang;
	print STDOUT $v if $v;
    }

    # print the rest that was read
    print STDOUT $line;
    while( read $fh, $line, 1024 ){
	    print STDOUT $line;
    }
    if( $dat->{pjl} or @job_pjl ){
	my $jclappend = "\x1b\%-12345X".$dat->{'jclappend'};
	D10("Fixup: SUFFIX $jclappend");
	print STDOUT $jclappend;
    }
    return(0);
}



## Close the renderer process and wait until all kid processes finish.

sub closerenderhandle( $ $ $ ) {

    my ($fh, $rpid, $fpid ) = @_;

    D0("${added_lf}Closing renderer\n");
    if( $fh and $rpid ){
	close $fh or
	    rip_die( "Error closing renderer - $!", $EXIT_PRNERR );
    }
    childwait( $rpid, "Render");
    childwait( $fpid, "Fixup");
    return $EXIT_PRINTED;
}


sub childwait( $ $ ){
    my ($pid, $name ) = @_;
    my $p = waitpid( $pid, 0 );
    if( $p == $pid ){
	my ($s, $signal, $retval ) = decode_status($?);
	$retval = fix_codes( $signal, $retval );
	rip_die ("$name: $s", $retval) if $retval;
	D0 "$name: $s";
    }
}


## This function is only used when the input data is not
## PostScript. Then it runs a filter which converts non-PostScript
## files into PostScript. The user can choose which filter he wants
## to use. The filter command line is provided by $fileconverter.
##
## ($pid ) = sub getfileconverter( $dat, $read );
##   $read is the input currently read

sub getfileconverter( $ $ ) {

    # Already read data must be converted, too
    my ($dat, $read) = @_;

    # Determine with which command non-PostScript files are converted
    # to PostScript
    my $f = ($fileconverter or $spoolerfileconverters->{$spooler});
    if( not $f ){
	foreach my $c ( @fileconverters ){
	    my @args = split ' ', $c;
	    my $command = shift(@args);
	    if( $command =~ m!^/! and -x $command ){
		$f = $c;
	    } else {
		for (split(':', $ENV{'PATH'})) {
		    if(-x "$_/$command") {
			$f = $c;
			last;
		    }
		}
	    }
	    last if ($f ne '');
	}
    } else {
	# check to see if it is in the list
	foreach my $c ( @fileconverters ){
	    my @args = split ' ', $c;
	    my $command = shift(@args);
	    if( $command eq $f ){
		$f = $c;
		last;
	    }
	}
	my @args = split ' ', $f;
	my $command = shift(@args);
	my $found = 0;
	if( $command =~ m!^/! and -x $command ){
	    $found = 1;
	} else {
	    for (split(':', $ENV{'PATH'})) {
		if(-x "$_/$command") {
		    $found = 1;
		    last;
		}
	    }
	}
	if( not $found ){
	    D0("Fileconverter '$f' not executable. Cannot convert file to PostScript!");
	    return( undef, undef );
	}
    }
    if ($f eq '') {
	D0("No fileconverter- Cannot convert file to PostScript!");
	return( undef, undef );
    }

    # Insert the page size into the command
    if ($f =~ /\@\@([^@]+)\@\@PAGESIZE\@\@/) {
	# We always use the "header" option swt here, with a
	# non-PostScript file we have no "currentpage"
	my $optstr = $1;
	my $arg;
	my $sizestr = (($arg = $dat->{'args_byname'}{'PageSize'})
		       ? $arg->{'header'}
		       : '');
	if ($sizestr) {
	    # Use wider margins so that the pages come out completely on
	    # every printer model (especially HP inkjets)
	    if ($f =~ /^\s*(a2ps)\s+/) {
		if (lc($sizestr) eq "letter") {
		    $sizestr = "Letterdj";
		} elsif (lc($sizestr) eq "a4") {
		    $sizestr = "A4dj";
		}
	    }
	    $optstr .= $sizestr;
	} else {
	    $optstr = '';
	}
	$f =~ s/\@\@([^@]+)\@\@PAGESIZE\@\@/$optstr/;
    }

    # Insert the job title into the $f
    if ($f =~ /\@\@([^@]+)\@\@JOBTITLE\@\@/) {
	if ($show_docs) {
	    $jobtitle =
		"Documentation for the $model";
	}
	my $titlearg = $1;
	my ($arg, $optstr);
	($arg = $jobtitle) =~ s/\"/\\\"/g;
	if (($titlearg =~ /\"/) || $arg) {
	    $optstr = $titlearg . ($titlearg =~ /\"/ ? '' : '"') .
		($arg ? "$arg\"" : '"');
	} else {
	    $optstr = '';
	}
	$f =~ s/\@\@([^@]+)\@\@JOBTITLE\@\@/$optstr/;
    }

    # Apply "pstops" when having used a file converter under CUPS, so
    # CUPS can stuff the default settings into the PostScript output
    # of the file converter (so all CUPS settings get also applied when
    # one prints the documentation pages (all other files we get
    # already converted to PostScript by CUPS.
    if ($spooler eq 'cups') {
	my $command = "pstops";
	my $path = '';
	for (split(':', $ENV{'PATH'})) {
	    my $p = "$_/$command";
	    if(-x "$p" ){
		$path = $p;
		last;
	    }
	}
	if( $path eq '' ){
	    rip_die ("Cannot find executable 'pstops' in \$PATH",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
	$f .=
	    " | $path '$rargs[0]' '$rargs[1]' '$rargs[2]' " .
	    "'$rargs[3]' '$rargs[4]'";
    }

    $f =~ s/^\s*\|\s*//;
    D0("${added_lf}Starting file converter '$f'\n");

    # check if we can rewind the input file
    if( sysseek(STDIN,0,0) ){
	# we can just run the fileconverter program.  If we are
	# doing PPD translation this will save copying the file
	D1("Starting file converter directly");
	my ($pid, $fh ) = run_subprocess_with_logger(
	    "File Converter", undef, undef, "Logger", "system", $f );
	close(STDIN);
	my $fd = fileno($fh);
	open(STDIN,"<&$fd") or rip_die ("File Converter: dup(STDIN,0) failed - $!", $EXIT_PRNERR);
	dup2($fd, 0) or rip_die ("File Converter($fd,0) failed - $!", $EXIT_PRNERR);
	close($fh);
	return( $pid);
    }


    # now we open a PIPE to the actual filter.  The
    # filter will write to STDOUT, which is actually the parent
    # process destination pipe
    # we do this in the parent process - it is much easier to handle
    # an exit under these conditions


    # we start a subprocess, reading from STDIN and writing to a pipe

    my ($pid, $fh ) = run_subprocess_with_logger(
	    "File Converter", undef, undef, "Logger");

    # if we are the parent (MAIN?), we smugly return and do our stuff.
    # MAIN will set up the $fh file handle as STDIN

    if( $pid ){
	close(STDIN);
	my $fd = fileno($fh);
	open(STDIN,"<&$fd") or rip_die ("File Converter: OPEN(STDIN,$fd) failed - $!", $EXIT_PRNERR);
	dup2($fd, 0) or rip_die ("File Converter: dup($fd,0) failed - $!", $EXIT_PRNERR);
	close($fh);
	return( $pid );
    }
    # now we make a pipe
    $f = "| $f";
    D10("Fileconverter '$f'");
    $fh = new FileHandle( $f ) or
        rip_die ("cannot execute fileconverter '$f'", $EXIT_PRNERR);

    if( $read ne '' ){
	print $fh $read
	    or rip_die ("cannot write line to fileconverter '$f",
		$EXIT_PRNERR);
    }

    if( not eof(STDIN) ){
	my $count;
	while( ($count = read STDIN, $read, 10240) ){
	    print $fh $read
	    or rip_die ("cannot write STDIN to fileconverter '$f",
		$EXIT_PRNERR);
	}
    }
    close( $fh ) or do {
	my ($s, $signal, $retval );
	$retval = $EXIT_PRINTED;
	if( $! ){
	    rip_die ("fileconverter close failed '$f' - $!", $EXIT_PRNERR);
	} elsif( $? ) {
	    ($s, $signal, $retval ) = decode_status($?);
	    $retval = fix_codes(  $signal, $retval );
	    rip_die ("fileconverter close failed '$f' - $s - returning $retval",
		    $retval );
	}
    };
    exit $EXIT_PRINTED;
}


## Generate the documentation page and return a filehandle to get it

sub docgenerator( $ ) {

    # The data structure with the options
    # we set child STDIN and STDOUT to  $stdin and $stdout if they are defined
    my ($dat) = @_;

    D0("Generating documentation page for the $model");
    print "Documentation page for the $model\n";

    # Printer queue name
    my $printerstr;
    if ($printer) {
	$printerstr = $printer;
    } else {
	$printerstr = "<printer>";
    }
	
    # Spooler-specific differences
    my ($command,
	$enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	$boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	$booloptright,
	$numopt, $numoptleft, $numoptequal, $numoptright,
	$stropt, $stroptleft, $stroptequal, $stroptright,
	$optsep, $trailer, $custompagesize);
    if ($spooler eq 'cups') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-o ", '', "=", '',
	      "-o ", "no", '', "=", '',
	      "-o ", '', "=", '',
	      "-o ", '', "=", '',
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'lpd') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr -J \"",
	      '', '', "=", '',
	      '', '', '', "=", '',
	      '', '', "=", '',
	      '', '', "=", '',
	      " ", "\" <file>",
	      "\n  Custom size: PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'gnulpr') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-o ", '', "=", '',
	      "-o ", '', '', "=", '',
	      "-o ", '', "=", '',
	      "-o ", '', "=", '',
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'lprng') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-Z ", '', "=", '',
	      "-Z ", '', '', "=", '',
	      "-Z ", '', "=", '',
	      "-Z ", '', "=", '',
	      " "," <file>",
	      "\n  Custom size: -Z PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -Z PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'ppr') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("ppr -d $printerstr --ripopts \"",
	      '', '', "=", '',
	      '', '', '', "=", '',
	      '', '', "=", '',
	      '', '', "=", '',
	      " ","\" <file>",
	      "\n  Custom size: PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'ppr-int') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("ppr -d $printerstr -i \"",
	      '', '', "=", '',
	      '', '', '', "=", '',
	      '', '', "=", '',
	      '', '', "=", '',
	      " ","\" <file>",
	      "\n  Custom size: PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'cps') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-o ", '', "=", '',
	      "-o ", '', '', "=", '',
	      "-o ", '', "=", '',
	      "-o ", '', "=", '',
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'direct') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("$programname -P $printerstr ",
	      "-o ", '', "=", '',
	      "-o ", '', '', "=", '',
	      "-o ", '', "=", '',
	      "-o ", '', "=", '',
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'pdq') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptfalseprefix, $booloptleft, $booloptequal,
	 $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $stropt, $stroptleft, $stroptequal, $stroptright,
	 $optsep, $trailer, $custompagesize) =
	     ("pdq -P $printerstr ",
	      "-o", '', "_", '',
	      "-o", "no", '', "_", '',
	      "-a", '', "=", '',
	      "-a", '', "=", '',
	      " "," <file>",
	      "\n" .
	      "Option 'PageWidth':\n".
	      "  Page Width (for \"Custom\" page size)\n" .
	      "  A floating point number argument\n" .
	      "  Range: 0 <= x <= 100000\n" .
	      "  Example: -aPageWidth=123.4\n" .
	      "\n" .
	      "Option 'PageHeight':\n" .
	      "  Page Height (for \"Custom\" page size)\n" .
	      "  A floating point number argument\n" .
	      "  Range: 0 <= x <= 100000\n" .
	      "  Example: -aPageHeight=234.5\n" .
	      "\n" .
	      "Option 'PageSizeUnit':\n" .
	      "  Unit (for \"Custom\" page size)\n" .
	      "  An enumerated choice argument\n" .
	      "  Possible choices:\n" .
	      "   o -oPageSizeUnit_pt: Points (1/72 inch)\n" .
	      "   o -oPageSizeUnit_in: Inches\n" .
	      "   o -oPageSizeUnit_cm: cm\n" .
	      "   o -oPageSizeUnit_mm: mm\n" .
	      "  Example: -oPageSizeUnit_mm\n");
    }
    # Kill data on STDIN to satisfy PPR
    if (($spooler eq 'ppr_int') || ($spooler eq 'ppr')) {
	my $dummy;
	while ( read STDIN, $dummy, 1024 ) {};
    }
    close STDIN
	or print "Error closing STDIN for docs print\n";

    print "\nInvokation summary for the $model\n\n";
    my $line = '';
    print "Use the following command line:\n\n";
    if ($booloptfalseprefix) {
	# I think that what you want to indicate is that the prefix for a false
	# boolean has this form:  xxx [no]<switch> or something similar
	$line =  "   ${command}${enumopt}${enumoptleft}<option>" .
	    "${enumoptequal}<choice>${enumoptright}${optsep}" .
	    "${boolopt}${booloptleft}\[${booloptfalseprefix}\]<switch>" .
	    "${booloptright}${optsep}" .
	    "${numopt}${numoptleft}<num. option>${numoptequal}" .
	    "<value>${numoptright}${optsep}" .
	    "${stropt}${stroptleft}<string option>${stroptequal}" .
	    "<string>${stroptright}" .
	    "${trailer}";
    } else {
	$line =  "   ${command}${enumopt}${enumoptleft}<option>" .
	    "${enumoptequal}<choice>${enumoptright}${optsep}" .
	    "${boolopt}${booloptleft}<switch>${booloptequal}" .
	    "<True/False>${booloptright}${optsep}" .
	    "${numopt}${numoptleft}<num. option>${numoptequal}" .
	    "<value>${numoptright}${optsep}" .
	    "${stropt}${stroptleft}<string option>${stroptequal}" .
	    "<string>${stroptright}" .
	    "${trailer}";
    }
    trim_options_stdout( $line, 60,"   ");
    print "\n";

    if( $dat->{'aliases'} ){
	print "The following aliases are available for this printer:\n\n";
	$line = '';
	my $prefix = "  ";
	my $value = ($dat->{foomatic_option}{'aliases'} || '');
	foreach my $entry (split(' ', ($dat->{foomatic_option}{'aliases'} || '') )){
	    D10("ALIAS: value '$entry'");
	    my($key,$value) = split('=',$entry,2);
	    $key = (unhtmlify($key));
	    $value = (unhtmlify($value));
	    $line .= " $key ($value)";
	    if( length($line) > 60 ){
		print $prefix . $line . "\n";
		$line = '';
	    }
	}
	print $prefix . $line . "\n" if $line;
	print "\n";
    }

    print "The following options are available for this printer:\n\n";

    for my $argname (sort @{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	D2("Option: $argname " . Dumper($arg) );
	next if (!$arg->{'option'});
        my ($name, $type, $comment, $default, $hidden)
	 = ($arg->{'name'}, $arg->{'type'}, $arg->{'comment'},
	     ($arg->{'default'}||''), ($arg->{'hidden'}||'') );

	D2("name $name, type $type, comment $comment, " );
	D2("	default $default, hidden $hidden");

	# Is this really an option? Otherwise skip it.

	# We don't need "PageRegion", we have "PageSize"
	next if ($name eq "PageRegion");

	# Skip enumerated choice options with only one choice
	next if (($type eq 'enum') && (@{$arg->{'vals'}} <= 1));

	# Skip hidden choice options
	next if $hidden;
	my $commentstr = '';
	if ($comment) {
	    $commentstr = "  $comment\n";
	}

	my $typestr;
        if ($type eq "enum") {
	    $typestr = "An enumerated choice";
	} elsif ($type eq "pickmany") {
	    $typestr = "A pickmany choice";
	} elsif ($type eq "bool") {
	    $typestr = "A boolean";
	} elsif ($type eq "int") {
	    $typestr = "An integer number";
	} elsif ($type eq "float") {
	    $typestr = "A floating point number";
	} elsif (($type eq "string") || ($type eq "password")) {
	    $typestr = "A string";
	}

        print "Option '$name':\n$commentstr  $typestr argument\n";
        # print "  This options corresponds to a PJL command\n" if ($arg->{'style'} eq 'J');
        # print "  This options corresponds to a PJL command\n" if ($arg->{'style'} eq 'pjl');

        if ($type eq 'bool') {
	    my $comment_true = $arg->{'vals_byname'}{'True'}{'comment'};
	    my $comment_false = $arg->{'vals_byname'}{'False'}{'comment'};
            print "  Possible choices:\n";
	    if ($booloptfalseprefix) {
		print "   o $name: ${comment_true}\n";
		print "   o $booloptfalseprefix$name: ${comment_false}\n";
		if (defined($default)) {
		    my $defstr = ($default ? '' : "$booloptfalseprefix");
		    print "  Default: $defstr$name\n";
		}
		print "  Example: ${boolopt}${booloptleft}${name}" .
		    "${booloptright}\n";
	    } else {
		print "   o True: ${comment_true}\n";
		print "   o False: ${comment_false}\n";
		if (defined($default)) {
		    my $defstr = ($default ? "True" : "False");
		    print "  Default: $defstr\n";
		}
		print "  Example: ${boolopt}${booloptleft}${name}" .
		    "${booloptequal}True${booloptright}\n";
	    }
        } elsif ($type eq 'enum' or $type eq 'pickmany') {
            print "  Possible choices:\n";
            my $exarg;
	    my $havecustomsize = 0;
            for my $valname (@{$arg->{'vals'}}) {
		my $val = $arg->{'vals_byname'}{$valname};
                my ($choice, $comment) = ($val->{'value'}, $val->{'comment'});
                print "   o $choice: $comment\n";
		if (($name eq "PageSize") && ($choice eq "Custom")) {
		    $havecustomsize = 1;
		}
                $exarg=$choice;
            }
            if (defined($default)) {
                print "  Default: $default\n";
            }
            print "  Example: ${enumopt}${enumoptleft}${name}" .
		"${enumoptequal}${exarg}${enumoptright}\n";
	    if ($havecustomsize) {
		print $custompagesize;
	    }
        } elsif ($type eq 'int' or $type eq 'float') {
            my ($max, $min) = ($arg->{'max'}, $arg->{'min'});
            my $exarg;
            if (defined($max)) {
                print "  Range: $min <= x <= $max\n";
                $exarg=$max;
            }
            if (defined($default)) {
                print "  Default: $default\n";
                $exarg=$default;
            }
            if (!$exarg) { $exarg=0; }
	    my $proto = $arg->{'proto'}{'ps'};
	    my $string = sprintf($proto,
			  ($type eq 'int' 
			   ? sprintf("%d", $exarg)
			   : sprintf("%f", $exarg)));
            print "  Example: ${numopt}${numoptleft}${name}" .
		"${numoptequal}${exarg}${numoptright} ($string)\n";
        } elsif ($type eq 'string' or $type eq 'password') {
            my $maxlength = $arg->{'maxlength'};
            if (defined($maxlength)) {
                print "  Maximum length: $maxlength characters\n";
            }
            if (defined($default)) {
                print "  Default: $default\n";
            }
            print "  Examples/special settings:\n";
            for my $valname (@{$arg->{'vals'}}) {
		my $val = $arg->{'vals_byname'}{$valname};
		D2("EXAMPLE: val ".Dumper($val));
                my ($value, $comment, $driverval, $proto) =
		    ($val->{'value'}, $val->{'comment'},
		    $val->{'driverval'}{'ps'},
		     $arg->{'proto'}{'ps'});
		# Retrieve the original string from the prototype
		# and the driverval
		D2("EXAMPLE: proto ".Dumper($proto));
		D2("EXAMPLE: driverval ".Dumper($driverval));
		my $string;
		if ($proto) {
		    $proto =~ s/\%(?!s)/\%\%/g;
		    $string = sprintf($proto, $driverval);
		} else {
		    $string = $driverval;
		}
		print "   o ${stropt}${stroptleft}${name}" .
		    "${stroptequal}${value}${stroptright}";
		if (($value ne $string) || ($comment ne $value)) {
		    print " (";
		}
		if ($value ne $string) {
		    if ($string eq '') {
			print "blank string";
		    } else {
			print "\"$string\"";
		    }
		}
		if (($value ne $string) && ($comment ne $value)) {
		    print ", ";
		}
		if ($value ne $comment) {
		    print "$comment";
		}
		if (($value ne $string) || ($comment ne $value)) {
		    print ")";
		}
		print "\n";
            }
        }

        print "\n";
    }
    D0("Docgenerator finished\n");
    exit($EXIT_PRINTED);
}



## Close the documentation page generation process and wait until the
## kid process finishes.

# Signal handling routines

sub set_exit_prnerr() {
    killchildren();
    exit($EXIT_PRNERR);
}

sub set_exit_prnerr_noretry() {
    killchildren();
    exit($EXIT_PRNERR_NORETRY);
}

sub set_exit_engaged() {
    killchildren();
    exit($EXIT_ENGAGED);
}

# Read the config file

sub readConfFile( $ ) {
    my ($file) = @_;
    my %conf;
    # Read config file if present
    open CONF, "<$file" or
	rip_die("Cannot open config file '$file'",
	    $EXIT_PRNERR_NORETRY);
	
    while (<CONF>){
	next if (m/^\s*\#/);
	$conf{$1}="$2" if (m/^\s*(\S+?)\s*:\s*(.*)\s*$/);
    }
    close CONF;

    return %conf;
}

sub copyoptions( $ $ $ ) {

    ## Copy one option set into another one

    # Source and destination option sets
    my ($dat, $srcoptionset, $destoptionset) = @_;

    push @{$dat->{$destoptionset}}, @{$dat->{$srcoptionset}} if( defined $dat->{$srcoptionset} );
    for my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	if (defined($arg->{$srcoptionset})) {
	    $arg->{$destoptionset} = $arg->{$srcoptionset};
	}
    }
}

sub deleteoptions ( $ $ ) {

    ## Delete an option set

    # option set to be removed
    my ($dat, $optionset) = @_;

    delete $dat->{$optionset};
    for my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	delete($arg->{$optionset});
    }
}

sub makeprologsection( $ $ $ ) {

    # option set to be used,
    # $comments = 1: Add "%%BeginProlog...%%EndProlog"
    my ($dat, $optionset, $comments) = @_;
    D10(" makeprologsection optionset '$optionset' comments '$comments'");

    # Collect data to be inserted here
    my @output;

    # Start comment
    if ($comments) {
	D0("\"Prolog\" section is missing, inserting it.\n");
	push(@output, "%%BeginProlog\n");
    }

    # Generate the option code (not necessary when CUPS is spooler)
    if ($spooler ne 'cups') {
	D0("Inserting option code into \"Prolog\" section.\n");
	push(@output, ( $dat->{'prologprepend'} ));
    }

    # End comment
    if ($comments) {
	push(@output, "%%EndProlog\n");
    }

    return join('', @output);
}

sub makesetupsection( $ $ $ ) {

    # option set to be used, $comments = 1: Add "%%BeginSetup...%%EndSetup"
    my ($dat, $optionset, $comments) = @_;
    D10(" makesetupsection optionset '$optionset' comments '$comments'");

    # Collect data to be inserted here
    my @output;

    # Start comment
    if ($comments) {
	D0("\"Setup\" section is missing, inserting it.\n");
	push(@output, "%%BeginSetup\n");
    }

    # PostScript code to generate accounting messages for CUPS
    if ($spooler eq 'cups') {
	D0("Inserting PostScript code for CUPS' page accounting\n");
	push(@output, $accounting_prolog);
    }

    # Generate the option code (not necessary when CUPS is spooler)
    if ($spooler ne 'cups') {
	D0("Inserting option code into \"Setup\" section.\n");
	push(@output, ($dat->{'setupprepend'}));
    }

    # End comment
    if ($comments) {
	push(@output, "%%EndSetup\n");
    }

    return join('', (@output));
}

sub makepagesetupsection( $ $ $ ) {

    # option set to be used,
    # $comments = 1: Add "%%BeginPageSetup...%%EndPageSetup"
    my ($dat, $optionset, $comments) = @_;

    # Collect data to be inserted here
    my @output;

    # Start comment
    if ($comments) {
	push(@output, "%%BeginPageSetup\n");
	D0("\"PageSetup\" section is missing, inserting it.\n");
    }

    # Generate the option code (not necessary when CUPS is spooler)
    D0("Inserting option code into \"PageSetup\" section.\n");
    D10(" makepagesetupsection optionset '$optionset' comments '$comments'");
    push(@output, ($dat->{'pagesetupprepend'}));

    # End comment
    if ($comments) {
	push(@output, "%%EndPageSetup\n");
    }
    D10("makepagesetupsection optionset $optionset - ".join('', (@output)) );
    return join('', (@output));

}


sub parsepageranges( $ $ ) {

# given a page range, check if it matches this page

    # String with page ranges and number of current page
    my ($rangelist, $page) = @_;

    my( $range, $key, $option, $value );

    D10("parsepageranges: rangelist '$rangelist', page '$page'");
    ## range has the format:
    ## (even|odd|PAGE|START-END)[,(even|odd|PAGE|START-END)]*:Key=Value

    # String with page ranges and number of current page (0 for score)
    if( not (($range, $option) = ($rangelist =~ m/^([^:]*):(.*)$/)) ){
	D0("Bad page range value '$rangelist'");
	return( $value );
    }
    D10("parsepageranges: ranges '$range', page '$page'");
    foreach my $r ( split(',',$range ) ){
	$r = lc($r);
	D10("parsepageranges: subrange '$r', page '$page'");
	if( $r =~ m/^even$/i ){
		$value = $option if !($page % 2);
	} elsif( $r eq m/odd/i ){
		$value = $option if ($page % 2);
	} elsif( $r =~ m/^\d+$/ ){
		$value = $option if ($page == $r );
	} elsif( $r =~ m/^(\d*)-(\d*)/ ){
	    my $start = ($1 or 0)+0;
	    my $end = ($2 or 0)+0;
	    if( $start <= $page and $page <= $end ){
		$value = $option;
	    } elsif( $start and $start <= $page and $end eq 0){
		$value = $option;
	    }
	}
    }
    D10("parsepageranges: value '" . ($value?$value:'') . "'");
	
    return( $value );
}

#
#
# sub setoptionsforpage( $dat, $optionset, $page )
#   we run down the list of options, finding ones hat
#   have a page range.
#
#   Then for every option in the pagerange list we decide if this page
#   will have a match
#

sub setoptionsforpage( $ $ $ ) {

    ## Set the options for a given page
    my ($dat, $optionset, $page ) = @_;

    # Foomatic data, name of the option set where to apply the options, and
    # number of the page

    my @list = ();
    for my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	my @pagerange = @{$arg->{'pagerange'}} if defined $arg->{'pagerange'};
	next if not @pagerange;
	D10("setoptionsforpage: '$argname' optionset '$optionset', page '$page', pagerange '@pagerange'"); 
	foreach my $range (@pagerange){
		my $n = parsepageranges($range, $page);
		push( @list, $n) if $n;
	}
    }
    D0("New options for page $page: @list") if @list;
    return @list;
}

sub buildcommandline( $ $ ) {

    ## Build a renderer command line, based on the given option set
    # Foomatic data and name of the option set to apply

    my ($dat, $optionset ) = @_;

    # we set up the information using the options we have been provided
    D10("BUILDCOMMANDLINE: optionset $optionset");
    my $opts = $dat->{$optionset};
    expandoptions( $dat, $opts, $optionset, 1, $Precedence_values{file}, "PostScript File: " );
    $dat->{$optionset} = undef;

    my $languages = [qw(ps pjl cmdline pcl pxl ) ];

    # Construct the proper command line.
    my @prologprepend;
    my @setupprepend;
    my @pagesetupprepend;
    my @jclprepend;

    $dat->{'currentcmd'} = $dat->{'cmd'};
    $dat->{'pcl_command'} = '';
    $dat->{'pjl_command'} = '';

    checkconstraints( $dat, $optionset );

    my $arg_lists = {};
    foreach my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	#D10("BUILDCOMMANDLINE: arg $argname: argstyle: " .  Dumper( $arg->{'argstyle'} ));
	next if not defined $arg->{'argstyle'};
	foreach my $lang ( keys %{$arg->{'argstyle'}} ){
	    my $order = $arg->{'order'}{$lang};
	    $order = 100 if not defined $order;
	    push( @{$arg_lists->{$lang}}, [ $order, $arg->{'name'} ] );
	}
    }

    D10("BUILDCOMMANDLINE ARG_LISTS " . Dumper($arg_lists));

    my @composite = @{$arg_lists->{'composite'}}
	if $arg_lists->{'composite'};
    D10("COMPOSITE XX " . Dumper(\@composite));
    @composite = sort { $a->[0] <=> $b->[0] or $a->[1] cmp $b->[1] } @composite;
    D10("SORTED COMPOSITE '" . Dumper(\@composite));
    @composite = map { $_->[1] } @composite;
    D10("FINAL COMPOSITE '" . Dumper(\@composite));

    foreach my $lang ( @{$languages} ){
	D10("BUILDCOMMANDLINE LANGUAGE $lang");
	my @list = @{$arg_lists->{$lang}}
	    if $arg_lists->{$lang};
	next if not @list;
	
	#D10("LIST XX $lang" . Dumper(@list));
	@list = sort { $a->[0] <=> $b->[0] or $a->[1] cmp $b->[1] } @list;
	#D10("SORTED LIST '" . Dumper(\@list));
	@list = map { $_->[1] } @list;
	#D10("FINAL LIST '" . Dumper(\@list));
	D10("DOING optionset '$optionset' lang $lang, list @list");

	for my $argname ( @list ){
	    my $arg = argbyname( $dat, $argname );
	    # If we have both "PageSize" and "PageRegion" options, we kept
	    # them all the time in sync, so we don't need to insert the settings
	    # of both options. So skip "PageRegion".
	    #next if (($name eq "PageRegion") &&
	    #     (defined($dat->{'args_byname'}{'PageSize'})) &&
	    #     (defined($dat->{'args_byname'}{'PageRegion'})));

	    my $userval = $arg->{$optionset};
	    my $name = $arg->{'name'};
	    $userval = $arg->{$optionset};
	    $arg->{header_cmdvar}{$lang} = '' if( $optionset eq 'header');

	    if( not defined $userval ){
		if( $lang eq 'ps' ){
		    my $header_cmdvar = $arg->{header_cmdvar}{$lang};
		    push (@setupprepend, $header_cmdvar)
			if $header_cmdvar;
		}
		D10( "ARG '$name' NO $optionset VALUE");
		next;
	    }
	    my $type = ($arg->{'type'} or '');
	    my $section = ($arg->{'section'}{$lang} or '');
	    my $spot = ($arg->{'spot'}{$lang} or 'A');

	    D10("ARG name $name, lang '$lang', value '$userval', type '$type', section '$section', spot '$spot'"); 

	    # check to see if we use the 'PageRegion' entry
	    if( $lang eq 'ps' and $arg->{'name'} eq 'PageSize' ){
		my $pr = $dat->{'usepageregion'};
		my $pr_arg = argbyname( $dat, 'PageRegion' );
		my $v = checkoptionvalue($pr_arg, $userval, 0) if $pr_arg;
		if( $pr and $pr_arg and $v ) {
		    my $found = 0;
		    foreach my $testv (keys %{$pr} ){
			my $v = $pr->{$testv};
			my ($set) = keys %{$v};
			my $check = $pr->{$testv}{$set};
			my $chk_arg = argbyname( $dat, $testv );
			my $chk_val = $chk_arg->{$optionset} if $chk_arg;
			$chk_val = '' if not defined $chk_val;
			D10("USEPAGEREGION '$testv' = $chk_val, $set compared to " . Dumper($check));
			foreach my $checkval (keys %{$check} ){
			    if( $set =~ /true/ and "$chk_val" eq "$checkval" ){
				$found = 1;
			    }
			    if( $set !~ /true/ and "$chk_val" ne "$checkval" ){
				$found = 1;
			    }
			    last if $found;
			}
			D10("USEPAGEREGION found $found");
			last if $found;
		    }
		    if( $found ){
			D0("Using PageRegion for PageSize");
			$pr_arg->{$optionset} = $userval;
			next;
		    }
		}
	    }

	    # we get the value AND the new set of user options.  This solves a problem with
	    # pickmany options
	    my ($cmdvar, $newargs) = fixoptionvalue( $arg, $lang, $optionset );
	    $cmdvar = fixopts( $dat,  $optionset, $cmdvar );
	    $cmdvar = '' if not defined $cmdvar;
	    $userval = $newargs if $newargs;

	    my $controlled_by = ($arg->{'controlled_by'}?'@':'');
	    my $user = ((not $controlled_by and $arg->{'option_type'}{user}{$lang}) or 0);

	    D10( "  X4 cmdvar $cmdvar");
	    # Insert the built snippet at the correct place
	    if ($lang eq 'ps') {
		# Place this Postscript command onto the prepend queue
		# for the appropriate section.
		my( $open, $close );
		if( $user ){
		    $open = "%%BeginFeature: *$name $userval\n";
		} else {
		    $open = "%%FoomaticRIPOptionSetting: *$name=${controlled_by}$userval\n";
		}
		$close = "%%EndFeature\n";
		$cmdvar = '[{' . $cmdvar . " } stopped cleartomark\n"
			if( $cmdvar );
		$cmdvar = $open.$cmdvar.$close;
		D10( "  X5 optionset '$optionset' lang '$lang' cmdvar '$cmdvar'");
		if( $optionset eq 'header' ){
		    $arg->{header_cmdvar}{$lang} = $cmdvar;
		}
		my $header_cmdvar = $arg->{header_cmdvar}{$lang};
		if ($section eq "Prolog") {
		    push (@prologprepend, $cmdvar);
		} elsif( $section ne "PageSetup" ){
		    push (@setupprepend, $header_cmdvar);
		    if( ($header_cmdvar ne $cmdvar) ) {
			push (@pagesetupprepend, $cmdvar);
		    }
		} else {
		    push (@pagesetupprepend, $cmdvar);
		}
	    } elsif ($lang eq 'pjl') {
		# JCL argument
		next if $cmdvar eq '';
		# put JCL commands onto JCL stack...
		D10("    PJL - $name = $userval");
		push (@jclprepend, "\@PJL COMMENT $name=$userval\n", $cmdvar);
	    } elsif ($lang eq 'cmdline') {
		next if $cmdvar eq '';
		# command-line argument
		# Insert the processed argument in the commandline
		# just before every occurance of the spot marker.
		D10("    CMDLINE - spot $spot, cmdvar $cmdvar");
		$dat->{'currentcmd'} =~ s!\%$spot!$cmdvar\%$spot!g;
		D10("    CMDLINE - output " . $dat->{'currentcmd'});
	    } elsif ($lang eq 'pcl'){
		next if $cmdvar eq '';
		D10("    PCLLINE - $name = $userval, cmdvar $cmdvar");
		$dat->{'pcl_command'} .= $cmdvar;
		D10("    PCLLINE - pclcommand " . $dat->{'pcl_command'});
	    } elsif ($lang eq 'pxl'){
		next if $cmdvar eq '';
		D10("    PXLLINE - $name = $userval, cmdvar $cmdvar");
		$dat->{'pxl_command'} .= ' ' . $cmdvar;
		D10("    PXLLINE - pclcommand " . $dat->{'pxl_command'});
	    }
	}
	

	### Tidy up after computing option statements

	## Commandline type finishing
	# Pluck out all of the %n's from the command line prototype
	if( $lang eq 'cmdline' ){
	    $dat->{'currentcmd'} =~ s!\%[A-Z]!!g;
	}

	## PJL type finishing
	# Compute the proper stuff to say around the job

	if ( ($lang eq 'pjl' or $lang eq 'jcl') and
	    ( $dat->{'jcl'} or $dat->{'pjl'} ) ) {

            # Command to start job
	    my $jcl = ($dat->{pjl_support}{'begin'} or $jclbegin) .
		join("\n", @jclprepend );
	    my @list = split( "\n", unhexify($jcl) );
	    map  { s/\x1b\%-12345X// } @list;
	    foreach (@list){
		s/^\s+//; s/\s+$//;
		next if not $_;
		if( not /^\@PJL/ ){ $_ = '@PJL ' . $_; }
		$_ .= "\n";
	    }
	    $dat->{'jclprepend'} = join('',(@list));

	    # Arrange for JCL RESET command at end of job
	    $jcl = ($dat->{pjl_support}{'end'} or $jclend );
	    @list = split( "\n", unhexify($jcl) );
	    map  { s/\x1b\%-12345X// } @list;
	    foreach (@list){
		s/^\s+//; s/\s+$//;
		next if not $_;
		if( not /^\@PJL/ ){ $_ = '@PJL ' . $_; }
		$_ .= "\n";
	    }
	    $dat->{'jclappend'} = join('',(@list));

	    # Put the JCL stuff into the data structure
	    $dat->{pjl_command} = $dat->{'jclprepend'} . $dat->{'jclappend'};
	}

	if( $lang eq 'ps' ){
	    ## G type finishing
	    # Save PostScript options
	    $dat->{'prologprepend'}    = join( '', (@prologprepend) );
	    $dat->{'setupprepend'}     = join( '', (@setupprepend) );
	    $dat->{'pagesetupprepend'} = join( '', (@pagesetupprepend) );
	    D10(" X6 prologprepend " . $dat->{prologprepend} );
	    D10(" X7 setupprepend " . $dat->{setupprepend} );
	    D10(" X8 pagesetupprepend " . $dat->{pagesetupprepend} );
	}
	if( $lang eq 'pcl' ){
	    # remove whitespace and then unhexify
	    $opts = $dat->{pcl_command};
	    $opts =~ s/[\s\n]//g;
	    $dat->{pcl_command} = unhexify($opts);
	}
    }
}

# put the JCL to enter a language at the end of the JCL
# We may need to do this based on the output of the rasterizer

sub set_jcl_enterlanguage( $ $ ){
    my($dat, $language) = @_;
    my $jcl = $dat->{pjl_support}{'tointerpreter'}{$language};
    my @list = split( "\n", unhexify($jcl) );
    foreach (@list){
	s/^\s+//; s/\s+$//;
	next if not $_;
	if( not /^\@PJL/ ){ $_ = '@PJL ' . $_; }
	$_ .= "\n";
    }
    if( @list ){
	return join('', @list);
    }
    return '';
}

sub buildpdqdriver( $ $ ) {


    # Build a PDQ driver description file to use the given PPD file
    # together with foomatic-rip with the PDQ printing system

    # Foomatic data and name of the option set for the default settings
    my ($dat, $optionset) = @_;
    D1("buildpdqdriver: optionset $optionset " . Dumper($dat) );

    # Construct structure with driver information
    my @pdqdriver = ();

    # Construct option list
    my @driveropts = ();

    # Do we have a "Custom" setting for the page size?
    # Then we have to insert the following into the "filter_exec" script.
    my @setcustompagesize = ();

    # Fata for a custom page size, to allow a custom size as default
    my $pagewidth = 612;
    my $pageheight = 792;
    my $pageunit = "pt";

    # Appears to be a hangover from some other code
    my $prefix = '';


    ## First, compute the various option/value clauses
    for my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	next if not $arg->{'option'};
	$arg->{'type'} = '' if not defined $arg->{'type'};
	if ($arg->{'type'} eq 'enum' or $arg->{'type'} eq 'pickmany') {
	
	    # Option with only one choice, omit it, foomatic-rip will set
	    # this choice anyway.
	    next if (@{$arg->{'vals'}} < 2);

	    my $nam = $arg->{'name'};

	    # Omit "PageRegion" option, it does the same as "PageSize".
	    next if $nam eq "PageRegion";

	    my $com = $arg->{'comment'};

	    # Assure that the comment is not empty
	    if (!$com) {
		$com = $nam;
	    }

	    my $def = $arg->{$optionset};
	    $arg->{'varname'} = "$nam";
	    $arg->{'varname'} =~ s![\-\/\.]!\_!g;
	    my $varn = $arg->{'varname'};

	    # 1, if setting "PageSize=Custom" was found
	    # Then we must add options for page width and height
	    my $custompagesize = 0;

	    # If the default is a custom size we have to set also
	    # defaults for the width, height, and units of the page
	    if (($nam eq "PageSize") &&
		($def =~ /^Custom\.([\d\.]+)x([\d\.]+)([A-Za-z]*)$/)) {
		$def = "Custom";
		$pagewidth = $1;
		$pageheight = $2;
		$pageunit = $3;
	    }

	    # No quotes, thank you.
	    $com =~ s!\"!\\\"!g;
	
	    push(@driveropts,
		 "  option {\n",
		 "    var = \"$varn\"\n",
		 "    desc = \"$com\"\n");
	
	    # get enumeration values for each enum arg
	    my (@valstmp);
	    for my $valname (@{$arg->{'vals'}}) {
		my $ev = $arg->{'vals_byname'}{$valname};
		my $choiceshortname = $ev->{'value'};
		my $choicename = "${nam}_${choiceshortname}";
		my $val = " -o ${nam}=${choiceshortname}";
		my $com = $ev->{'comment'};

		# Assure that the comment is not empty
		if (!$com) {
		    $com = $choiceshortname;
		}

		# stick another choice on driveropts
		push(@valstmp,
		     "    choice \"$choicename\" {\n",
		     "      desc = \"$com\"\n",
		     "      value = \"$val\"\n",
		     "    }\n");
		if (($nam eq "PageSize") &&
		    ($choiceshortname eq "Custom")) {
		    $custompagesize = 1;
		    if ($#setcustompagesize < 0) {
			push(@setcustompagesize,
			     "      # Custom page size settings\n",
			     "      # We aren't really checking for " .
			     "legal vals.\n",
			     "      if [ \"x\${$varn}\" == 'x$val' ]; " .
			     "then\n",
			     "        $varn=\"\${$varn}.\${PageWidth}" .
			     "x\${PageHeight}\${PageSizeUnit}\"\n",
			     "      fi\n\n");
		    }
		}
	    }

	    push(@driveropts,
		 "    default_choice \"" . $nam . '_' . ($def || '') . "\"\n",
		 @valstmp,
		 "  }\n\n");

	    if ($custompagesize) {
		# Add options to set the custom page size
		push(@driveropts,
		     "  argument {\n",
		     "    var = \"PageWidth\"\n",
		     "    desc = \"Page Width (for \\\"Custom\\\" page " .
		     "size)\"\n",
		     "    def_value \"$pagewidth\"\n",
		     "    help = \"Minimum value: 0, Maximum value: " .
		     "100000\"\n",
		     "  }\n\n",
		     "  argument {\n",
		     "    var = \"PageHeight\"\n",
		     "    desc = \"Page Height (for \\\"Custom\\\" page " .
		     "size)\"\n",
		     "    def_value \"$pageheight\"\n",
		     "    help = \"Minimum value: 0, Maximum value: " .
		     "100000\"\n",
		     "  }\n\n",
		     "  option {\n",
		     "    var = \"PageSizeUnit\"\n",
		     "    desc = \"Unit (for \\\"Custom\\\" page size)\"\n",
		     "    default_choice \"PageSizeUnit_$pageunit\"\n",
		     "    choice \"PageSizeUnit_pt\" {\n",
		     "      desc = \"Points (1/72 inch)\"\n",
		     "      value = \"pt\"\n",
		     "    }\n",
		     "    choice \"PageSizeUnit_in\" {\n",
		     "      desc = \"Inches\"\n",
		     "      value = \"in\"\n",
		     "    }\n",
		     "    choice \"PageSizeUnit_cm\" {\n",
		     "      desc = \"cm\"\n",
		     "      value = \"cm\"\n",
		     "    }\n",
		     "    choice \"PageSizeUnit_mm\" {\n",
		     "      desc = \"mm\"\n",
		     "      value = \"mm\"\n",
		     "    }\n",
		     "  }\n\n");		
	    }
	
	} elsif ($arg->{'type'} eq 'int' or $arg->{'type'} eq 'float') {
	
	    my $nam = $arg->{'name'};
	    my $com = $arg->{'comment'};

	    # Assure that the comment is not empty
	    if (!$com) {
		$com = $nam;
	    }

	    my $def = $arg->{$optionset};
	    my $max = $arg->{'max'};
	    my $min = $arg->{'min'};
	    $arg->{'varname'} = "$nam";
	    $arg->{'varname'} =~ s![\-\/\.]!\_!g;
	    my $varn = $arg->{'varname'};
	    my $legal = $arg->{'legal'} =
		"Minimum value: $min, Maximum value: $max";
	
	    my $defstr = '';
	    if ($def) {
		$defstr = sprintf("    def_value \"%s\"\n", $def);
	    }
	
	    push(@driveropts,
		 "  argument {\n",
		 "    var = \"$varn\"\n",
		 "    desc = \"$com\"\n",
		 $defstr,
		 "    help = \"$legal\"\n",
		 "  }\n\n");
	
	} elsif ($arg->{'type'} eq 'bool') {

	    my $nam = $arg->{'name'};
	    my $com = $arg->{'comment'};

	    # Assure that the comment is not empty
	    if (!$com) {
		$com = $nam;
	    }

	    my $tcom = $arg->{'vals_byname'}{'True'}{'comment'};
	    my $fcom = $arg->{'vals_byname'}{'False'}{'comment'};
	    my $def = $arg->{$optionset};
	    $arg->{'legal'} = "Value is a boolean flag";
	    $arg->{'varname'} = "$nam";
	    $arg->{'varname'} =~ s![\-\/\.]!\_!g;
	    my $varn = $arg->{'varname'};
	
	    my $defstr = '';
	    if ($def) {
		$defstr = sprintf("    default_choice \"%s\"\n",
				  $def ? "$nam" : "no$nam");
	    } else {
		$defstr = sprintf("    default_choice \"%s\"\n", "no$nam");
	    }
	    push(@driveropts,
		 "  option {\n",
		 "    var = \"$varn\"\n",
		 "    desc = \"$com\"\n",
		 $defstr,
		 "    choice \"$nam\" {\n",
		 "      desc = \"$tcom\"\n",
		 "      value = \" -o $nam=True\"\n",
		 "    }\n",
		 "    choice \"no$nam\" {\n",
		 "      desc = \"$fcom\"\n",
		 "      value = \" -o $nam=False\"\n",
		 "    }\n",
		 "  }\n\n");

	} elsif ($arg->{'type'} eq 'string' or $arg->{'type'} eq 'password') {
	    my $nam = $arg->{'name'};
	    my $com = $arg->{'comment'};
	    # Assure that the comment is not empty
	    $com = $nam if (!$com);

	    my $def = $arg->{$optionset};
	    my $maxlength = $arg->{'maxlength'};
	    my $proto = $arg->{'proto'}{'ps'};
	    $arg->{'varname'} = "$nam";
	    $arg->{'varname'} =~ s![\-\/\.]!\_!g;
	    my $varn = $arg->{'varname'};

	    my $legal;
            if (defined($maxlength)) {
                $legal .= "Maximum length: $maxlength characters, ";
            }
            $legal .= "Examples/special settings: ";
            for my $valname (@{$arg->{'vals'}}) {
		my $val = $arg->{'vals_byname'}{$valname};
                my ($value, $comment, $driverval) =
		    ($val->{'value'}, $val->{'comment'}, $val->{'driverval'}{'ps'});
		# Retrieve the original string from the prototype
		# and the driverval
		my $string;
		if ($proto) {
		    $proto =~ s/\%(?!s)/\%\%/g;
		    $string = sprintf($proto, $driverval);
		} else {
		    $string = $driverval;
		}
		if ($value ne $string) {
		    $legal .= "${value}: \\\"$string\\\"";
		} else {
		    $legal .= "\\\"$value\\\"";
		}
		if ($comment && ($value ne $comment) &&
		    ($string ne $comment) &&
		    (($value ne 'None') || ($comment ne '(None)'))) {
		    $legal .= " ($comment)";
		}
		$legal .= "; ";
	    }
	    $legal =~ s/; $//;

	    $arg->{'legal'} = $legal;
	
	    my $defstr = '';
	    if ($def) {
		$defstr = sprintf("    def_value \"%s\"\n", $def);
	    }
	
	    push(@driveropts,
		 "  argument {\n",
		 "    var = \"$varn\"\n",
		 "    desc = \"$com\"\n",
		 $defstr,
		 "    help = \"$legal\"\n",
		 "  }\n\n");
	
	}
	
    }



    ## Define the "docs" option to print the driver documentation page

    push(@driveropts,
	 "  option {\n",
	 "    var = \"DRIVERDOCS\"\n",
	 "    desc = \"Print driver usage information\"\n",
	 "    default_choice \"nodocs\"\n",
	 "    choice \"docs\" {\n",
	 "      desc = \"Yes\"\n",
	 "      value = \" -o docs\"\n",
	 "    }\n",
	 "    choice \"nodocs\" {\n",
	 "      desc = \"No\"\n",
	 "      value = \"\"\n",
	 "    }\n",
	 "  }\n\n");



    ## Build the "foomatic-rip" command line
    my $commandline = "foomatic-rip --pdq";
    if ($printer) {
	$commandline .= " -P $printer";
    } else {
	# Make sure that the PPD file is entered with an absolute path
	if ($ppdfile !~ m!^/!) {	
	    my $pwd = getcwd;
	    $ppdfile = "$pwd/$ppdfile";
	}
	$commandline .= " --ppd=$ppdfile";
    }
    for my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
	if ($arg->{'varname'}) {
	    $commandline .= "\${$prefix$arg->{'varname'}}";
	}
    }
    $commandline .= "\${DRIVERDOCS} \$INPUT > \$OUTPUT";



    ## Now we generate code to build the command line snippets for the
    ## numerical options

    my @psfilter;
    for my $argname (@{$dat->{'args'}}) {
	my $arg = $dat->{'args_byname'}{$argname};
		
	# Only numerical and string options need to be treated here
	next if (($arg->{'type'} ne 'int') &&
		 ($arg->{'type'} ne 'float') &&
		 ($arg->{'type'} ne 'string') &&
		 ($arg->{'type'} ne 'password'));

	my $comment = ($arg->{'comment'} || '');
	my $name = $arg->{'name'};
	my $varname = ($arg->{'varname'} || $name);

	# If the option's variable is non-null, put in the
	# argument.  Otherwise this option is the empty
	# string.  Error checking?

	$arg->{'type'} = '' if not defined $arg->{'type'};
	push(@psfilter,
	     "      # $comment\n",
	     (($arg->{'type'} eq 'int') || ($arg->{'type'} eq 'float') ?
	      ("      # We aren't really checking for max/min,\n",
	       "      # this is done by foomatic-rip\n",
	       "      if [ \"x\${$varname}\" != 'x' ]; then\n  ") : ''),
	     "      $varname=\" -o $name='\${$varname}'\"\n",
	     (($arg->{'type'} eq 'int') || ($arg->{'type'} eq 'float') ?
	      "      fi\n" : ''),
	     "\n");
    }

    # Command execution

    push(@psfilter,
	 "      if ! test -e \$INPUT.ok; then\n",
	 "        sh -c \"$commandline\"\n",
	 "        if ! test -e \$OUTPUT; then \n",
	 "          echo 'Error running foomatic-rip; no output!'\n",
	 "          exit 1\n",
	 "        fi\n",
	 "      else\n",
	 "        ln -s \$INPUT \$OUTPUT\n",
	 "      fi\n\n");

    my $version = time();
    my $name = "$model-$version";
    $name =~ s/\W/\-/g;
    $name =~ s/\-+/\-/g;

    my $pname = $model;

    push (@pdqdriver,
	  "driver \"$name\" {\n\n",
	  "  # This PDQ driver declaration file was generated " .
	  "automatically by\n",
	  "  # foomatic-rip from information in the file $ppdfile.\n",
	  "  # It allows printing with PDQ on the $pname.\n",
	  "\n",
	  "  requires \"foomatic-rip\"\n\n",
	  @driveropts,
	  "  language_driver all {\n",
	  "    # We accept all file types and pass them to foomatic-rip\n",
	  "    # (invoked in \"filter_exec {}\" section) without\n",
          "    # pre-filtering\n",
	  "    filetype_regx \"\"\n",
	  "    convert_exec {\n",
	  "      ln -s \$INPUT \$OUTPUT\n",
	  "    }\n",
	  "  }\n\n",
	  "  filter_exec {\n",
	  @setcustompagesize,
	  @psfilter,
	  "  }\n",
	  "}\n");

    return @pdqdriver;

}

# checkchild waits for any exited child and prints
# a message
sub checkchild(){
    my $pid;
    while( ($pid = waitpid(-1,&WNOHANG)) != -1 and $pid ){
	my $name = "Unknown Child";
	$name = "Stderr logger" if $pid == $debugpid;
	$name = "Document generator" if  $pid == $docgeneratorpid;
	$name = "File converter" if $pid == $fileconverterpid;
	$name = "Render" if $pid == $renderpid;
	$name = "Fixup" if $pid == $fixuppid;
	$name = "Postpipe" if $pid == $postpipepid;
	my ($s, $signal, $retval) = decode_status($?);
	D0("$name: process $pid exited, $s\n");
	$retval = fix_codes( $signal, $retval );
	rip_die ("Child exited with error", $retval) if $retval;
    }
}

sub expandoptions( $ $ $ $ $ $){

    my( $dat, $opts, $optionset, $verbose, $precedence, $warning_header ) = @_;
    my @input_opts = @{$opts} if defined( $opts );
    my $option_values = {};
    my $xcount = 0;

    D0 "expandoptions: undefined precedence value" if( not defined $precedence );
    $precedence = 0;
    # First we scan the list of options for composite options and
    # remove all off the 'controlled_by' flags on options set by the current
    # option value.
    for( my $i = 0; $i < @input_opts; ++$i ){
	my $option = $input_opts[$i];
	$option =~ s/^(even|odd|[\d,-]+)://i;
	# is it an alias?
	my $alias= findalias( $dat, $option );
	if ( m!^([^=:]+)[:=](.*)! ){
	    my ($aname, $avalue) = ($1, $2);
	    my $arg = argbyname($dat, $aname);
	    if( $arg ){
		my $name = $arg->{'name'};
		next if not $arg->{'argstyle'}{'composite'};
		D10( "FOUND ARG " . Dumper($arg) );
		# now we remove all of the 'controlled_by' entries
		# which match this one
		foreach my $argname (keys %{$dat->{'args_byname'}}){
		    my $arg = $dat->{'args_byname'}{$argname};
		    next if not $arg->{controlled_by};
		    if( $arg->{controlled_by} eq $name ){
		    	$arg->{controlled_by} = undef;
		    }
		}
	    }
	}
    }

    while( @input_opts and $xcount++ < 1000 ){
	my $option = shift @input_opts;
	my $lc_option = lc($option);
	my $arg;
	
	D0("Pondering option '$option'\n") if $verbose;

	# Is the command line option limited to certain page ranges? If so,
	# mark the setting with a hash key containing the ranges
	my $controlled_by = '';
	if ($option =~ s/^(@[^@]*@)//i) {
	    $controlled_by = $1;
	}
	my $pagerange = '';
	if ($option =~ s/^(even|odd|[\d,-]+)://i) {
	    $pagerange = "$1:";
	}
	D10( "    PageRange '$pagerange'" );

	# try alias translation first - you may get multiple options back
	my $alias= findalias( $dat, $option );
	if( $alias ){
	    D0(" Option $option is alias for $alias") if $verbose;
	    unshift @input_opts, ($controlled_by . $pagerange . $alias);
	    next;
	}
	$_ = $option;
	if ( (m!([^=:]+)[:=][\'\"]?([^\'\"]*)[\'\"]?!) ) {
	    my ($aname, $avalue) = ($1, $2);
	    my $arg = argbyname($dat, $aname);

	    D10( "    Split Option aname='$aname' avalue='$avalue'" );

	    # At first look for the "backend" option to determine the PPR
	    # backend to use
	    if (($aname =~ m!^backend$!i) && ($spooler eq 'ppr_int')) {
		# Backend interface name
		$backend = $avalue;
		D10( "    Setting PPR backend '$backend'" );
	    } elsif ($aname =~ m!^media$!i) {

		D10( "    Handling media '$avalue'" );

		# Standard arguments?
		# media=x,y,z
		# sides=one|two-sided-long|short-edge

		# Rummage around in the media= option for known media, source,
		# etc types.
		# We ought to do something sensible to make the common manual
		# boolean option work when specified as a media= tray thing.
		#
		# Note that this fails miserably when the option value is in
		# fact a number; they all look alike.  It's unclear how many
		# drivers do that.  We may have to standardize the verbose
		# names to make them work as selections, too.

		my @values = split(',',$avalue);
		for (@values) {
		    my ($d, $v);
		    if (($d = argsbyname('PageSize')) and
			defined($v = valbyname($d,$_)) ) {
			$v =  "PageSize='$v'";
		    } elsif (($d = argsbyname('PageSize')) and /^Custom/i ){
			$v =  "PageSize='$_'";
		    } elsif (($d = argsbyname('MediaType')) and
			defined ($v = valbyname($d, $_)) ) {
			$v =  "MediaType='$v'";
		    } elsif (($d = argsbyname('InputSlot')) and
			defined ($v = valbyname($d, $_)) ) {
			$v =  "InputSlot='$v'";
		    } elsif ($_ =~  m!manualfeed!i
			and ($d = argsbyname('ManualFeed'))
			and defined($v = valbyname($d,'True')) ) {
			# feeder option if we didn't match an InputSlot above
			$v =  "ManualFeed='$v'";
		    } else {
			D0("  Unknown \"media\" component: \"$_\".\n") if $verbose;
		    }
		    if( defined $v ){
			D0("  Replacing $_ by $v") if $verbose;
			unshift @input_opts, $controlled_by . $pagerange . $v;
		    }
		}
	    } elsif ($aname =~ m!^sides$!i) {
		# Handle the standard duplex option, mostly
		D10( "    Handling sides '$avalue'" );
		my $v;
		if ($avalue =~ m!^two-sided!i or $avalue =~ m!^duplex!i ) {
		    if (defined($dat->{'args_byname'}{'Duplex'})) {
			# Check the binding: "long edge" or "short edge"
			if ($avalue =~ m!long-edge!i) {
			    $v =  "lduplex";
			} elsif ($avalue =~ m!short-edge!i) {
			    $v =  "sduplex";
			} else {
			    $v =  "duplex";
			}
		    } else {
			D0("  Unknown \"media\" component: \"$avalue\".\n") if $verbose;
		    }
		} elsif ($avalue =~ m!^one-sided!i) {
		    if (defined($dat->{'args_byname'}{'Duplex'})) {
			$v =  "simplex";
		    } else {
			D0("  Unknown \"media\" component: \"$avalue\".\n") if $verbose;
		    }
		}
		if( defined $v ){
		    D0("  Replacing $aname by $v") if $verbose;
		    unshift @input_opts, $controlled_by.$pagerange.$v;
		}

		# We should handle the other half of this option - the
		# BindEdge bit.  Also, are there well-known ipp/cups
		# options for Collate and StapleLocation?  These may be
		# here...

	    } else {
		D10( "    Processing $aname='$avalue'");

		# Option Processing
		# This is where we actually decide what
		# to do about the options
		# set $option_values hash with the list
		if ($arg = argbyname($dat, $aname)) {
		    my $name = $arg->{'name'};
		    my $value;
		    my $range = $pagerange;
		    D10( "    MAP pagerange '$range' $aname => '$name'");
		    # If the choice is valid, use it, otherwise
		    # ignore it.
		    if (defined( $value =
			    checkoptionvalue($arg, $avalue, 0))) {
			D10( "    MAP ARG $avalue => '$value'");
			my $old_precedence = ($arg->{'precedence'} || 0);
			if( $precedence >= $old_precedence ){
			    $arg->{'precedence'} = $precedence;
			}
			if( $arg->{'controlled_by'} ){
			    D0(" Option '$name' controlled by $arg->{'controlled_by'}, cannot modify");
				next;
			}
			if ( $range ){
			    my $found = 0;
			    my $section = $arg->{'section'};
			    foreach my $language (keys %{$section}){
				my $v = $section->{$language};
				$found = 1 if($v =~ /^(Any|Page|JCL)Setup/);
			    }
			    if( not $found ){
				D0("  The $name option is not a PageSetup, ".
				"AnySetup, or JCLSetup option, so it cannot be restricted to " .
				"a page range.\n");
				$range = '';
			    }
			}
			# If this argument is PageSize or PageRegion,
			# also set the other
			$option_values->{$name} = $arg;
			if( $range ){
			    push @{$arg->{'pagerange'}}, "$range$name=$value";
			} else {
			    if( $arg->{'type'} eq 'pickmany' ){
				$value = $arg->{$optionset} =
				    fix_pickmany( $arg,
					$arg->{$optionset}, $value );
			    } else {
				$arg->{$optionset} = $value;
				syncpagesize($dat, $name, $value, $optionset );
			    }
			}
			my $cb = '';
			if( $controlled_by ){
			    my ($n) = $controlled_by =~ m/\@([^@]*)\@/;
			    $arg->{'controlled_by'} = $n;
			    $cb = ", controlled by $n";
			}
			D0(" Maps to $range$name='$value'$cb") if $verbose;
			# now we handle the case where we have a composite option
			if( $arg->{'argstyle'}{'composite'} ){
			    my $lang = $arg->{'argstyle'}{'composite'};
			    my $type = $arg->{'type'};
			    D10("   COMPOSITE name $name, lang $lang, type '$type' value = $value");
			    if( $type ne 'enum' and $type ne 'bool'
				and $type ne 'pickmany' ){
				D0("  Composite option $name has bad type $type");
				next;
			    }
			    foreach my $val( split(/,;:/, $value ) ){
				next if $type eq 'pickmany' and $val =~ m/^no/;
				my $expand = valbyname($arg,$val);
				D10("   COMPOSITE name $name, lang $lang, value = $val");
				if( not $expand ){
				    D0("  No value for composite option $name =$val");
				    next;
				}
				my $string = ($expand->{driverval}{$lang} || '');
				$string =~ s/\s+/ /g;
				D10("    COMPOSITE setting '$string'");
				# now we need to get the options, which have the
				# format key=value or key="value", and value has
				# no spaces in it
				$controlled_by = "\@$name\@" if( not $controlled_by );
				foreach my $v ( reverse split(' ',$string ) ){
				    unshift @input_opts, $controlled_by . $v;
				}
				D10("   FINAL @input_opts");
			    }
			}
		    } else {
			# Invalid choice, make log entry
			D0("  ${warning_header}Invalid choice $aname=$avalue. Use: '" .
			    join("', '", @{$arg->{'vals'}} ) . "'\n");
		    }
		} elsif ($spooler eq 'ppr_int') {
		    # Unknown option, pass it to PPR's backend interface
		    push (@backendoptions, "$aname=$avalue");
		} else {
		    # Unknown option, make log entry
		    D0("${warning_header}Unknown option $aname=$avalue.\n") if $verbose;
		}
	    }
	} elsif (m!^([\d\.]+)x([\d\.]+)([A-Za-z]*)$!) {
	    my ($w, $h, $u) = ($1, $2, $3);
	    # Custom paper size
	    D10( "    Custom paper size '$_'");
	    if (($w != 0) && ($h != 0) &&
		($arg=argbyname($dat, "PageSize")) &&
		(defined($arg->{'vals_byname'}{'Custom'}))) {
		my $v = $controlled_by . ${pagerange}. "PageSize='Custom.${w}x${h}${u}'";
		D0("  Replacing $_ by $v") if $verbose;
		unshift @input_opts, $v;
	    } else {
		D0("Custom paper size option not supported- $_.\n") if $verbose;
	    }
	} elsif ((m!^\s*no(.+)\s*$!i) and ($arg=argbyname($dat, $1))
	    and $arg->{'type'} eq 'bool' ){
		D10( "    Boolean option $arg->{'name'} - FALSE");
		# standard bool args:
		# landscape; what to do here?
		# duplex; we should just handle this one OK now?
		my $v = $controlled_by. $pagerange . "$arg->{name}='False'";
		D0("  Replacing $_ by $v") if $verbose;
		unshift @input_opts, $v;
	} elsif ((m!^\s*(.+)\s*$!i) and ($arg=argbyname($dat, $1))
	    and $arg->{'type'} eq 'bool' ){
		D10( "    Boolean option $arg->{'name'} - TRUE");
		my $v = $controlled_by . $pagerange. "$arg->{'name'}='True'";
		D0("  Replacing $_ by $v") if $verbose;
		unshift @input_opts, $v;
	} else {
	    D0("  Unknown option \"$_\".\n") if $verbose;
	}
    }
    if( @input_opts ){
	my $cnt = @input_opts;
	my $list = join( ", ", splice(@input_opts, 0, 10 ) );
	rip_die("Option expansion loop, $cnt options remaining, '" .
	    $list . ", ..." ,
	    $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
    return $option_values;
}

sub trim_options( $ $ $ ){
    my( $line, $length, $indent ) = @_; 
    my $header = '';
    $line = '' if not defined $line;
    while( length($line) > 0 ){
	$line =~ s/^\s+//;
	my($start,$end) = $line =~ m/^(.{1,$length}[^\s]*)(.*)$/;
	# D1("START '$start' END '$end'");
	D0("$header$start\n");
	$header = $indent;
	$line = $end;
    }
}

sub trim_options_stdout( $ $ $ ){
    my( $line, $length, $indent ) = @_; 
    my $header = '';
    $line = '' if not defined $line;
    while( length($line) > 0 ){
	$line =~ s/^\s+//;
	my($start,$end) = $line =~ m/^(.{1,$length}[^\s]*)(.*)$/;
	# D1("START '$start' END '$end'");
	print STDOUT "$header$start\n";
	$header = $indent;
	$line = $end;
    }
}

# check constraints
# Constraints have hash entry:
#  {constraint}{option1}{value1}{option2}{value2} = 1
#  {constraint}{option1}{value1}{option2}{'*'} = 1
#  {constraint}{option1}{'*'}{option2}{value2} = 1
#  {constraint}{option1}{'*'}{option2}{'*'} = 1
#


sub checkconstraints( $ $ ){
    my( $dat, $optionset ) = @_;
    my $constraint = $dat->{constraint};
    D20("checkconstraints: " . Dumper($constraint) );
    if( $constraint ){
	chkconstr( $dat, $optionset, $constraint, '' );
    }
}

# This does the recursive checking of the constraints
#  You could, in principle, have as many as you liked deep
#
sub chkconstr( $ $ $ $ ){
    my ($dat, $optionset, $constraint, $previous ) = @_;
    D20("chkconstr: previous '$previous'");
    foreach my $name ( keys %{$constraint} ){
	my $arg = $dat->{'args_byname'}{$name};
	next if not defined $arg;
	my $type = $arg->{'type'};
	next if not defined $type;
	# now we have to see if the type is bool, enum, or pickmany
	next if $type ne 'enum' and $type ne 'bool' and $type ne 'pickmany';
	my $value = $arg->{$optionset};
	if( not $value ){
	    D0("chkconstr: LOGIC ERROR - arg $name, optionset $optionset - no value");
	    next;
	}
	D20("chkconstr: previous '$previous' arg '$name' value '$value'");
	# we have the subconstrant.  We see if the combination
	# of option2/value2 is defined
	if( $constraint->{$name}{'*'} ){
	    next if( $value eq 'None' or $value eq 'False');
	    if( $type eq 'pickmany' ){
		my $none_set = 1;
		foreach my $value ( split( /[,;;]/, $value) ){
		    my($no,$name)= $value =~ m/^(no|)(.*)$/;
		    $none_set = 0 if not $no;
		}
		next if $none_set;
	    }
	    my $sub_constraint = $constraint->{$name}{'*'};
	    my $found = "$previous $name=$value";
	    if( ref $sub_constraint ){
		chkconstr( $dat, $optionset, $sub_constraint, $found );
	    } else {
		D0("Warning: constraint violation $found");
	    }
	    next;
	}
	foreach my $sb_value (split( /[,;;]/, $value) ){
	    next if $type eq 'pickmany' and $sb_value =~ /^no/;
	    my $sub_constraint = $constraint->{$name}{$sb_value};
	    next if not $sub_constraint;
	    my $found = "$previous $name=$sb_value";
	    if( ref $sub_constraint ){
		chkconstr( $dat, $optionset, $sub_constraint, $found );
	    } else {
		D0("Warning: constraint violation $found");
	    }
	}
    }
}

# Command substitution
# 
#  String:
#    \%[sprintf format]s{variable}
#    Example:
#      \%s{env.TMP}
#      \%10s{option.J}
#      \%-5s{PageSize}
#      \%-*s{PageSize,-5}
#  Integer
#    Example:
#    \%[sprintf format]d{variable}
#      \%{env.w}
#  Float
#    Example:
#    \%[sprintf format]f{variable}
# 
# When processing a string, integer, or flag value,  the value of the variable is
# cast to the appropriate type and then processed by the sprintf function.
# 
# The variable entries have the following format.  The notation used here
# is based on Perl for discussion purposes.
# 
#   Term:
#     "string"   - a literal string value.  Integers and floats are represented
#                  as strings, i.e. "10" and "10.0".
#     DATE       - the current date in YYYY-MM-DD-HH:MM:SS
#                  eg-    2003-12-12-07:10:19
#     cmd.X  -    value of the command line single character option 'X'
#                 Note: if the -c option is present, the value will be
#                 reported as 1; if not, as 0.  This makes the usage consistent
#                 with the LPD filter option convension.
#     Option     - the current value of an option.
# 
#   Variable:
#    term
#    test?variable:variable
# 
#   Test:
#    Test Format   Meaning
#    term      Perl test for TRUE string value
#    !term     Perl test for FALSE string value
#    term (eq, ne, gt, lt, ge, le) term
#    term (==, !=, <, >, >=, <=) term
# 
# 
# The cmd options are taken from current command
# line options, assuming the LPD option passing conventions.  This is basically
# that options have the form:  -X value  or -Xvalue.
#
# Do option value replacement on a string
#
#
# Do option value replacement on a string
#
# termval:
# $term_value =
#   my($dat, $optionset, $term )
# get the value of the term 

sub termval( $ $ $ ){
    my($dat, $optionset, $term ) = @_;
    my $v = '';
    $term =~ s/^\s+//;
    $term =~ s/\s+$//;
    my $neg = ($term =~ s/^\!\s*//);
    D10("   termval:  neg $neg, term '$term'");
    if( $neg ){
	$v = termval( $dat, $optionset, $term );
	$v = not $v;
	$v = '' if not defined $v;
	D10("termval:  neg return '$v'");
	return $v;
    }
    my( $prefix, $suffix ) = split( /\./, $term, 2 );
    D10("   termval:  prefix '$prefix' suffix '".($suffix?$suffix:"UNDEF")."'");
    if( not defined $suffix ){
	if( $prefix eq 'DATE' ){
	    $v = strftime( "%Y-%m-%d-%H:%M:%S",localtime time);
	} elsif( $prefix =~ m/^\'(.*)\'$/
		or  $prefix =~ m/^\"(.*)\"$/
		or $prefix =~ m/^(\d*)$/ ){
	    $v = $1;
	} else {
	    my $arg = argbyname( $dat, $prefix );
	    $v = $arg->{$optionset};
	}
    } elsif( $prefix eq 'cmd' ){
	$v = '' if( not defined ($v = $dat->{cmd_option}{$suffix}) ); 
    }
    $v = '' if not defined $v;
    D10("   termval:  return '$v'");
    return $v;
}

sub repval( $ $ $ $ $ ){
    my($dat, $optionset, $opt, $format, $term ) = @_;
    my( $test, $true, $false ) = $term =~ m/^([^\?]*?)\?([^\:]*)\:(.*)$/;
    my $v = '';
    if( not $test ){
	$v = termval( $dat, $optionset, $term );
    } else {
	D10("repval: test '$test' true '$true' false '$false'");
	my($left,$cmp,$right,$result);
	if( (($left,$cmp,$right) = ($test =~ m/^\s*(\S*?)\s+(\S*?)\s+(\S*?)\s*$/)) ){
	    D10("repval: left '$left' cmp '$cmp' right '$right'");
	    $left = termval( $dat, $optionset, $left );
	    $right = termval( $dat, $optionset, $right );
	    if( $cmp =~ /^[a-z]*$/ ){
		$left = '' if not defined $left;
		$right = '' if not defined $right;
		$result = eval "'$left' $cmp '$right'";
	    } else {
		$left = 0 if not defined $left or $left eq '';
		$right = 0 if not defined $right or $right eq '';
		$result = eval "$left $cmp $right";
	    }
	    D10("repval: EVAL left '$left' cmp '$cmp' right '$right' result '$result'");
	    if( $@ ){
		D10("Bad expr $left $cmp $right $term");
	    }
	} else {
	    $result = termval( $dat, $optionset, $test );
	}
	D10("repval: result '$result'");
	if( $result ){
	    D10("repval: doing true '$true'");
	    $v = termval( $dat, $optionset, $true );
	} else {
	    D10("repval: doing false '$false'");
	    $v = termval( $dat, $optionset, $false );
	}
	D10("repval: final value '$v'");
    }
    $v = '' if not defined $v;
	no strict;
    $v =  "$v" if( $format eq 's' );
    $v =  $v+0 if( $format eq 'd' );
    $v =  $v+0.0 if( $format eq 'f' );
	use strict;
    $v = sprintf( "%$opt$format", $v );
}


sub fixopts( $ $ $ ){
    my($dat, $optionset, $str ) = @_;
    # options
    # space   prefix positive number with a space
    # +       prefix positive number with a plus sign
    # -       left-justify within the field
    # 0       use zeros, not spaces, to right-justify
    # #       prefix non-zero octal with "0", non-zero hex with "0x"
    # number  minimum field width
    # .number "precision": digits after decimal point for
    #       floating-point, max length for string, minimum length
    #       for integer
    my $s = $str;
    $s =~ s/\\%([ \+\d\.\+\-]*?)([dfs])\{([^\}]*?)\}/repval($dat, $optionset, $1, $2, $3)/egx;
    D10("   fixopts: optionset '$optionset' inputstr '$str' output str '$s'");
    return $s;
}


#my $dat = {};
#my $dat->{cmd_option} = { J => 'Job name' };
#my $optionset = 'default';
#
#print STDERR "Fixed '" . fixopts( $dat, $optionset, "\\%s{ \"DATE\"} \\%12s{'DATE'} \\%-12s{'DATE'}" ) . "'\n";
#print STDERR "Fixed '" . fixopts( $dat, $optionset, "\\%d{\"12\"} \\%12d{'12'} \\%-12s{'12'}" ) . "'\n";
#print STDERR "Fixed '" . fixopts( $dat, $optionset, "\\%s{\"DATE\"} \\%s{DATE} \\%s{cmd.J}" ) . "'\n";
#print STDERR "Fixed '" . fixopts( $dat, $optionset, "\\%d{!'1'} \\%d{!'0'}" ) . "'\n";
#print STDERR "Fixed '" . fixopts( $dat, $optionset, "\\%s{'1' != '0'?1:0} \\%s{'1' == '0'?1:0} ") . "'\n";
#print STDERR "Fixed '" . fixopts( $dat, $optionset, "\\%s{DATE} \\%s{cmd.J}") . "'\n";

# Emacs tabulator/indentation

### Local Variables:
### tab-width: 8
### perl-indent-level: 4
### End:
