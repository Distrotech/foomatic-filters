#!@PERL@

# The above Perl path may vary on your system; fix it!!!

my $ripversion='$Revision$';
#'# Fix emacs syntax highlighting

# foomatic-rip is a spooler-independent filter script which takes
# PostScript as standard input and generates the printer's page
# description language (PDL)/raster format as standard output. This
# kind of filter is usually called Raster Image Processor (RIP),
# therefore the name "foomatic-rip".

# Save it in one of the directories of your $PATH, so that it gets
# found when called from the command line (for spooler-less printing),
# link it to spooler-specific directories when you use CUPS or PPR:

#    ln -s /usr/bin/foomatic-rip /usr/lib/cups/filter/
#    ln -s /usr/bin/foomatic-rip /usr/lib/ppr/lib/
#    ln -s /usr/bin/foomatic-rip /usr/lib/ppr/interfaces/

# Mark this filter world-readable and world-executable (note that most
# spoolers run the print filters as a special user, as "lp", not as
# "root" or as the user who sent the job).

# See http://www.linuxprinting.org/<NOT WRITTEN YET>.html

# ==========================================================================
#
#    User-configurable settings, edit them if needed
#
# ==========================================================================

# What path to use for filter programs and such.  Your printer driver
# must be in the path, as must be the renderer, $enscriptcommand, and
# possibly other stuff.	 The default path is often fine on Linux, but
# may not be on other systems.
#
my $execpath = "/usr/local/bin:/usr/bin:/bin";

# Location of the configuration file "filter.conf", this file can be
# used to change the settings of foomatic-rip without editing
# foomatic-rip. itself. This variable must contain the full pathname 
# of the directory which contains the configuration file, usually
# "/etc/foomatic".
my $configpath = "/etc/foomatic";

# For the stuff below, the settings in the configuration file have priority.

# Set to 1 to insert postscript code for page accounting (CUPS only).
my $ps_accounting = 1;

# Enter here your personal command for converting non-postscript files
# (especially text) to PostScript. If you leave it blank, at first the
# line "textfilter: ..." from /etc/foomatic/filter.conf is read and
# then the commands given on the list below are tried, beginning with
# the first one.
# You can set this to "a2ps", "enscript" or "mpage" to select one of the 
# default command strings.
my $fileconverter = "";

# What 'echo' program to use.  It needs -e and -n.  Linux's builtin
# and regular echo work fine; non-GNU platforms may need to install
# gnu echo and put gecho here or something.
#
my $myecho = 'echo';

# Set debug to 1 to enable the debug logfile for this filter; it will
# appear as defined by $logfile. It will contain status from this
# filter, plus the renderer's stderr output. You can also add a line
# "debug: 1" to your /etc/foomatic/filter.conf to get all your
# Foomatic filters into debug mode.
#
# WARNING: This logfile is a security hole; do not use in production.
my $debug = 0;

# This is the location of the debug logfile (and also the copy of the
# processed PostScript data) in case you have enabled debugging above.
# The logfile will get the extension ".log", the PostScript data ".ps".
my $logfile = "/tmp/foomatic-rip";

# End interesting enduser options

# ==========================================================================
#
# foomatic-rip spooler-independent PS->Printer filter (RIP) of Foomatic
#
# Copyright 2002 Grant Taylor <gtaylor@picante.com>
#		 & Till Kamppeter <till.kamppeter@gmx.net>
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2 of the License, or (at your
#  option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#  Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#  USA.
#

# Flush everything immediately.
$|=1;



## Costants used by this filter

# Error codes, as some spooles behave different depending on the reason why
# the RIP failed, we return an error code. As I have only found a table of
# error codes for the PPR spooler. If our spooler is really PPR, these
# definitions get overwritten by the ones of the PPR version currently in
# use.

$EXIT_PRINTED = 0;         # file was printed normally
$EXIT_PRNERR = 1;          # printer error occured
$EXIT_PRNERR_NORETRY = 2;  # printer error with no hope of retry
$EXIT_JOBERR = 3;          # job is defective
$EXIT_SIGNAL = 4;          # terminated after catching signal
$EXIT_ENGAGED = 5;         # printer is otherwise engaged (connection 
                           # refused)
$EXIT_STARVED = 6;         # starved for system resources
$EXIT_PRNERR_NORETRY_ACCESS_DENIED = 7;     # bad password? bad port
                                            # permissions?
$EXIT_PRNERR_NOT_RESPONDING = 8;            # just doesn't answer at all 
                                            # (turned off?)
$EXIT_PRNERR_NORETRY_BAD_SETTINGS = 9;      # interface settings are invalid
$EXIT_PRNERR_NO_SUCH_ADDRESS = 10;          # address lookup failed, may be 
                                            # transient
$EXIT_PRNERR_NORETRY_NO_SUCH_ADDRESS = 11;  # address lookup failed, not 
                                            # transient
$EXIT_INCAPABLE = 50;                       # printer wants (lacks) features
                                            # or resources
# Standard Unix signal names
$SIGHUP = 1;
$SIGINT = 2;
$SIGQUIT = 3;
$SIGKILL = 9;
$SIGTERM = 15;
$SIGUSR1 = 10;
$SIGUSR2 = 12;
$SIGTTIN = 21;
$SIGTTOU = 22;



## Some important variables

# We don't know yet, which spooler will be used. If we don't detect
# one.  we assume that we do spooler-less printing. Supported spoolers
# are currently:

#    cups    - CUPS - Common Unix Printing System
#    lpd     - LPD - Line Printer Daemon
#    lprng   - LPRng - LPR - New Generation
#    gnulpr  - GNUlpr, an enhanced LPD (development stopped)
#    ppr     - PPR (foomatic-rip runs as a PPR RIP)
#    ppr_int - PPR (foomatic-rip runs as an interface)
#    pdq     - PDQ - Print, Don't Queue
#    direct  - Direct, spooler-less printing (also CPS)

$spooler = 'direct';

# PPD file name
$ppdfile = "";

# Printer model
$model = "";

# Printer queue name
$printer = "";

# Printing options
$optstr = "";

# Job title
$jobtitle = "";

# Post pipe (command into which the output of this filter should be piped)
$postpipe = "";

# Files to be printed
@filelist = ();

# JCL prefix to put before the JCL options (Can be modified by a
# "*JCLBegin:" keyword in the PPD file):
$jclbegin = "\033%-12345X\@PJL\n";

# JCL command to switch the printer to the PostScript interpreter (Can
# be modified by a "*JCLToPSInterpreter:" keyword in the PPD file):
$jcltointerpreter = "";

# JCL command to close a print job (Can be modified by a "*JCLEnd:"
# keyword in the PPD file):
$jclend = "\033%-12345X\@PJL RESET\n";

# Under which name were we called and in which directory do we reside
$0 =~ m!^(.*/)([^/]+)$!;
$programdir = $1;
$programname = $2;

# Filters to convert non-PostScript files
my @fileconverters = 
  (# a2ps (converts also other files than text)
   'a2ps -1 @@--medium=@@PAGESIZE@@ @@--center-title=@@JOBTITLE@@ -o -',
   # enscript
   'enscript -G @@-M @@PAGESIZE@@ @@-b "Page $%|@@JOBTITLE@@ ' .
   '--margins=36:36:36:36 --mark-wrapped-lines=arrow --word-wrap -p-',
   # mpage
   'mpage -o -1 @@-b @@PAGESIZE@@ @@-H -h @@JOBTITLE@@ -m36l36b36t36r ' .
   '-f -P- -');

# spooler-specific file converters, default for the specific spooler when
# none of the converters above is chosen.
$spoolerfileconverters = {
    'cups' => "${programdir}texttops '$ARGV[0]' '$ARGV[1]' '$ARGV[2]' " .
	"'$ARGV[3]' '$ARGV[4] page-top=36 page-bottom=36 " .
	"page-left=36 page-right=36 nolandscape cpi=12 lpi=7 " .
	"columns=1 wrap'"
    };



## Config file

# Read config file if present
%conf = readConfFile("$configpath/filter.conf");

# Get execution path from config file
if ($execpath) {$ENV{'PATH'} = $execpath;}

# Set debug mode
$debug = $conf{debug} if defined(%conf) and defined $conf{debug};

# Determine which filter to use for non-PostScript files to be converted
# to PostScript
if (defined(%conf) and $conf{textfilter}) {
    $fileconverter = $conf{textfilter};
    $fileconverter eq 'a2ps' and $fileconverter = $fileconverters[0];
    $fileconverter eq 'enscript' and $fileconverter = $fileconverters[1];
    $fileconverter eq 'mpage' and $fileconverter = $fileconverters[2];
}



## Environment variables;

# "PPD": PPD file name for CUPS or PPR (if we run as PPR RIP)
if (defined($ENV{'PPD'})) {
    $ppdfile = $ENV{'PPD'};
    # CUPS and PPR (RIP filter) use the "PPD" environment variable to 
    # make the PPD file name available (we set CUPS here preliminarily,
    # in the next step we check for PPR
    $spooler = 'cups';
}

# "PPR_VERSION": PPR
if (defined($ENV{'PPR_VERSION'})) {
    # We have PPR
    $spooler = 'ppr';
}

# "LPOPTS": Option settings for some LPD implementations (ex: GNUlpr)
if (defined($ENV{'LPOPTS'})) {
    my @lpopts = split(/,/, $ENV{'LPOPTS'});
    foreach $opt (@lpopts) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We have an LPD which accepts "-o" for options
    $spooler = 'gnulpr';
}



## Named command line options

# Save the options for logging
my $origoptions = join("','",@ARGV);

# Read the options
use Getopt::Long;
Getopt::Long::Configure("no_ignore_case");

#          # General
GetOptions("q"        => \$opt_q,         # Quiet
           "v"        => \$opt_v,         # Verbose
	   "debug"    => \$opt_debug,     # Debug mode
	   "p=s"      => \$opt_p,         # PPD file
	   "ppd=s"    => \$opt_ppd,       # PPD file
	   # LPD, LPRng, GNUlpr 
	   "lprng"    => \$opt_lprng,     # Were we called from LPRng?
	   "c"        => \$opt_c,         # (raw printing, not used)
	   "w=s"      => \$opt_w,         # (text width, not used)
	   "l=s"      => \$opt_l,         # (text length, not used)
	   "i=s"      => \$opt_i,         # (indent, not used)
	   "n=s"      => \$opt_n,         # (login, not used)
	   "h=s"      => \$opt_h,         # (host, not used)
	   "j=s"      => \$opt_j,         # Job title (with options stuffed
	                                  # in when LPD is the spooler)_
	   "z=s"      => \$opt_z,         # (not used)
	   "Z=s"      => \$opt_Z,         # Options when LPRng is the
	                                  # spooler
	   # PDQ
	   "pdq"      => \$opt_pdq,       # Were we called from PDQ?
	   # Spooler-less printing
	   "P=s"      => \$opt_P,         # Printer
	   "d=s"      => \$opr_d,         # Printer
	   "o=s"      => \@opt_o,         # Options
	   "J=s"      => \$opt_J,         # Job title
	   );

# Debug mode activated via command line
if ($opt_debug) {
    $debug = 1;
}

# Where to send debugging log output to
if ($debug) {
    # Grotesquely unsecure; use for debugging only
    open LOG, "> ${logfile}.log";
    $logh = *LOG;

    use IO::Handle;
    $logh->autoflush(1);
} elsif (($opt_q) && (!$opt_v)) {
    # Quiet mode, do not log
    close $logh;
    open LOG, "> /dev/null";
    $logh = *LOG;

    use IO::Handle;
    $logh->autoflush(1);
} else {
    # Default: log to STDERR
    $logh=*STDERR;
}

# PPD file name given via the command line
if ($opt_p) {
    $ppdfile = $opt_p;
}
if ($opt_ppd) {
    $ppdfile = $opt_ppd;
}

# Check for LPD/GNUlpr
if ((defined($opt_h)) || (defined($opt_n)) || (defined($opt_w)) ||
    (defined($opt_l)) || (defined($opt_i))) {
    # We have LPD or GNUlpr
    if (($spooler ne 'lpd') && ($spooler ne 'gnulpr')) {
	$spooler = 'lpd';
    }
}

# Check for LPRng
if ($opt_lprng) {
    # We have LPRng
    $spooler = 'lprng';
}

# LPRng delivers the option settings via the "-Z" argument
if (defined($opt_Z)) {
    my @lpopts = split(/,/, $opt_Z);
    foreach $opt (@lpopts) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We have LPRng
    $spooler = 'lprng';
}

# Job title and options for stock LPD
if (defined($opt_j)) {
    # An LPD
    $jobtitle = $opt_j;
    # Classic LPD hack
    $optstr .= "$opt_j ";
}

# Job title
if (defined($opt_J)) {
    # Spooler-less, perhaps also LPD
    $jobtitle = $opt_J;
}

# Options for spooler-less printing or PDQ
if ((defined(@opt_o)) && ($#opt_o >= 0)) {
    foreach $opt (@opt_o) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We print without spooler (we check for PDQ later)
    $spooler = 'direct';
}

# Printer for spooler-less printing or PDQ
if (!defined($opt_P) && (defined($opt_d))) {
    $opt_P = $opt_d;
}
if (defined($opt_P)) {
    $direct_printer = $opt_P;
    $printer = $direct_printer;
    # We print without spooler (we check for PDQ later)
    $spooler = 'direct';
}

# Were we called from a PDQ wrapper
if ($opt_pdq) {
    # We have PDQ
    $spooler = 'pdq';
}



## Command line arguments without name

# Load definitions for PPR error messages, check whether we run as
# PPR interface or as PPR RIP
if ($spooler eq 'ppr') {
    # Read interface.sh so we will know the correct exit codes and
    # also signal.sh for the signal codes
    my $deffound = 0; # Did we find one of the definition files
    my @definitions;
    for my $file (("lib/interface.sh", "lib/signal.sh")) {
	
	open FILE, "$file" || do {
	    print $logh "error opening $file.\n";
	    next;
	};
	
	$deffound = 1;
	while(my $line = <FILE>) {
	    # Translate the shell script to Perl
	    if (($line !~ m/^\s*$/) && ($line !~ m/^\s*\#/)) {
		$line =~ s/^\s*([^\#\s]*)/\$$1;/;
		push (@definitions, $line);
	    }
	}
	close FILE;
    }

    if ($deffound) {
	# Apply the definitions loaded from PPR
	eval join('',@definitions) || do {
	    print $logh "unable to evaluate definitions\n";
	    rip_die ("Error in definitions evaluation",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	};
    }

    # Check whether we run as a PPR interface (if not, we run as a PPR RIP)
    if (($ARGV[3] =~ /^\s*\d\d?\s*$/) &&
	($ARGV[5] =~ /^\s*\d\d?\s*$/) &&
	(($#ARGV == 10) || ($#ARGV == 9) || ($#ARGV == 7))) {
	# PPR calls interfaces with many command line parameters,
	# where the forth and the sixth is a small integer
	# number. In addition, we have 8 (PPR <= 1.31), 10
	# (PPR>=1.32), 11 (PPR >= 1.50) command line parameters.
	# We also check whether the current working directory is a
	# PPR directory.
	
	# Get all command line parameters
	$ppr_printer = $ARGV[0];
	$ppr_address = $ARGV[1];
	$ppr_options = $ARGV[2];
	$ppr_jobbreak = $ARGV[3];
	$ppr_feedback = $ARGV[4];
	$ppr_codes = $ARGV[5];
	$ppr_jobname = $ARGV[6];
	$ppr_routing = $ARGV[7];
	$ppr_for = $ARGV[8];
	$ppr_filetype = $ARGV[9];
	$ppr_filetoprint = $ARGV[10];
	
	# Common job parameters
	$printer = $ppr_printer;
	$jobtitle = $ppr_jobname;
	if ((!$jobtitle) && ($ppr_filetoprint)) {
	    $jobtitle = $ppr_filetoprint;
	}
	$optstr = "$ppr_options $ppr_routing";
	
	# Get the path of the PPD file from the queue configuration
	$ppdfile = `LANG=en_US; ppad show $ppr_printer | grep PPDFile`;
	$ppdfile =~ s/PPDFile:\s+//;
	if ($ppdfile !~ m!^/!) {
	    $ppdfile = "../../share/ppr/PPDFiles/$ppdfile";
	}
	chomp($ppdfile);
	
	# We have PPR and run as an interface
	$spooler = 'ppr_int';
    }
}

# CUPS
if ($spooler eq 'cups') {
    # Get all command line parameters
    $cups_jobid = $ARGV[0];
    $cups_user = $ARGV[1];
    $cups_jobtitle = $ARGV[2];
    $cups_copies = $ARGV[3];
    $cups_options = $ARGV[4];
    $cups_filename = $ARGV[5];

    # Common job parameters
    #$printer = $cups_printer;
    $jobtitle = $cups_jobtitle;
    $optstr = $cups_options;

    # Check for and handle inputfile vs stdin
    if ((defined($cups_filename)) && ($cups_filename) &&
	($cups_filename ne '-')) {
	# We get the input from a file
	@filelist = ($cups_filename);
	print $logh "Getting input from file $cups_filename\n";
    }
}

# LPD/LPRng/GNUlpr
if (($spooler eq 'lpd') ||
    ($spooler eq 'lprng') || 
    ($spooler eq 'gnulpr')) {

    # Get PPD file name as the last command line argument
    $ppdfile = $ARGV[$#ARGV];

}

# No spooler
if ($spooler eq 'direct') {
    # Which files do we want to print?
    @filelist = @ARGV;
}



## Additional spooler-specific preparations

# CUPS

if ($spooler eq 'cups') {

    # This piece of PostScript code (initial idea 2001 by Michael
    # Allerhand (michael.allerhand at ed dot ac dot uk, vastly
    # improved by Till Kamppeter in 2002) lets GhostScript output
    # the page accounting information which CUPS needs on standard
    # error.

    if ((defined(%conf)) && (defined $conf{ps_accounting})) {
	$ps_accounting = $conf{ps_accounting};
    }
    $accounting_prolog = $ps_accounting ? "[{
%% Code for writing CUPS accounting tags on standard error

/cupsPSLevel2 % Determine whether we can do PostScript level 2 or newer
    systemdict/languagelevel 2 copy
    known{get exec}{pop pop 1}ifelse 2 ge
def

/cupsGetNumCopies { % Read the number of Copies requested for the current
		    % page
    cupsPSLevel2
    {
	% PS Level 2+: Get number of copies from Page Device dictionary
	currentpagedevice /NumCopies get
    }
    {
	% PS Level 1: Number of copies not in Page Device dictionary
	null
    }
    ifelse
    % Check whether the number is defined, if it is \"null\" use #copies 
    % instead
    dup null eq {
	pop #copies
    }
    if
    % Check whether the number is defined now, if it is still \"null\" use 1
    % instead
    dup null eq {
	pop 1
    } if
} bind def

/cupsWrite { % write a string onto standard error
    (%stderr) (w) file
    exch writestring
} bind def

/cupsEndPage { % write page log info when we were invoked by \"showpage\"
	       % or \"copypage\" return \"true\" or \"false\" as we had no
	       % redefinition of \"EndPage\"

    2 ne % If the reason code is 0 or 1, we have finshed a page
	 % (we were invoked by \"showpage\" or \"copypage\"), 
         % write log info and exit with \"true\" to push out the page.
	 % In case of reason code 2, we are invoked during device
	 % deactivation (happens also at a \"setpagedevice\" call),
	 % here we should not log and return \"false\"
    {
	% write \"Page <# of page> <# of copies><LF>\" to stderr
	(PAGE: ) cupsWrite
	% we must add 1 here, the number on the stack is the number
	% of \"showpage\" already executed during this job
	1 add 40 string cvs cupsWrite
	% space
	( ) cupsWrite
	% get the number of copies for this page
	cupsGetNumCopies 40 string cvs cupsWrite
	% line feed
	(\\n) cupsWrite
	% page should be ejected
	true
    }
    {
	pop % ignore the number of pages already printed
	% do not eject paper
	false
    }
    ifelse
} bind def

<</EndPage{cupsEndPage}>>setpagedevice
} stopped cleartomark
" : "";

    # On which queue are we printing?
    # CUPS gives the PPD file the same name as the printer queue,
    # so we can get the queue name from the name of the PPD file.
    $ppdfile =~ m!^(.*/)([^/]+)\.ppd$!;
    $printer = $2;
}

# No spooler/PDQ

if (($spooler eq 'direct') || ($spooler eq 'pdq')) {

    # Path for personal Foomatic configuration
    my $user_default_path = "$ENV{'HOME'}/.foomatic";

    if (!$ppdfile) {
	if (!$printer) {
	    # No printer definition file selected, check whether we have a
	    # default printer defined.
	    for my $conf_file (("./.directconfig",
				"./directconfig",
				"./.config",
				"$user_default_path/directconfig",
				"$user_default_path/direct/.config",
				"$configpath/directconfig",
				"$configpath/direct/.config")) {
		if (open CONFIG, "< $conf_file") {
		    while (my $line = <CONFIG>) {
			chomp $line;
			if ($line =~ /^default\s*:\s*([^:\s]+)\s*$/) {
			    $printer = $1;
			    last;
			}
		    }
		    close CONFIG;
		}
		if (defined($printer)) {
		    last;
		}
	    }
	}

	# Neither in a config file nor on the command line a printer was
	# selected.
	if (!defined($opt_P)) {
	    rip_die("No printer definition (option \"-P <name>\") " .
		    "specified!", $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
	
	# Search the PPD file
	
	# Search also common spooler-specific locations, this way a printer
	# configured under a certain spooler can also be used without
	# spooler
	if (-r $printer) {
	    $ppdfile = $printer;
	} elsif (-r "${printer}.ppd") { # current dir
	    $ppdfile = "${printer}.ppd";
	} elsif (-r "$user_default_path/${printer}.ppd") { # user dir
	    $ppdfile = "$user_default_path/${printer}.ppd";
	} elsif (-r "$configpath/${printer}.ppd") { # system dir
	    $ppdfile = "$configpath/${printer}.ppd";
	} elsif (-r "/etc/cups/ppd/${printer}.ppd") { # CUPS config dir
	    $ppdfile = "/etc/cups/ppd/${printer}.ppd";
	} elsif (-r "/usr/local/etc/cups/ppd/${printer}.ppd") {
	    $ppdfile = "/usr/local/etc/cups/ppd/${printer}.ppd";
	} elsif (-r "/usr/share/ppr/PPDFiles/${printer}.ppd") { # PPR PPDs
	    $ppdfile = "/usr/share/ppr/PPDFiles/${printer}.ppd";
	} elsif (-r "/usr/local/share/ppr/PPDFiles/${printer}.ppd") {
	    $ppdfile = "/usr/local/share/ppr/PPDFiles/${printer}.ppd";
	} else {
	    rip_die ("There is no readable PPD file for the printer " .
		     "$printer, is it configured?",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
    }
}



## Files to be printed (can be more than one for spooler-less printing)

# Empty file list -> print STDIN
if ($#filelist < 0) {
    @filelist = ("<STDIN>");
}

# Check file list
my $file;
my $filecnt = 0;
for $file (@filelist) {
    if ($file ne "<STDIN>") {
	if ($file =~ /^-/) {
	    rip_die ("Invalid argument: $file",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	} elsif (! -r $file) {
	    print $logh "File $file does not exist/is not readable\n";
	    splice(@{$dat->{'args'}}, $filecnt, 1);
	    $filecnt --;
	}
    }
    $filecnt ++;
}



## When we print without spooler do not log onto STDERR unless the "-v"
## ('Verbose') is set or the debug mode is used
if (($spooler eq 'direct') && (!$opt_v) && (!$debug)) {
    close $logh;
    open LOG, "> /dev/null";
    $logh = *LOG;

    use IO::Handle;
    $logh->autoflush(1);
}



## Start logging also when no error occurs
print $logh "foomatic-rip version $ripversion running...\n";
# Print the command line only in debug mode, Mac OS X adds very many
# options so that CUPS cannot handle the output of the command line
# in its log files. If CUPS encounters a line with more than 1024 characters
# sent into its log files, it aborts the job with an error.
if (($debug) || ($spooler ne 'cups')) {
    print $logh "called with arguments: '", $origoptions, "'\n";
}


## PPD file

# Load the PPD file and build a data structure for the renderer's
# command line and the options
open PPD, "$ppdfile" || do {
    print $logh "error opening $ppdfile.\n";
    rip_die ("Unable to open PPD file $ppdfile",
	     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
};

print $logh "Parsing PPD file ...\n";

my $dat = {};              # data structure for the options
my $currentargument = "";  # We are currently reading this argument

# Parse the PPD file
while(<PPD>) {
    # foomatic-rip should also work with PPD file downloaded under Windows.
    undossify;
    # Parse keywords
    if (m!^\*NickName:\s*\"(.*)$!) {
	# "*NickName: <code>"
	my $line = $1;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $cmd = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$cmd .= substr($line, 0, -2);
	    } else {
		# line ends here
		$cmd .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$cmd .= $1;
	$model = unhtmlify($cmd);
    } elsif (m!^\*FoomaticRIPPostPipe:\s*\"(.*)$!) {
	# "*FoomaticRIPPostPipe: <code>"
	my $line = $1;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $cmd = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$cmd .= substr($line, 0, -2);
	    } else {
		# line ends here
		$cmd .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$cmd .= $1;
	$postpipe = unhtmlify($cmd);
    } elsif (m!^\*FoomaticRIPCommandLine:\s*\"(.*)$!) {
	# "*FoomaticRIPCommandLine: <code>"
	my $line = $1;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $cmd = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$cmd .= substr($line, 0, -2);
	    } else {
		# line ends here
		$cmd .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$cmd .= $1;
	$dat->{'cmd'} = unhtmlify($cmd);
    } elsif (m!^\*CustomPageSize\s+True:\s*\"(.*)$!) {
	# "*CustomPageSize True: <code>"
	my $setting = "Custom";
	my $translation = "Custom Size";
	my $line = $1;
	# Make sure that the argument is in the data structure
	checkarg ($dat, "PageSize");
	checkarg ($dat, "PageRegion");
	# Make sure that the setting is in the data structure
	checksetting ($dat, "PageSize", $setting);
	checksetting ($dat, "PageRegion", $setting);
	$dat->{'args_byname'}{'PageSize'}{'vals_byname'}{$setting}{'comment'} = $translation;
	$dat->{'args_byname'}{'PageRegion'}{'vals_byname'}{$setting}{'comment'} = $translation;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($code !~ m!^%% FoomaticRIPOptionSetting!m) {
	    $dat->{'args_byname'}{'PageSize'}{'vals_byname'}{$setting}{'driverval'} = $code;
	    $dat->{'args_byname'}{'PageRegion'}{'vals_byname'}{$setting}{'driverval'} = $code;
	}
    } elsif (m!^\*(JCL|)OpenUI\s+\*([^:]+):\s*(\S+)\s*$!) {
	# "*[JCL]OpenUI *<option>[/<translation>]: <type>"
	my $argnametrans = $2;
	my $argtype = $3;
	my $argname;
	my $translation = "";
	if ($argnametrans =~ m!^([^:/\s]+)/([^:]*)$!) {
	    $argname = $1;
	    $translation = $2;
	} else {
	    $argname = $argnametrans;
	}
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'comment'} = $translation;
	# Set the argument type only if not defined yet, a
	# definition in "*FoomaticRIPOption" has priority
	if (!defined($dat->{'args_byname'}{$argname}{'type'})) {
	    if ($argtype eq "PickOne") {
		$dat->{'args_byname'}{$argname}{'type'} = 'enum';
	    } elsif ($argtype eq "PickMany") {
		$dat->{'args_byname'}{$argname}{'type'} = 'pickmany';
	    } elsif ($argtype eq "Boolean") {
		$dat->{'args_byname'}{$argname}{'type'} = 'bool';
	    }
	}
	# Mark in which argument we are currently, so that we can find
	# the entries for the choices
	$currentargument = $argname;
    } elsif (m!^\*(JCL|)CloseUI:\s+\*([^:/\s]+)\s*$!) {
	# "*[JCL]CloseUI *<option>"
	my $argname = $2;
	# Unmark the current argument to do not mis-interpret any keywords
	# as choices
	$currentargument = "";
    } elsif ((m!^\*FoomaticRIPOption ([^/:\s]+):\s*(\S+)\s+(\S+)\s+(\S)\s*$!) ||
	     (m!^\*FoomaticRIPOption ([^/:\s]+):\s*(\S+)\s+(\S+)\s+(\S)\s+(\S+)\s*$!)){
	# "*FoomaticRIPOption <option>: <type> <style> <spot> [<order>]"
	# <order> only used for 1-choice enum options
	my $argname = $1;
	my $argtype = $2;
	my $argstyle = $3;
	my $spot = $4;
	my $order = $5;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'type'} = $argtype;
	if ($argstyle eq "PS") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'G';
	} elsif ($argstyle eq "CmdLine") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'C';
	} elsif ($argstyle eq "JCL") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'J';
	    $dat->{'jcl'} = 1;
	} elsif ($argstyle eq "Collective") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'X';
	}
	$dat->{'args_byname'}{$argname}{'spot'} = $spot;
	# $order only defined here for 1-choice enum options
	if ($order) {
	    $dat->{'args_byname'}{$argname}{'order'} = $order;
	}
    } elsif (m!^\*FoomaticRIPOptionPrototype\s+([^/:\s]+):\s*\"(.*)$!) {
	# "*FoomaticRIPOptionPrototype <option>: <code>"
	# Used for numerical options only
	my $argname = $1;
	my $line = $2;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the value
	# Code string can have multiple lines, read all of them
	my $proto = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$proto .= substr($line, 0, -2);
	    } else {
		# line ends here
		$proto .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$proto .= $1;
	$dat->{'args_byname'}{$argname}{'proto'} = unhtmlify($proto);
    } elsif (m!^\*FoomaticRIPOptionRange\s+([^/:\s]+):\s*(\S+)\s+(\S+)\s*$!) {
	# "*FoomaticRIPOptionRange <option>: <min> <max>"
	# Used for numerical options only
	my $argname = $1;
	my $min = $2;
	my $max = $3;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'min'} = $min;
	$dat->{'args_byname'}{$argname}{'max'} = $max;
    } elsif (m!^\*OrderDependency:\s*(\S+)\s+(\S+)\s+\*([^:/\s]+)\s*$!) {
	# "*OrderDependency: <order> <section> *<option>"
	my $order = $1;
	my $section = $2;
	my $argname = $3;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'order'} = $order;
	$dat->{'args_byname'}{$argname}{'section'} = $section;
    } elsif (m!^\*Default([^/:\s]+):\s*([^/:\s]+)\s*$!) {
	# "*Default<option>: <value>"
	my $argname = $1;
	my $default = $2;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the value
	$dat->{'args_byname'}{$argname}{'default'} = $default;
    } elsif (m!^\*$currentargument\s+([^:]+):\s*\"(.*)$!) {
	# "*<option> <choice>[/<translation>]: <code>"
	my $settingtrans = $1;
	my $line = $2;
	my $translation = "";
	if ($settingtrans =~ m!^([^:/\s]+)/([^:]*)$!) {
	    $setting = $1;
	    $translation = $2;
	} else {
	    $setting = $settingtrans;
	}
	# Make sure that the argument is in the data structure
	checkarg ($dat, $currentargument);
	# Make sure that the setting is in the data structure (enum options)
	my $bool =
	    ($dat->{'args_byname'}{$currentargument}{'type'} eq 'bool');
	if ($bool) {
	    if (lc($setting) eq "true") {
		if (!$dat->{'args_byname'}{$currentargument}{'comment'}) {
		    $dat->{'args_byname'}{$currentargument}{'comment'} =
			$translation;
		}
		$dat->{'args_byname'}{$currentargument}{'comment_true'} =
		    $translation;
	    } else {
		$dat->{'args_byname'}{$currentargument}{'comment_false'} =
		    $translation;
	    }
	} else {
	    checksetting ($dat, $currentargument, $setting);
	    $dat->{'args_byname'}{$currentargument}{'vals_byname'}{$setting}{'comment'} = $translation;
	}
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($code !~ m!^%% FoomaticRIPOptionSetting!) {
	    if ($bool) {
		if (lc($setting) eq "true") {
		    $dat->{'args_byname'}{$currentargument}{'proto'} = $code;
		} else {
		    $dat->{'args_byname'}{$currentargument}{'protof'} = $code;
		}
	    } else {
		$dat->{'args_byname'}{$currentargument}{'vals_byname'}{$setting}{'driverval'} = $code;
	    }
	}
    } elsif ((m!^\*FoomaticRIPOptionSetting\s+([^/:=\s]+)=([^/:=\s]+):\s*\"(.*)$!) ||
	     (m!^\*FoomaticRIPOptionSetting\s+([^/:=\s]+):\s*\"(.*)$!)) {
	# "*FoomaticRIPOptionSetting <option>[=<choice>]: <code>"
	# For boolean options <choice> is not given
	my $argname = $1;
	my $setting = $2;
	my $line = $3;
	my $bool = 0;
	if (!$line) {
	    $line = $setting;
	    $bool = 1;
	}
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Make sure that the setting is in the data structure (enum options)
	if (!$bool) {
	    checksetting ($dat, $argname, $setting);
	    # Make sure that this argument has a default setting, even if 
	    # none is defined in this PPD file
	    if (!$dat->{'args_byname'}{$argname}{'default'}) {
		$dat->{'args_byname'}{$argname}{'default'} = $setting;
	    }
	}
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($bool) {
	    $dat->{'args_byname'}{$argname}{'proto'} = unhtmlify($code);
	} else {
	    $dat->{'args_byname'}{$argname}{'vals_byname'}{$setting}{'driverval'} = unhtmlify($code);
	}
    } elsif (m!^\*JCL(Begin|ToPSInterpreter|End):\s*\"(.*)$!) {
	# "*JCL(Begin|ToPSInterpreter|End): <code>"
	# The printer supports PJL/JCL when there is such a line 
	$dat->{'jcl'} = 1;
	$item = $1;
	$line = $2;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($item eq 'Begin') {
	    $jclbegin = unhexify($code);
	} elsif ($item eq 'ToPSInterpreter') {
	    $jcltointerpreter = unhexify($code);
	} elsif ($item eq 'End') {
	    $jclend = unhexify($code);
	}
    }
}
close PPD;



## We do not need to parse the PostScript job when we don't have
## any options. If we have options, we must check whether the
## default settings from the PPD file are valid and correct them
## if nexessary.

my $dontparse = 0;
if ((!defined(@{$dat->{'args'}})) ||
    ($#{$dat->{'args'}} < 0)) {
    # We don't have any options, so we do not need to parse the
    # PostScript data
    $dontparse = 1;
} else {
    # Let the default value of a boolean option being 0 or 1 instead of
    # "True" or "False", range-check the defaults of all options and
    # issue warnings if the values are not valid
    checkoptions($dat, 'default');
}

# Was the RIP command line defined in the PPD file? If not, we assume a
# PostScript printer and do not render/translate the input data
if (!defined($dat->{'cmd'})) {
    $dat->{'cmd'} = "cat%A%B%C%D%E%F%G%H%I%J%K%L%M%Z";
}



## Summary for debugging
print $logh "\nParameter Summary\n";
print $logh "-----------------\n\n";
print $logh "Spooler: $spooler\n";
print $logh "Printer: $printer\n";
print $logh "PPD file: $ppdfile\n";
print $logh "Printer model: $model\n";
# Print the options string only in debug mode, Mac OS X adds very many
# options so that CUPS cannot handle the output of the option string
# in its log files. If CUPS encounters a line with more than 1024 characters
# sent into its log files, it aborts the job with an error.
if (($debug) || ($spooler ne 'cups')) {
    print $logh "Options: $optstr\n";
}
print $logh "Job title: $jobtitle\n";
print $logh "File(s) to be printed:\n@filelist\n\n";



## Parse options from command line ($optstr)

# Before we start, save the defaults for printing documentation pages

copyoptions($dat, 'default', 'userval');


# The options are "foo='bar nut'", "foo", "nofoo", "'bar nut'", or
# "foo:'bar nut'" (when GPR was used) all with spaces between...

my @opts;

# Variable for PPR's backend interface name (parallel, tcpip, atalk, ...)

$backend = "";

# Array to collect unknown options so that they can get passed to the
# backend interface of PPR. For other spoolers we ignore them.

@backendoptions = ();

# "foo='bar nut'"
while ($optstr =~ s!(\w+=[\'\"].+?[\'\"]) ?!!) {
    push (@opts, $1);
}

# "foo:'bar nut'" (GPR separates option and setting with a colon ":")
while ($optstr =~ s!(\w+:[\'\"].+?[\'\"]) ?!!) {
    push (@opts, $1);
}

# "'bar nut'", "'foo=bar nut'", "'foo:bar nut'"
while ($optstr =~ s!([\'\"].+?[\'\"]) ?!!) {
    my $opt = $1;
    $opt =~ s/[\'\"]//g; # Make only sure that we didn't quote
                         # the option for a second time when we read
                         # rge options from the command line or
                         # environment variable
    push (@opts, $opt);
    
}

# "foo", "nofoo"
push(@opts, split(/ /,$optstr));

# Now actually process those pesky options...

for (@opts) {
    print $logh "Pondering option '$_'\n";

    if ((lc($_) =~ /^\s*docs\s*$/) ||
	(lc($_) =~ /^\s*docs\s*=\s*true\s*$/)) {
	# The second one is necessary becuase CUPS 1.1.15 or newer sees
	# "docs" as boolean option and modifies it to "docs=true"
        $do_docs = 1;
	next;
    }

    my $arg;
    if ((m!([^=]+)=\'?(.+)\'?!) || (m!([^=:]+):\'?(.+)\'?!)) {
        my ($aname, $avalue) = ($1, $2);

	# At first look for the "backend" option to determine the PPR
	# backend to use
	if (($aname =~ m!^backend$!i) && ($spooler eq 'ppr_int')) {
	    # Backend interface name
	    $backend = $avalue;
        } elsif ($aname =~ m!^media$!i) {

	    # Standard arguments?
	    # media=x,y,z
	    # sides=one|two-sided-long|short-edge

	    # Rummage around in the media= option for known media, source, 
	    # etc types.
	    # We ought to do something sensible to make the common manual
	    # boolean option work when specified as a media= tray thing.
	    # 
	    # Note that this fails miserably when the option value is in
	    # fact a number; they all look alike.  It's unclear how many
	    # drivers do that.  We may have to standardize the verbose
	    # names to make them work as selections, too.

            my @values = split(',',$avalue);
            for (@values) {
                if ($dat->{'args_byname'}{'PageSize'} and
                    $val=valbyname($dat->{'args_byname'}{'PageSize'},$_)) {
                    $dat->{'args_byname'}{'PageSize'}{'userval'} = 
                        $val->{'value'};
		    # Keep "PageRegion" in sync
		    if ($dat->{'args_byname'}{'PageRegion'} and
			$val=valbyname($dat->{'args_byname'}{'PageRegion'},
				       $_)) {
			$dat->{'args_byname'}{'PageRegion'}{'userval'} = 
			    $val->{'value'};
		    }
                } elsif ($dat->{'args_byname'}{'PageSize'} 
			 and /^Custom/) {
		    $dat->{'args_byname'}{'PageSize'}{'userval'} = $_;
		    # Keep "PageRegion" in sync
		    if ($dat->{'args_byname'}{'PageRegion'}) {
			$dat->{'args_byname'}{'PageRegion'}{'userval'} = 
			    $_;
		    }
                } elsif ($dat->{'args_byname'}{'MediaType'} and
                         $val=valbyname($dat->{'args_byname'}{'MediaType'},
					$_)) {
                    $dat->{'args_byname'}{'MediaType'}{'userval'} =
                        $val->{'value'};
                } elsif ($dat->{'args_byname'}{'InputSlot'} and
                         $val=valbyname($dat->{'args_byname'}{'InputSlot'},
					$_)) {
                    $dat->{'args_byname'}{'InputSlot'}{'userval'} = 
                        $val->{'value'};
                } elsif (lc($_) eq 'manualfeed') {
                    # Special case for our typical boolean manual
                    # feeder option if we didn't match an InputSlot above
                    if (defined($dat->{'args_byname'}{'ManualFeed'})) {
                        $dat->{'args_byname'}{'ManualFeed'}{'userval'} = 1;
                    }
                } else {
                    print $logh "Unknown \"media\" component: \"$_\".\n";
                }
            }
        } elsif ($aname =~ m!^sides$!i) {
            # Handle the standard duplex option, mostly
            if ($avalue =~ m!^two-sided!i) {
                if (defined($dat->{'args_byname'}{'Duplex'})) {
		    # We set "Duplex" to '1' here, the real argument setting
		    # will be done later
                    $dat->{'args_byname'}{'Duplex'}{'userval'} = '1';
		    # Check the binding: "long edge" or "short edge"
		    if ($avalue =~ m!long-edge!i) {
			if (defined($dat->{'args_byname'}{'Binding'})) {
			    $dat->{'args_byname'}{'Binding'}{'userval'} =
      $dat->{'args_byname'}{'Binding'}{'vals_byname'}{'LongEdge'}{'value'};
			} else {
			    $dat->{'args_byname'}{'Duplex'}{'userval'} = 
				'LongEdge';
			}
		    } elsif ($avalue =~ m!short-edge!i) {
			if (defined($dat->{'args_byname'}{'Binding'})) {
			    $dat->{'args_byname'}{'Binding'}{'userval'} =
      $dat->{'args_byname'}{'Binding'}{'vals_byname'}{'ShortEdge'}{'value'};
			} else {
			    $dat->{'args_byname'}{'Duplex'}{'userval'} = 
				'ShortEdge';
			}
		    }
                }
            } elsif ($avalue =~ m!^one-sided!i) {
                if (defined($dat->{'args_byname'}{'Duplex'})) {
		    # We set "Duplex" to '0' here, the real argument setting
		    # will be done later
                    $dat->{'args_byname'}{'Duplex'}{'userval'} = '0';
                }
            }

            # We should handle the other half of this option - the
            # BindEdge bit.  Also, are there well-known ipp/cups
            # options for Collate and StapleLocation?  These may be
            # here...

        } else {
            # Various non-standard printer-specific options
            if ($arg=argbyname($aname)) {
		if (defined(my $newvalue =
		    checkoptionvalue($dat, $aname, $avalue, 0))) {
		    # If the choice is valid, use it, otherwise
		    # ignore it.
		    $arg->{'userval'} = $newvalue;
		    # If this argument is PageSize or PageRegion,
		    # also set the other
		    syncpagesize($dat, $aname, $avalue, 'userval');
		} else {
		    # Invalid choice, make log entry
		    print $logh "Invalid choice $aname=$avalue.\n";
		}
            } elsif ($spooler eq 'ppr_int') {
                # Unknown option, pass it to PPR's backend interface
		push (@backendoptions, "$aname=$avalue");
            } else {
		# Unknown option, make log entry
		print $logh "Unknown option $aname=$avalue.\n";
	    }
        }
    } elsif (m!^([\d\.]+)x([\d\.]+)([A-Za-z]*)$!) {
	my ($w, $h, $u) = ($1, $2, $3);
	# Custom paper size
	if (($w != 0) && ($h != 0) &&
	    ($arg=argbyname("PageSize")) &&
	    (defined($arg->{'vals_byname'}{'Custom'}))) {
            $arg->{'userval'} = "Custom.${w}x${h}${u}";
	    # Keep "PageRegion" in sync
	    if ($dat->{'args_byname'}{'PageRegion'}) {
		$dat->{'args_byname'}{'PageRegion'}{'userval'} = 
		    $arg->{'userval'};
	    }
	}
    } elsif ((m!^\s*no(.+)\s*$!i) and ($arg=argbyname($1))) {
        # standard bool args:
        # landscape; what to do here?
        # duplex; we should just handle this one OK now?
	$arg->{'userval'} = 0;
    } elsif (m!^\s*(.+)\s*$!) {
        if ($arg=argbyname($1)) {
            $arg->{'userval'} = 1;
        } else {
            print $logh "Unknown boolean option \"$1\".\n";
        }
    }
}



## Set the $postpipe

# $postpipe when running as a PPR RIP
if ($spooler eq 'ppr') {
    # Strange, the PPR RIP must send to /dev/fd/3 instead of to STDOUT
    $postpipe = "| cat - >&3";
}

# Set up PPR backend (if we run as a PPR interface).
if ($spooler eq 'ppr_int') {

    # Is the chosen backend installed and executable
    if (!-x "interfaces/$backend") {
	print $logh "The backend interface `$pwd`/interfaces/$backend " .
	    "does not exist/is not executable!\n";
	rip_die ("The backend interface `$pwd`/interfaces/$backend " .
		 "does not exist/is not executable!",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }

    # foomatic-rip cannot use foomatic-rip as backend
    if ($backend eq "foomatic-rip") {
	print $logh "\"foomatic-rip\" cannot use itself as backend " .
	    "interface!\n";
	ppr_die ($ppr_printer,
		 "\"foomatic-rip\" cannot use itself as backend interface!",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }

    # Put the backend interface into the $postpipe
    $postpipe = "| ( interfaces/$backend \"$ppr_printer\" ".
	"\"$ppr_address\" \"" . join(" ",@backendoptions) .
	"\" \"$ppr_jobbreak\" \"$ppr_feedback\" " .
	"\"$ppr_codes\" \"$ppr_jobname\" \"$ppr_routing\" " .
	"\"$ppr_for\" \"\" )";

}

# CUPS has its own backends, it does not need a $postpipe
if ($spooler eq 'cups') {
    # No $postpipe for CUPS, even if one is defined in the PPD file
    $postpipe = "";
}

if ($postpipe) {
    print $logh "\nOutput will be redirected to:\n$postpipe\n\n";
}



## Print documentation page when asked for
$docgeneratorpid = 0;
if ($do_docs) {
    # Don't print the supplied files, STDIN will be redirected to the
    # documentation page generator
    @filelist = ("<STDIN>");
    # Start the documentation page generator
    ($docgeneratorhandle, $docgeneratorpid) =
	getdocgeneratorhandle($dat);
    if ($retval != $EXIT_PRINTED) {
	rip_die ("Error opening documentation page generator",
		 $retval);
    }
    # Read the further data from the documentation page generator and
    # not from STDIN
    if (!close STDIN) {
	rip_die ("Couldn't close STDIN",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
    if (!open (STDIN, "<&$docgeneratorhandle")) {
	rip_die ("Couldn't dup \$docgeneratorhandle",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
}



## In debug mode save the data supposed to be fed into the
## renderer also into a file, reset the file here

if ($debug) {
    system("> ${logfile}.ps");
}


	    
## From here on we have to repeat all the rest of the program for
## every file to print

for $file (@filelist) {

    print $logh "
================================================

File: $file

================================================

";



    ## If we do not print standard input, open the file to print
    if ($file ne "<STDIN>") {
	if (! -r $file) {
	    print $logh "File $file missing or not readable, skipping.\n";
	    next;
	}
        close STDIN;
        open STDIN, "< $file" || do {
	    print $logh "Cannot open $file, skipping.\n";
	    next;
	}
    }



    ## First, for arguments with a default, stick the default in as
    ## the initial value for the "header" option set, this option set
    ## consists of the PPD defaults, the options specified on the
    ## command line, and the options set in the header part of the
    ## PostScript file (all before the first page begins).

    copyoptions($dat, 'userval', 'header');



    ## Next, examine the PostScript job for traces of command-line and
    ## JCL options. PPD-aware applications and spoolers stuff option
    ## settings directly into the file, they do not necessarily send
    ## PPD options by the command line. Also stuff in PostScript code
    ## to apply option settings given by the command line and to set
    ## the defaults given in the PPD file.

    # Examination strategy: read lines from STDIN until the first
    # %%Page: comment appears and save them as @psheader. This is the
    # page-independent header part of the PostScript file. The
    # PostScript interpreter (renderer) must execute this part once
    # before rendering any assortment of pages. Then pages can be
    # printed in any arbitrary selection or order. All option
    # settings we find here will be collected in the default option
    # set for the RIP command line.

    # Now the pages will be read and sent to the renderer, one after
    # the other. Every page is read into memory until the
    # %%EndPageSetup comment appears (or a certain amount of lines was
    # read). So we can get option settings only valid for this
    # page. If we have such settings we set them in the modified
    # command set for this page.

    # If the renderer is not running yet (first page) we start it with
    # the command line built from the current modified command set and
    # send the first page to it, in the end we leave the renderer
    # running and keep input and output pipes open, so that it can
    # accept further pages. If the renderer is still running from
    # the previous page and the current modified command set is the
    # same as the one for the previous page, we send the page. If
    # the command set is different, we close the renderer, re-start
    # it with the command line built from the new modified command
    # set, send the header again, and then the page.

    # After the last page the trailer (%%Trailer) is sent.

    # The output pipe of this program stays open all the time so that
    # the spooler does not assume that the job has finished when the
    # renderer is re-started.

    # Non DSC-conforming documents will be read until a certain line
    # number is reached. Command line or JCL options inserted later
    # will be ignored.

    # If options are implemented by PostScript code supposed to be
    # stuffed into the job's PostScript data we stuff the code for all
    # these options into our job data, So all default settings made in
    # the PPD file (the user can have edited the PPD file to change
    # them) are taken care of and command line options get also
    # applied. To give priority to settings made by applications we
    # insert the options's code in the beginnings of their respective
    # sections, so that sommething, which is already inserted, gets
    # executed after our code. Missing sections are automatically
    # created. In non-DSC-conforming files we insert the option code
    # in the beginning of the file. This is the same policy as used by
    # the "pstops" filter of CUPS.

    # If CUPS is the spooler, the option settings were already
    # inserted by the "pstops" filter, so we don't insert them
    # again. The only thing we do is correcting settings of numerical
    # options when they were set to a value not available as choice in
    # the PPD file, As "pstops" does not support "real" numerical
    # options, it sees these settings as an invalid choice and stays
    # with the default setting. In this case we correct the setting in
    # the first occurence of the option's code, as this one is the one
    # added by CUPS, later occurences come from applications and
    # should not be touched.

    # If the input is not PostScript (if there is no "%!" after
    # $maxlinestopsstart lines) a file conversion filter will
    # automatically be applied to the incoming data, so that we will
    # process the resulting PostScript here. This way we have always
    # PostScript data here and so we can apply the printer/driver
    # features described in the PPD file.

    # Supported file conversion filters are "a2ps", "enscript",
    # "mpage", and spooler-specific filters. All filters convert
    # plain text to PostScript, "a2ps" also other formats. The
    # conversion filter is always used when one prints the
    # documentation pages, as they are created as plain text,
    # when CUPS is the spooler "pstops" is executed after the
    # filter so that the default option settings from the PPD file
    # and CUPS-specific options as N-up get applied. On regular
    # printouts one gets always PostScript when CUPS or PPR is
    # the spooler, so the filter is only used for regular
    # printouts under LPD, LPRng, GNUlpr or without spooler.

    print $logh "Reading PostScript input ...\n";
    my $maxlines = 1000;            # Maximum number of lines to be read
                                    # when the documenent is not
                                    # DSC-conforming. "$maxlines = 0"
                                    # means that all will be read
                                    # and examined. If it is
                                    # discovered that the input file
                                    # is DSC-conforming, this will
                                    # be set to 0.

    my $maxlinestopsstart = 200;    # That many lines are allowed until the
                                    # "%!" indicating PS comes. These
                                    # additional lines in the
                                    # beginning are usually JCL
                                    # commands. The lines will be
                                    # ignored by our parsing but
                                    # passed through.

    my $maxlinesforpageoptions=200; # Unfortunately, CUPS does not bracket
                                    # "PageSetup" option with
                                    # "%%BeginPageSetup" and
                                    # "%%EndPageSetup", so the options
                                    # can simply stand after the
                                    # page header and before the
                                    # page code, without special
                                    # marking. So buffer this amount
                                    # of lines before printing the
                                    # page to check for options.

    my $maxnondsclinesinheader=1000; # If there is a block of more lines
                                    # than this in the document
                                    # header which is not in the
                                    # "%%BeginProlog...%%EndProlog"
                                    # or
                                    # "%%BeginSetup...%%EndSetup"
                                    # sections, the document is not
                                    # considered as DSC-conforming
                                    # and the rest gets passed
                                    # through to the renderer without
                                    # further parsing for options.

    my $nondsclines = 0;            # Amount of lines found which are not in
                                    # a section (see 
                                    # $maxnondsclinesinheader).

    my $nonpslines = 0;             # lines before "%!" found yet.

    my $more_stuff = 1;             # there is more stuff in stdin.

    my $linect = 0;                 # how many lines have we examined?

    my $onelinebefore = "";         # The line before the current line
                                    # (Non-DSC comments are ignored)

    my $twolinesbefore = "";        # The line two lines before the current 
                                    # line (Non-DSC comments are ignored)

    my @psheader = ();              # The header of the PostScript file, 
                                    # to be sent after each start of the
                                    # renderer

    my @psfifo = ();                # The input FIFO, data which we have
                                    # pulled from stdin for examination,
                                    # but not sent to the renderer yet.

    my $passthru = 0;               # 0: write data into @psfifo; 1: pass
                                    # data directly to the renderer

    my $isdscjob = 0;               # Is the job DSC conforming

    my $inheader = 1;               # Are we still in the header, before
                                    # first "%%Page:" comment?

    my $optionset = 'header';       # Where do the option settings, which 
                                    # we have found, go?

    my $nestinglevel = 0;           # Are we in the main document (0) or
                                    # in an embedded document bracketed by
                                    # "%%BeginDocument" and "%%EndDocument"
                                    # (>0) We do not parse the PostScript
                                    # in an embedded document.

    my $inpageheader = 0;           # Are we in the header of a page,
                                    # between "%%BeginPageSetup" and
                                    # "%%EndPageSetup" (1) or not (0).

    my $lastpassthru = 0;           # State of $passthru in previous line
                                    # (to allow debug output when $passthru
                                    # switches.

    my $ignorepageheader = 0;       # Will be set to 1 as soon as active 
                                    # code (not between "%%BeginPageSetup" 
                                    # and "%%EndPageSetup") appears after a
                                    # "%%Page:" comment. In this case
                                    # "%%BeginPageSetup" and
                                    # "%%EndPageSetup" is not allowed any 
                                    # more on this page and will be ignored.
                                    # Will be set to 0 when a new "%%Page:" 
                                    # comment appears.

    my $printprevpage = 0;          # We set this when encountering
                                    # "%%Page:" and the previous page is not
                                    # printed yet. Then it will printed and 
                                    # the new page will be prepared in the
                                    # next run of the loop (we don't read a
                                    # new line and don't increase the
                                    # $linect then).

    my $rendererhandle;             # File handle to the renderer process\

    my $rendererpid = 0;            # PID of the renderer process

    my $prologfound = 0;            # Did we find the
                                    # "%%BeginProlog...%%EndProlog" section?

    my $setupfound = 0;             # Did we find the
                                    # "%%BeginSetup...%%EndSetup" section?

    my $inprolog = 0;               # We are between "%%BeginProlog" and
                                    # "%%EndProlog".

    my $insetup = 0;                # We are between "%%BeginSetup" and
                                    # "%%EndSetup".

    my $infeature = 0;              # We are between "%%BeginFeature" and
                                    # "%%EndFeature".

    my $nondsclines = 0;            # Number of subsequent lines found which
                                    # are at a non-DSC-conforming place,
                                    # between the sections of the header.

    my $optionreplaced = 0;         # Will be set to 1 when we are in an
                                    # option ("%%BeginFeature...
                                    # %%EndFeature") which we have replaced.

    $jobhasjcl = 0;                 # When the job does not start with
                                    # PostScript directly, but is a
                                    # PostScript job, we set this to 1
                                    # to avoid adding the JCL options
                                    # for the second time.

    my $insertoptions = 1;          # If we find out that a file with
                                    # a DSC magic string
                                    # ("%!PS-Adobe-") is not really
                                    # DSC-conforming, we insert the
                                    # options directly after the line
                                    # with the magic string. We use
                                    # this variable to store the
                                    # number of the line with the
                                    # magic string.

    if ($dontparse) {
	# We do not parse the PostScript to find Foomatic options, we check
	# only whether we have PostScript.
	$maxlines = 1;
    }

    my $line;                       # Line to be read from stdin
    do {
	my $ignoreline = 0;         # Comment line to be ignored when
	                            # determining the last active line 
	                            # and the one before the last

	if (($printprevpage) || ($line=<STDIN>)) {

	    if ($linect == $nonpslines) {
		# In the beginning should be the postscript leader,
                # sometimes after some JCL commands
		if ($line !~ m/^.?%!/) { # There can be a Windows control 
		                         # character before "%!"
		    $nonpslines ++;
		    if ($maxlines == $nonpslines) {
			$maxlines ++;
		    }
		    $jobhasjcl = 1;
		    if ($nonpslines > $maxlinestopsstart) {
			# This is not a PostScript job, we must convert it
			print $logh "\nJob does not start with \"%!\", " . 
			     "is it PostScript?\n" .
			     "Starting file converter\n";
			# Reset all variables but conserve the data which
			# we have already read.
			$jobhasjcl = 0;
			$linect =  0;
			$nonpslines = 1; # Take into account that the line
			                 # of this run of the loop will be
			                 # put into @psheader, so the
			                 # first line read by the filr
			                 # converter is already the second
			                 # line.
			$maxlines = 1001;
			$onelinebefore = "";
			$twolinesbefore = "";
			my $alreadyread = join('', @psheader, @psfifo) . 
			    $line;
			$line = "";
			@psheader = ();
			@psfifo = ();
			# Start the file conversion filter
			if (!$fileconverterpid) {
			    ($fileconverterhandle, $fileconverterpid) =
				getfileconverterhandle
				($dat, $alreadyread);
			    if ($retval != $EXIT_PRINTED) {
				rip_die ("Error opening file converter",
					 $retval);
			    }
			} else {
			    rip_die("File conversion filter probably " .
				    "crashed",
				    $EXIT_JOBERR);
			}
			# Read the further data from the file converter and
			# not from STDIN
			if (!close STDIN) {
			    rip_die ("Couldn't close STDIN",
				     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
			}
			if (!open (STDIN, "<&$fileconverterhandle")) {
			    rip_die ("Couldn't dup \$fileconverterhandle",
				     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
			}
		    }
		} else {
		    # Do we have a DSC-conforming document?
		    if (($line =~ m/^.?%!PS-Adobe-/) && 
			($line !~ m/EPSF/)) {
			# Do not stop parsing the document
			if (!$dontparse) {
			    $maxlines = 0;
			    $isdscjob = 1;
			    $insertoptions = $linect + 1;
			    # We have written into @psfifo before,
			    # now we continue in @psheader and move
			    # over the data which is already in @psfifo
			    push (@psheader, @psfifo);
			    @psfifo = ();
			}
			print $logh 
			    "--> This document is DSC-conforming!\n";
		    } else {
			# Job is not DSC-conforming, stick in all PostScript
			# option settings in the beginning
			$line .= makeprologsection($dat, $optionset, 1);
			$line .= makesetupsection($dat, $optionset, 1);
			$line .= makepagesetupsection($dat, $optionset, 1);
			$prologfound = 1;
			$setupfound = 1;
			$pagesetupfound = 1;
		    }
		}
	    } else {
		if ($line =~ m/^\s*\%\%BeginDocument[: ]/) {
		    # Beginning of an embedded document
		    # Note that Adobe Acrobat has a bug and so uses
		    # "%%BeginDocument " instead of "%%BeginDocument:"
		    $nestinglevel ++;
		    print $logh "Embedded document, " .
			"nesting level now: $nestinglevel\n";
		} elsif (($line =~ m/^\s*\%\%EndDocument/) &&
			 ($nestinglevel > 0)) {
		    # End of an embedded document
		    $nestinglevel --;
		    print $logh "End of Embedded document, " .
			"nesting level now: $nestinglevel\n";
		} elsif (($line =~ m/^\%\%BeginProlog/) &&
			 ($nestinglevel == 0)) {
		    # Note: Below is another place where a "Prolog"
		    # section start will be considered. There we assume
		    # start of the "Prolog" if the job is DSC-Conformimg,
		    # but an arbitrary comment starting with "%%Begin", but
		    # not a comment explicitly treated here, is found. This
		    # is done because many "dvips" (TeX/LaTeX) files miss
		    # the "%%BeginProlog" comment.
		    # Beginning of Prolog
		    $inprolog = 1;
		    $nondsclines = 0;
		    # Insert options for "Prolog"
		    if (!$prologfound) {
			$line .= makeprologsection($dat, $optionset, 0);
		    }
		    $prologfound = 1;
		} elsif (($line =~ m/^\%\%EndProlog/) &&
			 ($nestinglevel == 0)) {
		    # End of Prolog
		    $inprolog = 0;
		    $insertoptions = $linect + 1;
		} elsif (($line =~ m/^\%\%BeginSetup/) &&
			 ($nestinglevel == 0)) {
		    # Beginning of Setup
		    $insetup = 1;
		    $nondsclines = 0;
		    # If there was no "Prolog" but there are options for
		    # the "Prolog", push a "Prolog" with these options onto
		    # the @psfifo here
		    if (!$prologfound) {
			# "Prolog" missing, insert it here
			$line = makeprologsection($dat, $optionset, 1) .
			    $line;
			# Now we have a "Prolog"
			$prologfound = 1;
		    }
		    # Insert options for "DocumentSetup" or "AnySetup"
		    if (!$setupfound) {
			$line .= makesetupsection($dat, $optionset, 0);
		    }
		    $setupfound = 1;
		} elsif (($line =~ m/^\%\%EndSetup/) &&
			 ($nestinglevel == 0)) {
		    # End of Setup
		    $insetup = 0;
		    $insertoptions = $linect + 1;
		} elsif (($line =~ m/^\%\%Page:(.*)$/) &&
			 ($nestinglevel == 0)) {
		    if ((!$lastpassthru) && (!$inheader)) {
			# In the last line we were not in passthru mode,
			# so the last page is not printed. Prepare to do
			# it now.
			$printprevpage = 1;
			# Print the previous page
			$passthru = 1;
			print $logh "New page found but previous not " . 
			    "printed, print it now.\n";
		    } else {
			# The previous page is printed, so we can prepare
			# the current one
			$printprevpage = 0;
			print $logh "\n-----------\nNew page: $1\n";
			# Here begins a new page
			if ($inheader) {
			    # If there was no "Setup" but there are
			    # options for the "Setup", push a "Setup"
			    # with these options onto the @psfifo here
			    if (!$setupfound) {
				# "Setup" missing, insert it here
				$line = 
				    makesetupsection($dat, $optionset, 1) .
				    $line;
				# Now we have a "setup"
				$setupfound = 1;
			    }
			    # If there was no "Prolog" but there are
			    # options for the "Prolog", push a "Prolog"
			    # with these options onto the @psfifo here
			    if (!$prologfound) {
				# "Prolog" missing, insert it here
				$line = 
				    makeprologsection($dat, $optionset, 1) .
				    $line;
				# Now we have a "Prolog"
				$prologfound = 1;
			    }
			    # The first page starts, so the header ends
			    $inheader = 0;
			    $nondsclines = 0;
			    # Option setting should go into the
			    # page-specific option set now
			    $optionset = 'currentpage';
			} else {
			    # Save the option settings of the previous page
			    copyoptions($dat, 'currentpage',
					'previouspage');
			    deleteoptions($dat, 'currentpage');
			}
			# Initialize the option set
			copyoptions($dat, 'header', 'currentpage');
			$pagesetupfound = 0;
			if ($spooler eq 'cups') {
			    # Remove the "notfirst" flag from all options
			    # forseen for the "PageSetup" section, because
			    # when these are numerical options for CUPS.
			    # they have to be set to the correct value
			    # for every page
			    for $arg (@{$dat->{'args'}}) {
				if (($arg->{'section'} eq 'PageSetup') &&
				    (defined($arg->{'notfirst'}))) {
				    delete($arg->{'notfirst'});
				}
			    }
			} else {
			    # Insert PostScript option settings
			    # (options for section "PageSetup".
			    if ($isdscjob) {
				$line .= 
				    makepagesetupsection($dat, $optionset,
							 0);
				$pagesetupfound = 1;
			    }
			}
			# Now the page header comes, so buffer the data,
			# because we must perhaps shut down and restart 
			# the renderer
			$passthru = 0;
			$ignorepageheader = 0;
		    }
		} elsif (($line =~ m/^\%\%BeginPageSetup/) &&
			 ($nestinglevel == 0) &&
			 (!$ignorepageheader))  {
		    # Start of the page header, up to %%EndPageSetup
		    # nothing of the page will be drawn, page-specific
		    # option settngs (as letter-head paper for page 1)
		    # go here
		    $passthru = 0;
		    $inpageheader = 1;		
		} elsif (($line =~ m/^\%\%EndPageSetup/) &&
			 ($nestinglevel == 0) &&
			 (!$ignorepageheader)) {
		    # End of the page header, the page is ready to be
		    # printed
		    print $logh "End of page header\n";
		    $passthru = 1;
		    $inpageheader = 0;
		} elsif ((($line =~ m/^\%\%(BeginFeature):\s*\*?([^\*\s=]+)\s+(\S[^\r\n]*)\r?\n?$/) ||
			  ($line =~ m/^\s*\%\%\s*(FoomaticRIPOptionSetting):\s*([^\*\s=]+)\s*=\s*(\S[^\r\n]*)\r?\n?$/)) &&
			 ($nestinglevel == 0) &&
			 (!$optionreplaced) &&
			 ((!$passthru) || (!$isdscjob))) {
		    my ($linetype, $option, $value) = ($1, $2, $3);

		    # Mark that we are in a "Feature" section
		    if ($linetype eq 'BeginFeature') {
			$infeature = 1;
		    }
		    
		    # OK, we have an option.  If it's not a
		    # *ostscript-style option (ie, it's command-line or
		    # JCL) then we should note that fact, since the
		    # attribute-to-filteroption passing in CUPS is kind of
		    # funky, especially wrt boolean options.  

		    print $logh "Found: $line";
		    if ($arg=argbyname($option)) {
			print $logh "   Option: $option=$value";
			if (($spooler eq 'cups') &&
			    ($linetype eq 'BeginFeature') &&
			    (!defined($arg->{'notfirst'})) &&
			    (($arg->{'type'} eq 'int') ||
			     ($arg->{'type'} eq 'float'))) {
			    # We have the first occurence of a numerical
			    # option setting and the spooler is CUPS,
			    # so this setting is inserted by "pstops".
			    # As "pstops" ignores settings of numerical
			    # options which are not one of the choices
			    # in the PPD file, and inserts the default
			    # value instead, we must fix this here
			    # replacing the setting inserted by "pstops"
			    # with the exact setting given on the command
			    # line.
			    if ($arg->{$optionset} != $value) {
				# The value from the command line was not
				# inserted by "pstops" so it seems to be
				# not under the choices in the PPD.
				# $arg->{$optionset} is already 
				# range-checked, so do not check again here
				# Insert DSC comment
				my $dest = ((($inheader) && ($isdscjob)) ?
					    \@psheader : \@psfifo);
				push(@{$dest},
				     "%%BeginFeature: " .
				     "*$option $arg->{$optionset}\n");
				if ($arg->{'style'} eq 'G') {
				    # PostScript option, insert the code
				    push(@{$dest},
					 sprintf($arg->{'proto'},
						 $arg->{$optionset}) .
					 "\n");
				} else {
				    # Cmmand line or JCL option
				    push(@{$dest},
					 "%% FoomaticRIPOptionSetting: " .
					 "$option=$arg->{$optionset}\n");
				}
				print $logh " --> Correcting numerical " .
				    "option to $option=$arg->{$optionset}" .
				    " (Command line argument)\n";
				# We have replaced this option on the 
				# FIFO
				$optionreplaced = 1;
			    }
			}
			# Mark that we have already found this option
			$arg->{'notfirst'} = 1;
			if (!$optionreplaced) {
			    if ($arg->{'style'} ne 'G') {
				# Non-PostScript option
				# Check whether it is valid
				if (defined(my $newvalue =
					    checkoptionvalue($dat, $option,
							     $value, 0))) {
				    print $logh " --> Setting option\n";
				    # Valid option, set it.
				    $arg->{$optionset} = $newvalue;
				    if (($arg->{'type'} eq 'enum') &&
					(($option eq 'PageSize') ||
					 ($option eq 'PageRegion')) &&
					($newvalue =~ /^Custom/) &&
					($linetype eq 
					 'FoomaticRIPOptionSetting')) {
					# Custom page size
					$twolinesbefore =~
					    /^\s*([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)\s*$/;
					my ($w, $h) = ($1, $2);
					if (($w) && ($h) && 
					    ($w != 0) && ($h != 0)) {
					    $newvalue = "$newvalue.$wx$h";
					    $arg->{$optionset} = $newvalue;
					}
				    }
				    # If this argument is PageSize or 
				    # PageRegion, also set the other
				    syncpagesize($dat, $option, $newvalue, 
						 $optionset);
				} else {
				    # Invalid option, log it.
				    print $logh " --> Invalid option " .
					"setting found in job\n";
				}
			    } else {
				# it is a PostScript style option,
				# presumably all applied for us and such...
				print $logh 
				    " --> Option will be set by " .
				    "PostScript interpreter\n";
			    }
			}
		    } else {
			# This option is unknown to us.  WTF?
			print $logh "Unknown option $option=$value found " .
			    "in the job\n";
		    }
		} elsif (($line =~ m/^\%\%EndFeature/) &&
			 ($nestinglevel == 0)) {
		    # End of Feature
		    $infeature = 0;
		    # If the option setting was replaced, it ends here, too,
		    # end the next option is not necessarily also replaced.
		    $optionreplaced = 0;
		} elsif (($line =~ m/^\%\%Begin/) &&
			 ($isdscjob) &&
			 (!$prologfound) &&
			 ($nestinglevel == 0)) {
		    # In some PostScript files (especially when generated
		    # by "dvips" of TeX/LaTeX) the "%%BeginProlog" is
		    # missing, so assume that it was before the current
		    # line (the first line starting with "%%Begin".
		    print $logh "Job claims to be DSC-conforming, but " . 
			"\"%%BeginProlog\" was missing before first " .
			"line with another \"%%Begin...\" comment " .
			"(is this a TeX/LaTeX/dvips-generated PostScript " .
			"file?). Assuming start of \"Prolog\" here.\n";
		    # Beginning of Prolog
		    $inprolog = 1;
		    $nondsclines = 0;
		    # Insert options for "Prolog" before the current line
		    if (!$prologfound) {
			$line =
			    "%%BeginProlog\n" .
			    makeprologsection($dat, $optionset, 0) .
			    $line;
		    }
		    $prologfound = 1;
		} elsif (($line =~ m/^\s*\%/) || ($line =~ m/^\s*$/)) {
		    # This is an unknown PostScript comment or a blank line,
		    # no active code
		    $ignoreline = 1;
		} else {
		    # This line is active PostScript code
		    if ($inheader) {
			if ((!$inprolog) && (!$insetup)) {
			    # Outside the "Prolog" and "Setup" section
			    # a correct DSC-conforming document has no
			    # active PostScript code, so consider the
			    # file as non-DSC-conforming when there are
			    # too many of such lines.
			    $nondsclines ++;
			    if ($nondsclines > $maxnondsclinesinheader) {
				# Consider document as not DSC-conforming
				print $logh "This job seems not to be " .
				    "DSC-conforming, DSC-comment for " .
				    "next section not found, stopping " .
				    "to parse the rest, passing it " .
				    "directly to the renderer.\n";
				# Stop scanning for further option settings
				$maxlines = 1;
				$isdscjob = 0;
				# Insert defaults and command line settings
				# in the beginning of the job or after the
				# last valid section
				splice(@psheader, $insertoptions, 0,
				       ($prologfound ? () :
					makeprologsection($dat, $optionset, 
							  1)),
				       ($setupfound ? () :
					makesetupsection($dat, $optionset,
							 1)),
				       ($pagesetupfound ? () :
					makepagesetupsection($dat,
							     $optionset, 
							     1)));
				$prologfound = 1;
				$setupfound = 1;
				$pagesetupfound = 1;
			    }
			}
		    } else {
			if (!$inpageheader) {
			    # PostScript code inside a page, but not between
			    # "%%BeginPageSetup" and "%%EndPageSetup", so 
			    # we are perhaps already drawing onto a page now
			    if ($onelinebefore =~ m/^\%\%Page:/) {
				print $logh "No page header or page " .
				    "header not DSC-conforming\n";
			    }
			    # Stop buffering lines to search for options 
			    # placed not DSC-conforming
			    if (scalar(@psfifo) >= 
				$maxlinesforpageoptions) {
				print $logh "Giving up searching a " .
				    "DSC-conforming page header\n";
				$passthru = 1;
				# If there comes a page header now, ignore 
				# it
				$ignorepageheader = 1;
			    }
			}
		    }
		}
	    }
	    
	    # Debug info
	    if ($lastpassthru != $passthru) {
		if ($passthru) {
		    print $logh "Found:\n   $line" . 
			" --> Output goes directly to the renderer now.\n" .
			"\n";
		} else {
		    print $logh "Found:\n   $line" . 
			" --> Output goes to the FIFO buffer now.\n\n";
		}
	    }

	    # We are in an option which was replaced, do not output
	    # the current line.
	    if ($optionreplaced) {
		$line = "";
	    }

	    # Store or send the current line
	    if (($inheader) && ($isdscjob)) {
		# We are still in the PostScript header, collect all lines 
		# in @psheader
		push (@psheader, $line);
	    } else {
		if (($passthru) && ($isdscjob)) {
		    if (!$lastpassthru) {
			# We enter passthru mode with this line, so the
			# command line can have changed, check it and
			# close the renderer if needed
			if (($rendererpid) &&
			    (!optionsequal($dat, 'currentpage',
					   'previouspage'))) {
			    print $logh "Command line/JCL options " .
				"changed, restarting renderer\n";
			    $retval = closerendererhandle
				($rendererhandle, $rendererpid);
			    if ($retval != $EXIT_PRINTED) {
				rip_die ("Error closing renderer",
					 $retval);
			    }
			    $rendererpid = 0;
			}
		    }
		    # Flush @psfifo and send line directly to the renderer
		    if (!$rendererpid) {
			# No renderer running, start it
			($rendererhandle, $rendererpid) =
			    getrendererhandle
			    ($dat, join('', @psheader, @psfifo));
			if ($retval != $EXIT_PRINTED) {
			    rip_die ("Error opening renderer",
				     $retval);
			}
			# @psfifo is sent out, flush it.
			@psfifo = ();
		    }
		    if ($#psfifo >= 0) {
			# Send @psfifo to renderer
			print $rendererhandle join('', @psfifo);
			# flush @psfifo
			@psfifo = ();
		    }
		    # Send line to renderer
		    if (!$printprevpage) {
			print $rendererhandle $line;
		    }
		} else {
		    # Push the line onto the stack for later spitting up...
		    push (@psfifo, $line);
		}
	    }
	    
	    if (!$printprevpage) {
		$linect++;
	    }

	} else {
	    # EOF!
	    $more_stuff = 0;
	    # No PostScript header in the whole file? Then it's not
	    # PostScript, convert it.
	    # We open the file converter here when the file has less
	    # lines than the amount which we search for the PostScript
	    # header ($maxlinestopsstart).
	    if ($linect <= $nonpslines) {
		# This is not a PostScript job, we must convert it
		print $logh "\nJob does not start with \"%!\", " . 
		    "is it PostScript?\n" .
		    "Starting file converter\n";
		# Reset all variables but conserve the data which
		# we have already read.
		$jobhasjcl = 0;
		$linect = 0;
		$nonpslines = 0;
		$maxlines = 1000;
		$onelinebefore = "";
		$twolinesbefore = "";
		my $alreadyread = join('', @psheader, @psfifo);
		@psheader = ();
		@psfifo = ();
		$line = "";
		# Start the file conversion filter
		if (!$fileconverterpid) {
		    ($fileconverterhandle, $fileconverterpid) =
			getfileconverterhandle($dat, $alreadyread);
		    if ($retval != $EXIT_PRINTED) {
			rip_die ("Error opening file converter",
				 $retval);
		    }
		} else {
		    rip_die("File conversion filter probably " .
			    "crashed",
			    $EXIT_JOBERR);
		}
		# Read the further data from the file converter and
		# not from STDIN
		if (!close STDIN) {
		    rip_die ("Couldn't close STDIN",
			     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
		}
		if (!open (STDIN, "<&$fileconverterhandle")) {
		    rip_die ("Couldn't dup \$fileconverterhandle",
			     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
		}
		# Now we have new (converted) stuff in STDIN, so
		# continue in the loop
		$more_stuff = 1;
	    }
	}

	$lastpassthru = $passthru;
	
	if ((!$ignoreline) && (!$printprevpage)) {
	    $twolinesbefore = $onelinebefore;
	    $onelinebefore = $line;
	}

    } while ((($maxlines == 0) or ($linect < $maxlines)) and
	     ($more_stuff != 0));

    # Some buffer still containing data? Send it out to the renderer.
    if (($more_stuff != 0) || ($#psheader >= 0) || ($#psfifo >= 0)) {
	# Flush @psfifo and send the remaining data to the renderer, this
	# only happens with non-DSC-conforming jobs or non-Foomatic PPDs
	if ($more_stuff) {
	    print $logh "Stopped parsing the PostScript data, ".
		"sending rest directly to renderer.\n";
	} else {
	    print $logh "Flushing FIFO.\n";
	}
	if ($inheader) {
	    # No page initialized yet? Copy the "header" option set into the
	    # "currentpage" option set, so that the renderer will find the
	    # options settings.
	    copyoptions($dat, 'header', 'currentpage');
	    $optionset = 'currentpage';
	    # If not done yet, insert defaults and command line settings
	    # in the beginning of the job or after the last valid section
	    splice(@psheader, $insertoptions, 0,
		   ($prologfound ? () :
		    makeprologsection($dat, $optionset, 1)),
		   ($setupfound ? () :
		    makesetupsection($dat, $optionset, 1)),
		   ($pagesetupfound ? () :
		    makepagesetupsection($dat, $optionset, 1)));
	    $prologfound = 1;
	    $setupfound = 1;
	    $pagesetupfound = 1;
	}
	if (!$rendererpid) {
	    ($rendererhandle, $rendererpid) =
		getrendererhandle($dat, join('', @psheader, @psfifo));
	    if ($retval != $EXIT_PRINTED) {
		rip_die ("Error opening renderer",
			 $retval);
	    }
	    # We have sent @psfifo now
	    @psfifo = ();
	}
	if ($#psfifo >= 0) {
	    # Send @psfifo to renderer
	    print $rendererhandle join('', @psfifo);
	    # flush @psfifo
	    @psfifo = ();
	}
	# Print the rest of the input data
	if ($more_stuff) {
	    while (<STDIN>) {
		print $rendererhandle $_;
	    }
	}
    }
    
    # Close the renderer
    if ($rendererpid) {
	$retval = closerendererhandle ($rendererhandle, $rendererpid);
	if ($retval != $EXIT_PRINTED) {
	    rip_die ("Error closing renderer",
		     $retval);
	}
	$rendererpid = 0;
    }

    # Close the file converter (if it was used)
    if ($fileconverterpid) {
	$retval = closefileconverterhandle
	    ($fileconverterhandle, $fileconverterpid);
	if ($retval != $EXIT_PRINTED) {
	    rip_die ("Error closing file converter",
		     $retval);
	}
	$fileconverterpid = 0;
    }
}


## Close the documentation page generator
if ($docgeneratorpid) {
    $retval = closedocgeneratorhandle
	($docgeneratorhandle, $docgeneratorpid);
    if ($retval != $EXIT_PRINTED) {
	rip_die ("Error closing documentation page generator",
		 $retval);
    }
    $docgeneratorpid = 0;
}



## Close last input file
close STDIN;



## Only for debugging
if ($debug && 1) {
    use Data::Dumper;
    local $Data::Dumper::Purity=1;
    local $Data::Dumper::Indent=1;
    print $logh Dumper(%ENV);
    print $logh Dumper($dat);
}



## The End
print $logh "\nClosing foomatic-rip.\n";
close $logh;

exit $retval;



## Functions to let foomatic-rip fork to do several tasks in parallel.

# To do the filtering without loading the whole file into memory we work
# on a data stream, we read the data line by line analyse it to decide what
# filters to use and start the filters if we have found out which we need.
# We buffer the data only as long as we didn't determing which filters to
# use for this piece of data and with which options. There are no temporary
# files used.

# foomatic-rip splits into up to 6 parallel processes to do the whole
# filtering (listed in the order of the data flow):

#    KID0: Generate documentation pages (only jobs with "docs" option)
#    KID2: Put together already read data and current input stream for
#          feeding into the file conversion filter (only non-PostScript
#          and "docs" jobs)
#    KID1: Run the file conversion filter to convert non-PostScript
#          input into PostScript (only non-PostScript and "docs" jobs)
#    MAIN: Prepare the job auto-detecting the spooler, reading the PPD,
#          extracting the options from the command line, and parsing
#          the job data itself. It analyses the job data to check
#          whether it is PostScript and starts KID1/KID2 if not, it
#          also stuffs PostScript code from option settings into the
#          PostScript data stream. It starts the renderer (KID3/KID4)
#          as soon as it knows its command line and restarts it when
#          page-specific option settings need another command line
#          or different JCL commands.
#    KID3: The rendering process. In most cases GhostScript, "cat"
#          for native PostScript printers with their manufacturer's
#          PPD files.
#    KID4: Put together the JCL commands and the renderer's output
#          and send all that either to STDOUT or pipe it into the
#          command line defined with $postpipe.

## This function runs the renderer command line (and if defined also
## the postpipe) and returns a file handle for stuffing in the
## PostScript data.

sub getrendererhandle {

    my ($dat, $prepend) = @_;

    print $logh "\nStarting renderer\n";

    # Catch signals
    $retval = $EXIT_PRINTED;
    use sigtrap qw(handler set_exit_prnerr USR1 
		   handler set_exit_prnerr_noretry USR2
		   handler set_exit_engaged TTIN);

    # Variables for the kid processes reporting their state

    # Set up a pipe for the kids to pass their exit stat to the main process
    pipe KID_MESSAGE, KID_MESSAGE_IN;

    # When one kid fails put the exit stat here
    $kidfailed = 0;

    # When a kid exits successfully, mark it here
    $kid3finished = 0;
    $kid4finished = 0;

    # Build the command line and get the JCL commands
    buildcommandline($dat, 'currentpage');
    $commandline = $dat->{'currentcmd'};
    @jclprepend = @{$dat->{'jclprepend'}};
    @jclappend = @{$dat->{'jclappend'}};

    use IO::Handle;
    pipe KID3_IN, KID3;
    KID3->autoflush(1);
    my $pid3 = fork();
    if (!defined($pid3)) {
	close KID3;
	close KID3_IN;
        print $logh "$0: cannot fork for kid3!\n";
	rip_die ("can't fork for kid3",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
    if ($pid3) {

        # we are the parent; return a glob to the filehandle
        close KID3_IN;

	# Feed in the PostScript header and the FIFO contents
	print KID3 $prepend;

        KID3->flush();
        return ( *KID3, $pid3 );

    } else {
        close KID3;

        pipe KID4_IN, KID4;
	KID4->autoflush(1);
        my $pid4 = fork();
        if (!defined($pid4)) {
	    close KID4;
	    close KID4_IN;
            print $logh "$0: cannot fork for kid4!\n";
	    close KID_MESSAGE;
	    print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
	    close KID_MESSAGE_IN;
	    rip_die ("can't fork for kid4",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
        }
        
        if ($pid4) {
            # parent, child of primary task; we are |commandline|
            close KID4_IN;

            print $logh "renderer PID pid4=$pid4\n";
	    print $logh "renderer command: $commandline\n";
            
            if (!close STDIN) {
		close KID3_IN;
		close KID4;
		close KID_MESSAGE;
		print KID_MESSAGE_IN
		    "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_IN;
		rip_die ("Couldn't close STDIN in $pid4",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!open (STDIN, "<&KID3_IN")) {
		close KID3_IN;
		close KID4;
		close KID_MESSAGE;
		print KID_MESSAGE_IN
		    "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_IN;
		rip_die ("Couldn't dup KID3_IN",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!close STDOUT) {
		close KID3_IN;
		close KID4;
		close KID_MESSAGE;
		print KID_MESSAGE_IN
		    "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_IN;
		rip_die ("Couldn't close STDOUT in $pid4",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!open (STDOUT, ">&KID4")) {
		close KID3_IN;
		close KID4;
		close KID_MESSAGE;
		print KID_MESSAGE_IN
		    "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_IN;
		rip_die ("Couldn't dup KID4",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
	    if ($debug) {
		if (!open (STDERR, ">&$logh")) {
		    close KID3_IN;
		    close KID4;
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN
			"3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		    close KID_MESSAGE_IN;
		    rip_die ("Couldn't dup logh to stderr",
			     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
		}
	    }

	    # Massage commandline to execute foomatic-gswrapper
	    my $havewrapper = 0;
	    for (split(':', $ENV{'PATH'})) {
		if (-x "$_/foomatic-gswrapper") {
		    $havewrapper=1;
		    last;
		}
	    }
	    if ($havewrapper) {
		$commandline =~ s!^\s*gs !foomatic-gswrapper !;
		$commandline =~ s!(\|\s*)gs !\|foomatic-gswrapper !;
		$commandline =~ s!(;\s*)gs !; foomatic-gswrapper !;
	    }

	    # In debug mode save the data supposed to be fed into the
	    # renderer also into a file
	    if ($debug) {
		$commandline = "tee -a ${logfile}.ps | $commandline";
	    }
	    
	    # Actually run the thing...
	    system("$commandline");
            if ($? != 0) {
		my $rendererretval = $? >> 8;
		print $logh "renderer return value: $rendererretval\n";
		my $renderersignal = $? & 127;
		print $logh "renderer received signal: $rendererretval\n";
		close STDOUT;
		close KID4;
		close STDIN;
		close KID3_IN;
		# Handle signals
		if ($renderersignal == $SIGUSR1) {
		    $retval = $EXIT_PRNERR;
		} elsif ($renderersignal == $SIGUSR2) {
		    $retval = $EXIT_PRNERR_NORETRY;
		} elsif ($renderersignal == $SIGTTIN) {
		    $retval = $EXIT_ENGAGED;
		}
		if ($retval != $EXIT_PRINTED) {
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $retval\n";
		    close KID_MESSAGE_IN;
		    exit $retval;
		}
		# Evaluate renderer result
		if ($rendererretval == 0) {
		    # Success, exit with 0 and inform main process
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRINTED\n";
		    close KID_MESSAGE_IN;
		    exit $EXIT_PRINTED;
		} elsif ($rendererretval == 1) {
		    # Syntax error? PostScript error?
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_JOBERR\n";
		    close KID_MESSAGE_IN;
		    rip_die ("Possible error on renderer command line or PostScript error. Check options.",
			     $EXIT_JOBERR);
		} elsif ($rendererretval == 139) {
		    # Seems to indicate a core dump
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_JOBERR\n";
		    close KID_MESSAGE_IN;
		    rip_die ("The renderer may have dumped core.",
			     $EXIT_JOBERR);
		} elsif ($rendererretval == 141) {
		    # Broken pipe, presumably additional filter interface
		    # exited.
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRNERR\n";
		    close KID_MESSAGE_IN;
		    rip_die ("A filter used in addition to the renderer" .
			     " itself may have failed.",
			     $EXIT_PRNERR);
		} elsif (($rendererretval == 243) || ($retval == 255)) {
		    # PostScript error?
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_JOBERR\n";
		    close KID_MESSAGE_IN;
		    exit $EXIT_JOBERR;
		} else {
		    # Unknown error
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRNERR\n";
		    close KID_MESSAGE_IN;
		    rip_die ("The renderer command line returned an" .
			     " unrecognized error code $rendererretval.",
			     $EXIT_PRNERR);
		}
	    }
	    close STDOUT;
	    close KID4;
	    close STDIN;
	    close KID3_IN;
	    # When arrived here the renderer command line was successful
	    # So exit with zero exit value here and inform the main process
	    close KID_MESSAGE;
	    print KID_MESSAGE_IN "3 $EXIT_PRINTED\n";
	    close KID_MESSAGE_IN;
	    # Wait for postpipe/output child
	    waitpid($pid4, 0);
	    print $logh "KID3 finished\n";
	    exit $EXIT_PRINTED;
        } else {
            # child, trailing task on the pipe; we write jcl stuff
            close KID4;
	    close KID3_IN;

            my $fileh = *STDOUT;

	    # Do we have a $postpipe, if yes, launch the command(s) and
	    # point our output into it/them
            if ($postpipe) {
                if (!open PIPE,$postpipe) {
		    close KID4_IN;
                    close KID_MESSAGE;
                    print KID_MESSAGE_IN
			"4 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		    close KID_MESSAGE_IN;
                    rip_die ("cannot execute postpipe $postpipe",
                             $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
                }
                $fileh = *PIPE;
            }

	    # Debug output
	    print $logh "JCL: " . join("", @jclprepend) . "<job data>\n" .
		join("", @jclappend) . "\n";

            # wrap the JCL around the job data, if there are any
            # options specified...
	    if ( @jclprepend > 1 ) {
		print $fileh @jclprepend;
	    }
            while (<KID4_IN>) {
                print $fileh $_;
            }
	    if ( @jclprepend > 1 ) {
		print $fileh @jclappend;
	    }
            
            if (!close $fileh) {
		close KID4_IN;
		close KID_MESSAGE;
		print KID_MESSAGE_IN
		    "4 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_IN;
		rip_die ("error closing $fileh",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
	    close KID4_IN;

            print $logh "tail process done writing data to STDOUT\n";

	    # Handle signals of the backend interface
	    if ($retval != $EXIT_PRINTED) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "4 $retval\n";
		close KID_MESSAGE_IN;
		exit $retval;
	    }

	    # Successful exit, inform main process
	    close KID_MESSAGE;
	    print KID_MESSAGE_IN "4 $EXIT_PRINTED\n";
	    close KID_MESSAGE_IN;

	    print $logh "KID4 finished\n";
            exit($EXIT_PRINTED);
        }
    }
}



## Close the renderer process and wait until all kid processes finish.

sub closerendererhandle {

    my ($rendererhandle, $rendererpid) = @_;

    print $logh "\nClosing renderer\n";

    # Do it!
    close $rendererhandle;

    # Wait for all kid processes to finish or one kid process to fail
    close KID_MESSAGE_IN;
    while ((!$kidfailed) &&
	   !(($kid3finished) &&
	     ($kid4finished))) {
	my $message = <KID_MESSAGE>;
	chomp $message;
	if ($message =~ /(\d+)\s+(\d+)/) {
	    my $kid_id = $1;
	    my $exitstat = $2;
	    print $logh "KID$kid_id exited with status $exitstat\n";
	    if ($exitstat > 0) {
		$kidfailed = $exitstat;
	    } elsif ($kid_id == 3) {
		$kid3finished = 1;
	    } elsif ($kid_id == 4) {
		$kid4finished = 1;
	    }
	}
    }

    close KID_MESSAGE;

    # If a kid failed, return the exit stat of this kid
    if ($kidfailed != 0) {
	$retval = $kidfailed;
    }

    print $logh "Renderer exit stat: $retval\n";
    # Wait for renderer child
    waitpid($rendererpid, 0);
    print $logh "Renderer process finished\n";
    return ($retval);
}



## This function is only used when the input data is not
## PostScript. Then it runs a filter which converts non-PostScript
## files into PostScript. The user can choose which filter he wants
## to use. The filter command line is provided by $fileconverter.

sub getfileconverterhandle {

    # Already read data must be converted, too
    my ($dat, $alreadyread) = @_;

    print $logh "\nStarting converter for non-PostScript files\n";

    # Determine with which command non-PostScript files are converted
    # to PostScript
    if ($fileconverter eq "") {
	if ($spoolerfileconverters->{$spooler}) {
	    $fileconverter = $spoolerfileconverters->{$spooler};
	} else {
	    for my $c (@fileconverters) {
		($c =~ m/^\s*(\S+)\s+/) || ($c = m/^\s*(\S+)$/);
		$command = $1;
		for (split(':', $ENV{'PATH'})) {
		    if (-x "$_/$command") {
			$fileconverter = $c;
			last;
		    }
		}
		if ($fileconverter ne "") {
		    last;
		}
	    }
	}
	if ($fileconverter eq "") {
	    $fileconverter = "echo \"Cannot convert file to " .
		"PostScript!\" 1>&2";
	}
    }

    # Insert the page size into the $fileconverter
    if ($fileconverter =~ /\@\@([^@]+)\@\@PAGESIZE\@\@/) {
	# We always use the "header" option swt here, with a
	# non-PostScript file we have no "currentpage"
	my $optstr = $1;
	my $sizestr = (($arg = $dat->{'args_byname'}{'PageSize'})
		       ? $arg->{'header'}
		       : "");
	if ($sizestr) {
	    # Use wider margins so that the pages come out completely on
	    # every printer model (especially HP inkjets)
	    if ($fileconverter =~ /^\s*(a2ps)\s+/) {
		if (lc($sizestr) eq "letter") {
		    $sizestr = "Letterdj";
		} elsif (lc($sizestr) eq "a4") {
		    $sizestr = "A4dj";
		}
	    }
	    $optstr .= $sizestr;
	} else {
	    $optstr = "";
	}
	$fileconverter =~ s/\@\@([^@]+)\@\@PAGESIZE\@\@/$optstr/;
    }

    # Insert the job title into the $fileconverter
    if ($fileconverter =~ /\@\@([^@]+)\@\@JOBTITLE\@\@/) {
	if ($do_docs) {
	    $jobtitle =
		"Documentation for the $model";
	}
	my $titlearg = $1;
	my ($arg, $optstr);
	($arg = $jobtitle) =~ s/\"/\\\"/g;
	if (($titlearg =~ /\"/) || $arg) {
	    $optstr = $titlearg . ($titlearg =~ /\"/ ? '' : '"') .
		($arg ? "$arg\"" : '"');
	} else {
	    $optstr = "";
	}
	$fileconverter =~ s/\@\@([^@]+)\@\@JOBTITLE\@\@/$optstr/;
    }

    # Apply "pstops" when having used a file converter under CUPS, so
    # CUPS can stuff the default settings into the PostScript output
    # of the file converter (so all CUPS settings get also applied when
    # one prints the documentation pages (all other files we get
    # already converted to PostScript by CUPS.
    if ($spooler eq 'cups') {
	$fileconverter .=
	    " | ${programdir}pstops '$ARGV[0]' '$ARGV[1]' '$ARGV[2]' " .
	    "'$ARGV[3]' '$ARGV[4]'";
    }

    # Variables for the kid processes reporting their state

    # Set up a pipe for the kids to pass their exit stat to the main process
    pipe KID_MESSAGE_CONV, KID_MESSAGE_CONV_IN;

    # When one kid fails put the exit stat here
    $convkidfailed = 0;

    # When a kid exits successfully, mark it here
    $kid1finished = 0;
    $kid2finished = 0;

    use IO::Handle;
    pipe KID1_IN, KID1;
    KID1->autoflush(1);
    my $pid1 = fork();
    if (!defined($pid1)) {
	close KID1;
	close KID1_IN;
        print $logh "$0: cannot fork for kid1!\n";
	rip_die ("can't fork for kid1",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }

    if ($pid1) {

        # we are the parent; return a glob to the filehandle
        close KID1;

        return ( *KID1_IN, $pid1 );

    } else {
	# We go on reading the job data and stuff it into the file
	# converter
        close KID1_IN;

        pipe KID2_IN, KID2;
	KID2->autoflush(1);
        my $pid2 = fork();
        if (!defined($pid2)) {
            print $logh "$0: cannot fork for kid2!\n";
	    close KID1;
	    close KID2;
	    close KID2_IN;
	    close KID_MESSAGE_CONV;
	    print KID_MESSAGE_CONV_IN 
		"1 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
	    rip_die ("can't fork for kid2",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
        }
        
        if ($pid2) {
            # parent, child of primary task; we are |$fileconverter|
            close KID2;

            print $logh "file converter PID pid2=$pid2\n";
	    if (($debug) || ($spooler ne 'cups')) {
		print $logh "file converter command: $fileconverter\n";
	    }
            
            if (!close STDIN) {
		close KID1;
		close KID2_IN;
		close KID_MESSAGE_CONV;
		print KID_MESSAGE_CONV_IN 
		    "1 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_CONV_IN;
		rip_die ("Couldn't close STDIN in $pid2",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!open (STDIN, "<&KID2_IN")) {
		close KID1;
		close KID2_IN;
		close KID_MESSAGE_CONV;
		print KID_MESSAGE_CONV_IN 
		    "1 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_CONV_IN;
		rip_die ("Couldn't dup KID2_IN",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!close STDOUT) {
		close KID1;
		close KID2_IN;
		close KID_MESSAGE_CONV;
		print KID_MESSAGE_CONV_IN
		    "1 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_CONV_IN;
		rip_die ("Couldn't close STDOUT in $pid2",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!open (STDOUT, ">&KID1")) {
		close KID1;
		close KID2_IN;
		close KID_MESSAGE_CONV;
		print KID_MESSAGE_CONV_IN
		    "1 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_CONV_IN;
		rip_die ("Couldn't dup KID1",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
	    if ($debug) {
		if (!open (STDERR, ">&$logh")) {
		    close KID1;
		    close KID2_IN;
		    close KID_MESSAGE_CONV;
		    print KID_MESSAGE_CONV_IN
			"1 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		    close KID_MESSAGE_CONV_IN;
		    rip_die ("Couldn't dup logh to stderr",
			     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
		}
	    }

	    # Actually run the thing...
	    system("$fileconverter");
            if ($? != 0) {
		my $fileconverterretval = $? >> 8;
		print $logh "file converter return value: " .
		    "$fileconverterretval\n";
		my $fileconvertersignal = $? & 127;
		print $logh "file converter received signal: ".
		    "$fileconverterretval\n";
		close STDOUT;
		close KID1;
		close STDIN;
		close KID2_IN;
		# Handle signals
		if ($fileconvertersignal == $SIGUSR1) {
		    $retval = $EXIT_PRNERR;
		} elsif ($fileconvertersignal == $SIGUSR2) {
		    $retval = $EXIT_PRNERR_NORETRY;
		} elsif ($fileconvertersignal == $SIGTTIN) {
		    $retval = $EXIT_ENGAGED;
		}
		if ($retval != $EXIT_PRINTED) {
		    close KID_MESSAGE_CONV;
		    print KID_MESSAGE_CONV_IN "1 $retval\n";
		    close KID_MESSAGE_CONV_IN;
		    exit $retval;
		}
		# Evaluate fileconverter result
		if ($fileconverterretval == 0) {
		    # Success, exit with 0 and inform main process
		    close KID_MESSAGE_CONV;
		    print KID_MESSAGE_CONV_IN "1 $EXIT_PRINTED\n";
		    close KID_MESSAGE_CONV_IN;
		    exit $EXIT_PRINTED;
		} else {
		    # Unknown error
		    close KID_MESSAGE_CONV;
		    print KID_MESSAGE_CONV_IN "1 $EXIT_PRNERR\n";
		    close KID_MESSAGE_CONV_IN;
		    rip_die ("The file converter command line returned " . 
			     "an unrecognized error code " .
			     "$fileconverterretval.",
			     $EXIT_PRNERR);
		}
	    }
	    close STDOUT;
	    close KID1;
	    close STDIN;
	    close KID2_IN;
	    # When arrived here the fileconverter command line was
	    # successful.
	    # So exit with zero exit value here and inform the main process
	    close KID_MESSAGE_CONV;
	    print KID_MESSAGE_CONV_IN "1 $EXIT_PRINTED\n";
	    close KID_MESSAGE_CONV_IN;
	    # Wait for input child
	    waitpid($pid1, 0);
	    print $logh "KID1 finished\n";
	    exit $EXIT_PRINTED;
        } else {
            # child, first part of the pipe, reading in the data from
	    # standard input and stuffing it into the file converter
	    # after putting in the already read data (in $alreadyread)
            close KID1;
	    close KID2_IN;

	    # At first pass the data which we have already read to the
	    # filter
	    print KID2 $alreadyread;
	    # Then read the rest from standard input
	    while (<STDIN>) { 
		print KID2 $_; 
	    }

            if (!close STDIN) {
		close KID2;
		close KID_MESSAGE_CONV;
		print KID_MESSAGE_CONV_IN
		    "2 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		close KID_MESSAGE_CONV_IN;
		rip_die ("error closing STDIN",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
	    close KID2;

            print $logh "tail process done reading data from STDIN\n";

	    # Successful exit, inform main process
	    close KID_MESSAGE_CONV;
	    print KID_MESSAGE_CONV_IN "2 $EXIT_PRINTED\n";
	    close KID_MESSAGE_CONV_IN;

	    print $logh "KID2 finished\n";
            exit($EXIT_PRINTED);
        }
    }
}



## Close the file conversion process and wait until all kid processes
## finish.

sub closefileconverterhandle {

    my ($fileconverterhandle, $fileconverterpid) = @_;

    print $logh "\nClosing file converter\n";

    # Do it!
    close $fileconverterhandle;

    # Wait for all kid processes to finish or one kid process to fail
    close KID_MESSAGE_CONV_IN;
    while ((!$convkidfailed) &&
	   !(($kid1finished) &&
	     ($kid2finished))) {
	my $message = <KID_MESSAGE_CONV>;
	chomp $message;
	if ($message =~ /(\d+)\s+(\d+)/) {
	    my $kid_id = $1;
	    my $exitstat = $2;
	    print $logh "KID$kid_id exited with status $exitstat\n";
	    if ($exitstat > 0) {
		$convkidfailed = $exitstat;
	    } elsif ($kid_id == 1) {
		$kid1finished = 1;
	    } elsif ($kid_id == 2) {
		$kid2finished = 1;
	    }
	}
    }

    close KID_MESSAGE_CONV;

    # If a kid failed, return the exit stat of this kid
    if ($convkidfailed != 0) {
	$retval = $convkidfailed;
    }

    print $logh "File converter exit stat: $retval\n";
    # Wait for fileconverter child
    waitpid($fileconverterpid, 0);
    print $logh "File converter process finished\n";
    return ($retval);
}



## Generate the documentation page and return a filehandle to get it

sub getdocgeneratorhandle {

    # The data structure with the options
    my ($dat) = @_;

    print $logh "\nGenerating documentation page for the $model\n";

    # Printer queue name
    my $printerstr;
    if ($printer) {
	$printerstr = $printer;
    } else {
	$printerstr = "<printer>";
    }
	
    # Spooler-specific differences
    my ($command,
	$enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	$boolopt, $booloptleft, $booloptequal, $booloptright,
	$numopt, $numoptleft, $numoptequal, $numoptright,
	$optsep, $trailer, $custompagesize);
    if ($spooler eq 'cups') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-o ", "", "=", "",
	      "-o ", "", "=", "",
	      "-o ", "", "=", "",
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'lpd') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr -J \"",
	      "", "", "=", "",
	      "", "", "=", "",
	      "", "", "=", "",
	      " ", "\" <file>",
	      "\n  Custom size: PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'gnulpr') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-o ", "", "=", "",
	      "-o ", "", "=", "",
	      "-o ", "", "=", "",
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'lprng') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("lpr -P $printerstr ",
	      "-Z ", "", "=", "",
	      "-Z ", "", "=", "",
	      "-Z ", "", "=", "",
	      " "," <file>",
	      "\n  Custom size: -Z PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -Z PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'ppr') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("ppr -d $printerstr ",
	      "-F ", "\"*", " ", "\"",
	      "-F ", "\"*", " ", "\"",
	      "-F ", "\"*", " ", "\"",
	      " "," <file>",
	      "");
    } elsif ($spooler eq 'ppr-int') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("ppr -d $printerstr ",
	      "-F ", "\"*", " ", "\"",
	      "-F ", "\"*", " ", "\"",
	      "-F ", "\"*", " ", "\"",
	      " "," <file>",
	      "\n  Custom size: -F \"*PageSize Custom\" -i " .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -F \"*PageSize Custom\" -i 4.0x6.0in\n");
    } elsif ($spooler eq 'direct') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("$programname -P $printerstr ",
	      "-o ", "", "=", "",
	      "-o ", "", "=", "",
	      "-o ", "", "=", "",
	      " "," <file>",
	      "\n  Custom size: -o PageSize=Custom." .
	      "<width>x<height>[<unit>]\n" .
	      "               Units: pt (default), in, cm, mm\n" .
	      "  Example: -o PageSize=Custom.4.0x6.0in\n");
    } elsif ($spooler eq 'pdq') {
	($command,
	 $enumopt, $enumoptleft, $enumoptequal, $enumoptright,
	 $boolopt, $booloptleft, $booloptequal, $booloptright,
	 $numopt, $numoptleft, $numoptequal, $numoptright,
	 $optsep, $trailer, $custompagesize) =
	     ("pdq -P $printerstr ",
	      "-o", "", "_", "",
	      "-o", "", "_", "",
	      "-a", "", "=", "",
	      " "," <file>",
	      "\n" .
	      "Option 'PageWidth':\n". 
	      "  Page Width (for \"Custom\" page size)\n" .
	      "  A floating point number argument\n" .
	      "  Range: 0 <= x <= 100000\n" .
	      "  Default: -aPageWidth=612\n" .
	      "  Example: -aPageWidth=123.4\n" .
	      "\n" .
	      "Option 'PageHeight':\n" .
	      "  Page Height (for \"Custom\" page size)\n" .
	      "  A floating point number argument\n" .
	      "  Range: 0 <= x <= 100000\n" .
	      "  Default: -aPageHeight=792\n" .
	      "  Example: -aPageHeight=234.5\n" .
	      "\n" .
	      "Option 'PageSizeUnit':\n" .
	      "  Unit (for \"Custom\" page size)\n" .
	      "  An enumerated choice argument\n" .
	      "  Possible choices:\n" .
	      "   o -oPageSizeUnit_pt: Points (1/72 inch)\n" .
	      "   o -oPageSizeUnit_in: Inches\n" .
	      "   o -oPageSizeUnit_cm: cm\n" .
	      "   o -oPageSizeUnit_mm: mm\n" .
	      "  Default: -oPageSizeUnit_pt\n" .
	      "  Example: -oPageSizeUnit_mm\n");
    }

    # Variables for the kid processes reporting their state

    # Set up a pipe for the kids to pass their exit stat to the main process
    pipe KID_MESSAGE_DOC, KID_MESSAGE_DOC_IN;

    # When the kid fails put the exit stat here
    $dockidfailed = 0;

    # When the kid exits successfully, mark it here
    $kid0finished = 0;

    use IO::Handle;
    pipe KID0_IN, KID0;
    KID0->autoflush(1);
    my $pid0 = fork();
    if (!defined($pid0)) {
	close KID0;
	close KID0_IN;
        print $logh "$0: cannot fork for kid0!\n";
	rip_die ("can't fork for kid0",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }

    if ($pid0) {
        # we are the parent; return a glob to the filehandle
        close KID0;
	print $logh "Documentation page generator PID pid0=$pid0\n";
        return ( *KID0_IN, $pid0 );
    }

    # we are the kid; we generate the documentation page

    close KID0_IN;

    # Kill data on STDIN to satisfy PPR
    if (($spooler eq 'ppr_int') || ($spooler eq 'ppr')) {
	while (my $dummy = <STDIN>) {};
    }
    close STDIN
	or print $logh "Error closing STDIN for docs print\n";

    # write the job into KID0
    select KID0;

    print "\nInvokation summary for the $model\n\n";
    print "Use the following command line:\n\n";
    print "   ${command}${enumopt}${enumoptleft}<option>${enumoptequal}" .
	"<choice>${enumoptright}${optsep}${boolopt}${booloptleft}<switch>" .
	"${booloptequal}<True/False>${booloptright}${optsep}${numopt}" .
	"${numoptleft}<num. option>${numoptequal}<value>${numoptright}" .
	"${trailer}\n\n";
    print "The following options are available for this printer:\n\n";

    for $arg (@{$dat->{'args'}}) {
        my ($name,
            $type,
            $comment,
            $spot,
            $default) = ($arg->{'name'},
                         $arg->{'type'},
                         $arg->{'comment'},
                         $arg->{'spot'},
                         $arg->{'default'});

	# Is this really an option? Otherwise skip it.
	next if (!$type);

	my $tpestr;
        if ($type eq "enum") {
	    $typestr = "An enumerated choice";
	} elsif ($type eq "bool") {
	    $typestr = "A boolean";
	} elsif ($type eq "int") {
	    $typestr = "An integer number";
	} elsif ($type eq "float") {
	    $typestr = "A floating point number";
	}

        print "Option '$name':\n  $comment\n  $typestr argument\n";
        print "  This options corresponds to a PJL command\n" if ($arg->{'style'} eq 'J');
        
        if ($type eq 'bool') {
            print "  Possible choices:\n";
	    print "   o True: $arg->{'comment_true'}\n";
	    print "   o False: $arg->{'comment_false'}\n";
            if (defined($default)) {
                my $defstr = ($default ? "True" : "False");
                print "  Default: $defstr\n";
            }
            print "  Example: ${boolopt}${booloptleft}${name}" .
		"${booloptequal}True${booloptright}\n";
        } elsif ($type eq 'enum') {
            print "  Possible choices:\n";
            my $exarg;
	    my $havecustomsize = 0;
            for (@{$arg->{'vals'}}) {
                my ($choice, $comment) = ($_->{'value'}, $_->{'comment'});
                print "   o $choice: $comment\n";
		if (($name eq "PageSize") && ($choice eq "Custom")) {
		    $havecustomsize = 1;
		}
                $exarg=$choice;
            }
            if (defined($default)) {
                print "  Default: $default\n";
            }
            print "  Example: ${enumopt}${enumoptleft}${name}" .
		"${enumoptequal}${exarg}${enumoptright}\n";
	    if ($havecustomsize) {
		print $custompagesize;
	    }
        } elsif ($type eq 'int' or $type eq 'float') {
            my ($max, $min) = ($arg->{'max'}, $arg->{'min'});
            my $exarg;
            if (defined($max)) {
                print "  Range: $min <= x <= $max\n";
                $exarg=$max;
            }
            if (defined($default)) {
                print "  Default: $default\n";
                $exarg=$default;
            }
            if (!$exarg) { $exarg=0; }
            print "  Example: ${numopt}${numoptleft}${name}" .
		"${numoptequal}${exarg}${numoptright}\n";
        }

        print "\n";
    }
    
    select STDOUT;
    close KID0 
        or print $logh "Error closing KID0 for docs print\n";
    close STDOUT
        or print $logh "Error closing STDOUT for docs print\n";

    # Finished successfully, inform main process
    close KID_MESSAGE_DOC;
    print KID_MESSAGE_DOC_IN "0 $EXIT_PRINTED\n";
    close KID_NESSAGE_DOC_IN;

    print $logh "KID0 finished\n";
    exit($EXIT_PRINTED);

}



## Close the documentation page generation process and wait until the
## kid process finishes.

sub closedocgeneratorhandle {

    my ($docgeneratorhandle, $docgeneratorpid) = @_;

    print $logh "\nClosing documentation page generator\n";

    # Do it!
    close $docgeneratorhandle;

    # Wait for the kid process to finish or the kid process to fail
    close KID_MESSAGE_DOC_IN;
    while ((!$dockidfailed) &&
	   (!$kid0finished)) {
	my $message = <KID_MESSAGE_DOC>;
	chomp $message;
	if ($message =~ /(\d+)\s+(\d+)/) {
	    my $kid_id = $1;
	    my $exitstat = $2;
	    print $logh "KID$kid_id exited with status $exitstat\n";
	    if ($exitstat > 0) {
		$dockidfailed = $exitstat;
	    } elsif ($kid_id eq "0") {
		$kid0finished = 1;
	    }
	}
    }

    close KID_MESSAGE_DOC;

    # If the kid failed, return the exit stat of the kid
    if ($dockidfailed != 0) {
	$retval = $dockidfailed;
    }

    print $logh "Documentation page generator exit stat: $retval\n";
    # Wait for fileconverter child
    waitpid($docgeneratorpid, 0);
    print $logh "Documentation page generator process finished\n";
    return ($retval);
}



# Find an argument by name in a case-insensitive way
sub argbyname {
    my $name = @_[0];

    my $arg;
    for $arg (@{$dat->{'args'}}) {
        return $arg if (lc($name) eq lc($arg->{'name'}));
    }

    return undef;
}

sub valbyname {
    my ($arg,$name) = @_;

    my $val;
    for $val (@{$arg->{'vals'}}) {
        return $val if (lc($name) eq lc($val->{'value'}));
    }

    return undef;
}

# Write a Good-Bye letter and clean up before committing suicide (send
# error message to caller)

sub rip_die {
    my ($message, $exitstat) = @_;

    # Close the documentation page generator (if it was used)
    if ($docgeneratorpid) {
	if ($kid0) {
	    print $logh "Killing process $pid0 (KID0)\n";
	    kill(9, $kid0);
	}
	$docgeneratorpid = 0;
    }

    # Close the file converter (if it was used)
    if ($fileconverterpid) {
	if ($kid2) {
	    print $logh "Killing process $pid2 (KID2)\n";
	    kill(9, $kid2);
	}
	if ($kid1) {
	    print $logh "Killing process $pid1 (KID1)\n";
	    kill(9, $kid1);
	}
	$fileconverterpid = 0;
    }

    # Close the renderer
    if ($rendererpid) {
	if ($kid4) {
	    print $logh "Killing process $pid4 (KID4)\n";
	    kill(9, $kid4);
	}
	if ($kid3) {
	    print $logh "Killing process $pid3 (KID3)\n";
	    kill(9, $kid3);
	}
	$rendererpid = 0;
    }

    print $logh "Process dieing with \"$message\", exit stat: $exitstat\n";
    if ($spooler eq 'ppr_int') {
	# Special error handling for PPR intefaces
	$message =~ s/\\/\\\\/;
	$message =~ s/\"/\\\"/;
	@messagelines = split("\n", $message);
	my $firstline = "TRUE";
	for $line (@messagelines) {
	    system("lib/alert $printer $firstline \"$line\"");
	    $firstline = "FALSE";
	}
    } else {
	print STDERR $message . "\n";
    }
    exit $exitstat;
}

# Signal handling routines

sub set_exit_prnerr {
    $retval = $EXIT_PRNERR;
}

sub set_exit_prnerr_noretry {
    $retval = $EXIT_PRNERR_NORETRY;
}

sub set_exit_engaged {
    $retval = $EXIT_ENGAGED;
}

# Read the config file

sub readConfFile {
    my ($file) = @_;

    my %conf;
    # Read config file if present
    if (open CONF, "< $file") {
	while (<CONF>)
	{
	    $conf{$1}="$2" if (m/^\s*([^\#\s]\S*)\s*:\s*(.*)\s*$/);
	}
	close CONF;
    }

    return %conf;
}

sub unhtmlify {
    # Replace HTML/XML entities by the original characters
    my $str = $_[0];
    $str =~ s/\&apos;/\'/g;
    $str =~ s/\&quot;/\"/g;
    $str =~ s/\&gt;/\>/g;
    $str =~ s/\&lt;/\</g;
    $str =~ s/\&amp;/\&/g;
    return $str;
}

sub unhexify {
    # Replace hex notation for unprintable characters in PPD files
    # by the actual characters ex: "<0A>" --> chr(hex("0A"))
    my ($input) = @_;
    my $output = "";
    my $hexmode = 0;
    my $firstdigit = "";
    for (my $i = 0; $i < length($input); $i ++) {
	my $c = substr($input, $i, 1);
	if ($hexmode) {
	    if ($c eq ">") {
		# End of hex string
		$hexmode = 0;
	    } elsif ($c =~ /^[0-9a-fA-F]$/) {
		# Hexadecimal digit, two of them give a character
		if ($firstdigit ne "") {
		    $output .= chr(hex("$firstdigit$c"));
		    $firstdigit = "";
		} else {
		    $firstdigit = $c;
		}
	    }
	} else {
	    if ($c eq "<") {
		# Beginning of hex string
		$hexmode = 1;
	    } else {
		# Normal character
		$output .= $c;
	    }
	}
    }
    return $output;
}

sub undossify {
    # Remove "dossy" line ends ("\r\n") from a string
    my ($str) = @_;
    $str =~ s/\r\n/\n/gs;
    $str =~ s/\r$//s;
    return $str;
}

sub checkarg {
    # Check if there is already an argument record $argname in $dat, if
    # create one
    my ($dat, $argname) = @_;
    return if defined($dat->{'args_byname'}{$argname});
    # argument record
    my $rec;
    $rec->{'name'} = $argname;
    # Insert record in 'args' array for browsing all arguments
    push(@{$dat->{'args'}}, $rec);
    # 'args_byname' hash for looking up arguments by name
    $dat->{'args_byname'}{$argname} = $dat->{'args'}[$#{$dat->{'args'}}];
    # Default execution style is 'G' (PostScript) since all arguments for
    # which we don't find "*Foomatic..." keywords are usual PostScript
    # options
    $dat->{'args_byname'}{$argname}{'style'} = 'G';
    # Default prototype for code to insert, used by enum options
    $dat->{'args_byname'}{$argname}{'proto'} = '%s';
    print $logh "Added option $argname\n";
}

sub checksetting {
    # Check if there is already an argument record $argname in $dat, if
    # create one
    my ($dat, $argname, $setting) = @_;
    return if 
	defined($dat->{'args_byname'}{$argname}{'vals_byname'}{$setting});
    # setting record
    my $rec;
    $rec->{'value'} = $setting;
    # Insert record in 'vals' array for browsing all settings
    push(@{$dat->{'args_byname'}{$argname}{'vals'}}, $rec);
    # 'vals_byname' hash for looking up settings by name
    $dat->{'args_byname'}{$argname}{'vals_byname'}{$setting} = 
	$dat->{'args_byname'}{$argname}{'vals'}[$#{$dat->{'args_byname'}{$argname}{'vals'}}];
}

sub removearg {
    # remove the argument record $argname from $dat
    my ($dat, $argname) = @_;
    return if !defined($dat->{'args_byname'}{$argname});
    # Remove 'args_byname' hash for looking up arguments by name
    delete $dat->{'args_byname'}{$argname};
    # Remove argument itself
    for (my $i = 0; $i <= $#{$dat->{'args'}}; $i ++) {
	if ($dat->{'args'}[$i]{'name'} eq $argname) {
	    print $logh "Removing option " .
		$argname . "\n";
	    splice(@{$dat->{'args'}}, $i, 1);
	    last;
	}
    }
}

sub removepsargs {
    # remove all records of PostScript arguments from $dat
    my ($dat) = @_;
    return if !defined($dat);
    for (my $i = 0; $i <= $#{$dat->{'args'}}; $i ++) {
	if ($dat->{'args'}[$i]{'style'} eq 'G') {
	    print $logh "Removing PostScript option " .
		$dat->{'args'}[$i]{'name'} . "\n";
	    # Remove 'args_byname' hash for looking up arguments by name
	    delete $dat->{'args_byname'}{$dat->{'args'}[$i]{'name'}};
	    # Remove argument itself
	    splice(@{$dat->{'args'}}, $i, 1);
	    $i --;
	}
    }
}

sub checkoptionvalue {

    ## This function checks whether a given value is valid for a given
    ## option. If yes, it returns a cleaned value (e. g. always 0 or 1
    ## for boolean options), otherwise "undef". If $forcevalue is set,
    ## we always determine a corrected value to insert (we never return
    ## "undef").

    # Is $value valid for the option named $argname?
    my ($dat, $argname, $value, $forcevalue) = @_;

    # Record for option $argname
    my $arg = $dat->{'args_byname'}{$argname};

    if ($arg->{'type'} eq 'bool') {
	if ((lc($value) eq 'true') ||
	    (lc($value) eq 'on') ||
	    (lc($value) eq 'yes') ||
	    (lc($value) eq '1')) {
	    return 1;
	} elsif ((lc($value) eq 'false') ||
		 (lc($value) eq 'off') ||
		 (lc($value) eq 'no') ||
		 (lc($value) eq '0')) {
	    return 0;
	} elsif ($forcevalue) {
	    # This maps Unknown to mean False.  Good?  Bad?
	    # It was done so in Foomatic 2.0.x, too.
	    my $name = $arg->{'name'};
	    print $logh 
		"The value $value for $name is not a " .
		"choice!\n" .
		" --> Using False instead!\n";
	    return 0;
	}
    } elsif ($arg->{'type'} eq 'enum') {
	if (defined($arg->{'vals_byname'}{$value})) {
	    return $value;
	} elsif ((($arg->{'name'} eq "PageSize") ||
		  ($arg->{'name'} eq "PageRegion")) &&
		 (defined($arg->{'vals_byname'}{'Custom'})) &&
		 ($value =~ m!^Custom\.([\d\.]+)x([\d\.]+)([A-Za-z]*)$!)) {
	    # Custom paper size
	    return $value;
	} elsif ($forcevalue) {
	    # wtf!?  that's not a choice!
	    my $name = $arg->{'name'};
	    # Return the first entry of the list
	    my $firstentry = $arg->{'vals'}[0]{'value'};
	    print $logh 
		"The value $value for $name is not a " .
		"choice!\n" .
		" --> Using $firstentry instead!\n";
	    return $firstentry;
	}
    } elsif (($arg->{'type'} eq 'int') ||
	     ($arg->{'type'} eq 'float')) {
	if (($value <= $arg->{'max'}) &&
	    ($value >= $arg->{'min'})) {
	    return $value;
	} elsif ($forcevalue) {
	    my $name = $arg->{'name'};
	    my $newvalue;
	    if ($value > $arg->{'max'}) {
		$newvalue = $arg->{'max'}
	    } elsif ($value < $arg->{'min'}) {
		$newvalue = $arg->{'min'}
	    }
	    print $logh 
		"PPD default value $value for $name is out of " .
		"range!\n" .
		" --> Using $newvalue instead!\n";
	    return $newvalue;
	}
    }
    return undef;
}

sub checkoptions {

    ## Let the values of a boolean option being 0 or 1 instead of
    ## "True" or "False", range-check the defaults of all options and
    ## issue warnings if the values are not valid

    # Option set to be examined
    my ($dat, $optionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if (defined($arg->{$optionset})) {
	    $arg->{$optionset} =
		checkoptionvalue
		($dat, $arg->{'name'}, $arg->{$optionset}, 1);
	}
    }

    # If the settings for "PageSize" and "PageRegion" are different,
    # set the one for "PageRegion" to the one for "PageSize" and issue
    # a warning.
    if ($dat->{'args_byname'}{'PageSize'}{$optionset} ne
	$dat->{'args_byname'}{'PageRegion'}{$optionset}) {
	print $logh "Seetings for \"PageSize\" and \"PageRegion\" are " .
	    "different:\n" .
	    "   PageSize: $dat->{'args_byname'}{'PageSize'}{$optionset}\n" .
	    "   PageRegion: ".
	    "$dat->{'args_byname'}{'PageRegion'}{$optionset}\n" .
	    "Using the \"PageSize\" value " .
	    "\"$dat->{'args_byname'}{'PageSize'}{$optionset}\"," .
	    " for both.\n";
	$dat->{'args_byname'}{'PageRegion'}{$optionset} =
	    $dat->{'args_byname'}{'PageSize'}{$optionset};
    }
}

# If the PageSize or PageRegion was changed, also change the other

sub syncpagesize {
    
    # Name and value of the option we set, and the option set where we
    # did the change
    my ($dat, $name, $value, $optionset) = @_;

    # Don't do anything if we were called with an option other than
    # "PageSize" or "PageRegion"
    return if (($name ne "PageSize") && ($name ne "PageRegion"));
    
    # Don't do anything if not both "PageSize" and "PageRegion" exist
    return if ((!defined($dat->{'args_byname'}{'PageSize'})) ||
	       (!defined($dat->{'args_byname'}{'PageRegion'})));
    
    my $dest;
    
    # "PageSize" --> "PageRegion"
    if ($name eq "PageSize") {
	$dest = "PageRegion";
    }
    
    # "PageRegion" --> "PageSize"
    if ($name eq "PageRegion") {
	$dest = "PageSize";
    }
    
    # Do it!
    if (my $val=valbyname($dat->{'args_byname'}{$dest}, $value)) {
	# Standard paper size
	$dat->{'args_byname'}{$dest}{$optionset} = $val->{'value'};
    } elsif (my $val=valbyname($dat->{'args_byname'}{$dest}, "Custom")) {
	# Custom paper size
	$dat->{'args_byname'}{$dest}{$optionset} = $value;
    }
}

sub copyoptions {

    ## Copy one option set into another one

    # Source and destination option sets
    my ($dat, $srcoptionset, $destoptionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if (defined($arg->{$srcoptionset})) {
	    $arg->{$destoptionset} = $arg->{$srcoptionset};
	}
    }
}

sub deleteoptions {

    ## Delete an option set

    # option set to be removed
    my ($dat, $optionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if (defined($arg->{$srcoptionset})) {
	    delete($arg->{$optionset});
	}
    }
}

sub optionsequal {

    ## Compare two option sets, if they are equal, return 1, otherwise 0

    # Option sets to be compared
    my ($dat, $firstoptionset, $secondoptionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if ((defined($arg->{$firstoptionset})) &&
	    (defined($arg->{$secondoptionset}))) {
	    # Both entries exist
	    return 0 if $arg->{$firstoptionset} ne $arg->{$secondoptionset};
	} elsif ((defined($arg->{$firstoptionset})) ||
		 (defined($arg->{$secondoptionset}))) {
	    # One entry exists
	    return 0;
	}
	# If no entry exists, the non-existing entries are considered as
	# equal
    }
    return 1;
}

sub makeprologsection {

    # option set to be used,
    # $comments = 1: Add "%%BeginProlog...%%EndProlog"
    my ($dat, $optionset, $comments) = @_;
    
    # Collect data to be inserted here
    my @output;

    # Start comment
    if ($comments) {
	print $logh "\"Prolog\" section is missing, inserting it.\n";
	push(@output, "%%BeginProlog\n");
    }

    # Generate the option code (not necessary when CUPS is spooler)
    if ($spooler ne 'cups') {
	print $logh "Inserting option code into \"Prolog\" section.\n";
	buildcommandline ($dat, $optionset);
	push(@output, @{$dat->{'prologprepend'}});
    }

    # End comment
    if ($comments) {
	push(@output, "%%EndProlog\n");
    }

    return join('', @output);
}

sub makesetupsection {

    # option set to be used, $comments = 1: Add "%%BeginSetup...%%EndSetup"
    my ($dat, $optionset, $comments) = @_;
    
    # Collect data to be inserted here
    my @output;

    # Start comment
    if ($comments) {
	print $logh "\"Setup\" section is missing, inserting it.\n";
	push(@output, "%%BeginSetup\n");
    }

    # PostScript code to generate accounting messages for CUPS
    if ($spooler eq 'cups') {
	print $logh "Inserting PostScript code for CUPS' page accounting\n";
	push(@output, $accounting_prolog);
    }

    # Generate the option code (not necessary when CUPS is spooler)
    if ($spooler ne 'cups') {
	print $logh "Inserting option code into \"Setup\" section.\n";
	buildcommandline ($dat, $optionset);
	push(@output, @{$dat->{'setupprepend'}});
    }

    # End comment
    if ($comments) {
	push(@output, "%%EndSetup\n");
    }

    return join('', @output);
}

sub makepagesetupsection {

    # option set to be used,
    # $comments = 1: Add "%%BeginPageSetup...%%EndPageSetup"
    my ($dat, $optionset, $comments) = @_;
    
    # Collect data to be inserted here
    my @output;

    # Start comment
    if ($comments) {
	push(@output, "%%BeginPageSetup\n");
	print $logh "\"PageSetup\" section is missing, inserting it.\n";
    }

    # Generate the option code (not necessary when CUPS is spooler)
    if ($spooler ne 'cups') {
	print $logh "Inserting option code into \"PageSetup\" section.\n";
	buildcommandline ($dat, $optionset);
	push(@output, @{$dat->{'pagesetupprepend'}});
    }

    # End comment
    if ($comments) {
	push(@output, "%%EndPageSetup\n");
    }

    return join('', @output);
}

sub buildcommandline {

    ## Build a renderer command line, based on the given option set

    # Foomatic data and name of the option set to apply
    my ($dat, $optionset) = @_;

    # Construct the proper command line.
    $dat->{'currentcmd'} = $dat->{'cmd'};
    my @prologprepend;
    my @setupprepend;
    my @pagesetupprepend;
    my @jclprepend;
    my @jclappend;
    my $arg;

    for $arg (sort { $a->{'order'} <=> $b->{'order'} } 
	      @{$dat->{'args'}}) {
	
	my $name = $arg->{'name'};
	my $spot = $arg->{'spot'};
	my $cmd = $arg->{'proto'};
	my $cmdf = $arg->{'protof'};
	my $type = $arg->{'type'};
	my $section = $arg->{'section'};
	my $userval = $arg->{$optionset};
        
	my $cmdvar = "";

	# If we have both "PageSize" and "PageRegion" options, we kept
	# them all the time in sync, so we don't need to insert the settings
	# of both options. So skip "PageRegion".
	next if (($name eq "PageRegion") &&
		 (defined($dat->{'args_byname'}{'PageSize'})) &&
		 (defined($dat->{'args_byname'}{'PageRegion'})));

	# Build the command line snippet/PostScript/JCL code for the current
	# option
	if ($type eq 'bool') {

	    # If true, stick the proto into the command line
	    if (defined($userval) && $userval == 1) {
		$cmdvar = $cmd;
	    } else {
		$cmdvar = $cmdf;
	    }

	} elsif ($type eq 'int' or $type eq 'float') {

	    # If defined, process the proto and stick the result into
	    # the command line or postscript queue.
	    if (defined($userval)) {
		my $min = $arg->{'min'};
		my $max = $arg->{'max'};
		if ($userval >= $min and $userval <= $max) {
		    my $sprintfcmd = $cmd;
		    $sprintfcmd =~ s!\%([^s])!\%\%$1!g;
		    $cmdvar = sprintf($sprintfcmd,
				      ($type eq 'int' 
				       ? sprintf("%d", $userval)
				       : sprintf("%f", $userval)));
		} else {
		    print $logh "Value $userval for $name is out of " .
			"range $min <= x <= $max.\n";
		}
	    }

	} elsif ($type eq 'enum') {

	    # If defined, stick the selected value into the proto and
	    # thence into the commandline
	    if (defined($userval)) {
		# CUPS assumes that options with the choises "Yes", "No",
		# "On", "Off", "True", or "False" are boolean options and
		# maps "-o Option=On" to "-o Option" and "-o Option=Off"
		# to "-o noOption", which cupsomatic maps to "0" and "1".
		# So when "0" or "1" is unavailable in the option, we try
		# "Yes", "No", "On", "Off", "True", and "False".
		my $found = 0;
		my $val;
		if ($val=valbyname($arg,$userval)) {
		    $found = 1;
		} elsif ($userval =~ /^Custom\.[\d\.]+x[\d\.]+[A-Za-z]*$/) {
		    # Custom paper size
		    $val = valbyname($arg,"Custom");
		    $found = 1;
		} elsif ($userval eq '0') {
		    foreach (qw(No Off False None)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		} elsif ($userval eq '1') {
		    foreach (qw(Yes On True)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		} elsif ($userval eq 'LongEdge') {
		    # Handle different names for the choices of the
		    # "Duplex" option
		    foreach (qw(LongEdge DuplexNoTumble)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		} elsif ($userval eq 'ShortEdge') {
		    foreach (qw(ShortEdge DuplexTumble)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		}
		if ($found) {
		    my $sprintfcmd = $cmd;
		    $sprintfcmd =~ s!\%([^s])!\%\%$1!g;
		    $cmdvar = sprintf($sprintfcmd,
				      (defined($val->{'driverval'})
				       ? $val->{'driverval'}
				       : $val->{'value'}));
		    # Custom paper size
		    if ($userval =~ /^Custom\.([\d\.]+)x([\d\.]+)([A-Za-z]*)$/) {
			my $width = $1;
			my $height = $2;
			my $unit = $3;
			# convert width and height to PostScript points
			if (lc($unit) eq "in") {
			    $width *= 72.0;
			    $height *= 72.0;
			} elsif (lc($unit) eq "cm") {
			    $width *= (72.0/2.54);
			    $height *= (72.0/2.54);
			} elsif (lc($unit) eq "mm") {
			    $width *= (72.0/25.4);
			    $height *= (72.0/25.4);
			}
			# Round width and height
			$width =~ s/\.[0-4].*$// or
			    $width =~ s/\.[5-9].*$// and $width += 1;
			$height =~ s/\.[0-4].*$// or
			    $height =~ s/\.[5-9].*$// and $height += 1;
			# Insert width and height into the prototype
			if ($cmdvar =~ /^\s*pop\W/s) {
			    # Custom page size for PostScript printers
			    $cmdvar = "$width $height 0 0 0\n$cmdvar";
			} else {
			    # Custom page size for Foomatic/GIMP-Print
			    $cmdvar =~ s/\%0/$width/ or
				$cmdvar =~ s/(\W)0(\W)/$1$width$2/ or
				$cmdvar =~ s/^0(\W)/$width$1/m or
				$cmdvar =~ s/(\W)0$/$1$width/m or
				$cmdvar =~ s/^0$/$width/m;
			    $cmdvar =~ s/\%1/$height/ or
				$cmdvar =~ s/(\W)0(\W)/$1$height$2/ or
				$cmdvar =~ s/^0(\W)/$height$1/m or
				$cmdvar =~ s/(\W)0$/$1$height/m or
				$cmdvar =~ s/^0$/$height/m;
			}
		    }
		} else {
		    # User gave unknown value?
		    print $logh "Value $userval for $name is not a valid choice.\n";
		}
	    }

	} else {
	    # Ignore unknown option types silently
	}
        
	# Insert the built snippet at the correct place
	if ($arg->{'style'} eq 'G') {
	    # Place this Postscript command onto the prepend queue
	    # for the appropriate section.
	    my $open = "[{\n%%BeginFeature: *$name $userval\n";
	    my $close = "\n%%EndFeature\n} stopped cleartomark\n";
	    if ($section eq "Prolog") {
		push (@prologprepend, "$open$cmdvar$close") if $cmdvar;
	    } elsif (($section eq "AnySetup") ||
		     ($section eq "DocumentSetup")) {
		push (@setupprepend, "$open$cmdvar$close") if $cmdvar;
	    } elsif ($section eq "PageSetup") {
		push (@pagesetupprepend, "$open$cmdvar$close") if $cmdvar;
	    } elsif ($section eq "JCLSetup") {
		# PJL/JCL argument
		$dat->{'jcl'} = 1;
		push (@jclprepend, unhexify($cmdvar)) if $cmdvar;
	    } else {
		push (@setupprepend, "$open$cmdvar$close") if $cmdvar;
	    }
	} elsif ($arg->{'style'} eq 'J') {
	    # JCL argument
	    $dat->{'jcl'} = 1;
	    # put JCL commands onto JCL stack...
	    push (@jclprepend, "\@PJL $cmdvar\n") if $cmdvar;
	} elsif ($arg->{'style'} eq 'C') {
	    # command-line argument

	    # Insert the processed argument in the commandline
	    # just before the spot marker.
	    $dat->{'currentcmd'} =~ s!\%$spot!$cmdvar\%$spot!;
	}
        
    }
    

    ### Tidy up after computing option statements for all of P, J, and
    ### C types:

    ## C type finishing
    # Pluck out all of the %n's from the command line prototype
    my @letters = qw/A B C D E F G H I J K L M Z/;
    for $spot (@letters) {
	# Remove the letter marker from the commandline
	$dat->{'currentcmd'} =~ s!\%$spot!!;
    }

    ## J type finishing
    # Compute the proper stuff to say around the job

    if ((defined($dat->{'jcl'})) && (!$jobhasjcl)) {

	# Stick beginning of job cruft on the front of the jcl stuff...
	unshift (@jclprepend, $jclbegin);

	# Command to switch to the interpreter
	push (@jclprepend, $jcltointerpreter);
	
	# Arrange for JCL RESET command at end of job
	push (@jclappend, $jclend);

	# Put the JCL stuff into the data structure
	@{$dat->{'jclprepend'}} = @jclprepend;
	@{$dat->{'jclappend'}} = @jclappend;
    }

    ## G type finishing
    # Save PostScript options
    @{$dat->{'prologprepend'}} = @prologprepend;
    @{$dat->{'setupprepend'}} = @setupprepend;
    @{$dat->{'pagesetupprepend'}} = @pagesetupprepend;
}



# Emacs tabulator/indentation

### Local Variables:
### tab-width: 8
### perl-indent-level: 4
### End:
