#!@PERL@

# The above Perl path may vary on your system; fix it!!!

my $ripversion='$Revision$';
#'# Fix emacs syntax highlighting

# foomatic-rip is a spooler-independent filter script which takes
# PostScript as standard input and generates the printer's page
# description language (PDL)/raster format as standard output. This
# kind of filter is usually called Raster Image Processor (RIP),
# therefore the name "foomatic-rip".

# Save it in one of the directories of your $PATH, so that it gets
# found when called from the command line (for spooler-less printing),
# link it to spooler-specific directories when you use CUPS or PPR:

#    ln -s /usr/bin/foomatic-rip /usr/lib/cups/filter/
#    ln -s /usr/bin/foomatic-rip /usr/lib/ppr/interfaces/

# Mark this filter world-readable and world-executable (note that most
# spoolers run the print filters as a special user, as "lp", not as
# "root" or as the user who sent the job).

# See http://www.linuxprinting.org/<NOT WRITTEN YET>.html

# ==========================================================================
#
#    User-configurable settings, edit them if needed
#
# ==========================================================================

# What path to use for filter programs and such.  Your printer driver
# must be in the path, as must be the renderer, $enscriptcommand, and
# possibly other stuff.	 The default path is often fine on Linux, but
# may not be on other systems.
#
my $execpath = "/usr/local/bin:/usr/bin:/bin";

# Location of the configuration file "filter.conf", this file can be
# used for settings which should apply to all filters (lpdomatic,
# cupsomatic, ...). 
# This variable must contain the full pathname of the directory which
# contains the configuration file, usually "/etc/foomatic".
my $configpath = "/etc/foomatic";

# For the stuff below, the settings in the configuration file have priority.

# Enter here your personal command for converting non-postscript files
# (especially text) to PostScript. If you leave it blank, at first the
# line "textfilter: ..." from /etc/foomatic/filter.conf is read and
# then the commands given on the list below are tried, beginning with
# the first one.
# You can set this to "a2ps", "enscript" or "mpage" to select one of the 
# default command strings.
my $enscriptcommand = "";

# What 'echo' program to use.  It needs -e and -n.  Linux's builtin
# and regular echo work fine; non-GNU platforms may need to install
# gnu echo and put gecho here or something.
#
my $myecho = 'echo';

# Set debug to 1 to enable the debug logfile for this filter; it will
# appear as defined by $logfile. It will contain status from this
# filter, plus the renderer's stderr output. You can also add a line
# "debug: 1" to your /etc/foomatic/filter.conf to get all your
# Foomatic filters into debug mode.
#
# WARNING: This logfile is a security hole; do not use in production.
my $debug=0;

# This is the location of the debug logfile in case you have enabled
# debugging # above.
my $logfile = "/tmp/foomatic-rip.log";

# End interesting enduser options

# ==========================================================================
#
# foomatic-rip spooler-independent PS->Printer filter (RIP) of Foomatic
#
# Copyright 2002 Grant Taylor <gtaylor@picante.com>
#		 & Till Kamppeter <till.kamppeter@gmx.net>
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2 of the License, or (at your
#  option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#  Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#  USA.
#

# Flush everything immediately.
$|=1;



## Costants used by this filter

# Error codes, as some spooles behave different depending on the reason why
# the RIP failed, we return an error code. As I have only found a table of
# error codes for the PPR spooler. If our spooler is really PPR, these
# definitions get overwritten by the ones of the PPR version currently in
# use.

$EXIT_PRINTED = 0;         # file was printed normally
$EXIT_PRNERR = 1;          # printer error occured
$EXIT_PRNERR_NORETRY = 2;  # printer error with no hope of retry
$EXIT_JOBERR = 3;          # job is defective
$EXIT_SIGNAL = 4;          # terminated after catching signal
$EXIT_ENGAGED = 5;         # printer is otherwise engaged (connection 
                           # refused)
$EXIT_STARVED = 6;         # starved for system resources
$EXIT_PRNERR_NORETRY_ACCESS_DENIED = 7;     # bad password? bad port
                                            # permissions?
$EXIT_PRNERR_NOT_RESPONDING = 8;            # just doesn't answer at all 
                                            # (turned off?)
$EXIT_PRNERR_NORETRY_BAD_SETTINGS = 9;      # interface settings are invalid
$EXIT_PRNERR_NO_SUCH_ADDRESS = 10;          # address lookup failed, may be 
                                            # transient
$EXIT_PRNERR_NORETRY_NO_SUCH_ADDRESS = 11;  # address lookup failed, not 
                                            # transient
$EXIT_INCAPABLE = 50;                       # printer wants (lacks) features
                                            # or resources
# Standard Unix signal names
$SIGHUP = 1;
$SIGINT = 2;
$SIGQUIT = 3;
$SIGKILL = 9;
$SIGTERM = 15;
$SIGUSR1 = 10;
$SIGUSR2 = 12;
$SIGTTIN = 21;
$SIGTTOU = 22;



## Config file

# Read config file if present
%conf = readConfFile("$configpath/filter.conf");

# Get execution path from config file
if ($execpath) {$ENV{'PATH'} = $execpath;}

# Set debug mode
$debug = $conf{debug} if defined(%conf) and defined $conf{debug};



## Some important variables

# We don't know yet, which spooler will be used. If we don't detect one.
# we assume that we do spooler-less printing.
$spooler = 'direct';

# PPD file name
$ppdfile = "";

# Printer queue name
$printer = "";

# Printing options
$optstr = "";

# Job title
$jobtitle = "";

# Post pipe (command into which the output of this filter should be piped)
$postpipe = "";

# Files to be printed
@filelist = ();



## Environment variables;

# "PPD": PPD file name for CUPS
if (defined($ENV{'PPD'})) {
    $ppdfile = $ENV{'PPD'};
    # CUPS uses the "PPD" environment variable to make the PPD file name
    # available
    $spooler = 'cups';
}

# "LPOPTS": Option settings for some LPD implementations (ex: GNUlpr)
if (defined($ENV{'LPOPTS'})) {
    my @lpopts = split(/,/, $ENV{'LPOPTS'});
    foreach $opt (@lpopts) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We have an LPD which accepts "-o" for options
    $spooler = 'gnulpr';
}



## Named command line options

# Save the options for logging
my $origoptions = join("','",@ARGV);

# Read the options
use Getopt::Long;
Getopt::Long::Configure("no_ignore_case");

#          # General
GetOptions("q"        => \$opt_q,         # Quiet
           "v"        => \$opt_v,         # Verbose
	   "debug"    => \$opt_debug,     # Debug mode
	   "p=s"      => \$opt_p,         # PPD file
	   "ppd=s"    => \$opt_ppd,       # PPD file
	   # LPD, LPRng, GNUlpr 
	   "lprng"    => \$opt_lprng,     # Were we called from LPRng?
	   "c"        => \$opt_c,         # (raw printing, not used)
	   "w=s"      => \$opt_w,         # (text width, not used)
	   "l=s"      => \$opt_l,         # (text length, not used)
	   "i=s"      => \$opt_i,         # (indent, not used)
	   "n=s"      => \$opt_n,         # (login, not used)
	   "h=s"      => \$opt_h,         # (host, not used)
	   "j=s"      => \$opt_j,         # Job title (with options stuffed
	                                  # in when LPD is the spooler)_
	   "z=s"      => \$opt_z,         # (not used)
	   "Z=s"      => \$opt_Z,         # Options when LPRng is the
	                                  # spooler
	   # Spooler-less printing
	   "P=s"      => \$opt_P,         # Printer
	   "d=s"      => \$opr_d,         # Printer
	   "o=s"      => \@opt_o,         # Options
	   "J=s"      => \$opt_J,         # Job title
	   );

# Quiet mode, do not log
if (($opt_q) && (!$debug)) {
    open LOG, ">/dev/null";
    $logh = *LOG;

    use IO::Handle;
    $logh->autoflush(1);
}

# Debug mode activated via command line
if ($opt_debug) {
    $debug = 1;
}

# Where to send debugging log output to
if ($debug) {
    # Grotesquely unsecure; use for debugging only
    open LOG, ">$logfile";
    $logh = *LOG;

    use IO::Handle;
    $logh->autoflush(1);
} else {
    $logh=*STDERR;
}

# Start logging
print $logh "foomatic-rip version $ripversion running...\n";
print $logh "called with arguments: '", $origoptions, "'\n";

# PPD file name given via the command line
if ($opt_p) {
    $ppdfile = $opt_p;
}
if ($opt_ppd) {
    $ppdfile = $opt_ppd;
}

# Check for LPD/GNUlpr
if ((defined($opt_h)) || (defined($opt_n)) || (defined($opt_w)) ||
    (defined($opt_l)) || (defined($opt_i))) {
    # We have LPD or GNUlpr
    if (($spooler ne 'lpd') && ($spooler ne 'gnulpr')) {
	$spooler = 'lpd';
    }
}

# Check for LPRng
if ($opt_lprng) {
    # We have LPRng
    $spooler = 'lprng';
}

# LPRng delivers the option settings via the "-Z" argument
if (defined($opt_Z)) {
    my @lpopts = split(/,/, $opt_Z);
    foreach $opt (@lpopts) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We have LPRng
    $spooler = 'lprng';
}

# Job title and options for stock LPD
if (defined($opt_j)) {
    # An LPD
    $jobtitle = $opt_j;
    # Classic LPD hack
    $optstr .= "$opt_j ";
}

# Job title
if (defined($opt_J)) {
    # Spooler-less, perhaps also LPD
    $jobtitle = $opt_J;
}

# Options for spooler-less printing
if ((defined(@opt_o)) && ($#opt_o >= 0)) {
    foreach $opt (@opt_o) {
	$opt =~ s/^\s+//;
	$opt =~ s/\s+$//;
	if ($opt =~ /\s+/) {
	    $opt = "\"$opt\"";
	}
	$optstr .= "$opt ";
    }
    # We print without spooler
    $spooler = 'direct';
}

# Printer for spooler-less printing
if (!defined($opt_P) && (defined($opt_d))) {
    $opt_P = $opt_d;
}
if (defined($opt_P)) {
    $direct_printer = $opt_P;
    $printer = $direct_printer;
    # We print without spooler
    $spooler = 'direct';
}



## Command line options without name

# Check for PPR
if (($ARGV[3] =~ /^\s*\d\d?\s*$/) &&
    ($ARGV[5] =~ /^\s*\d\d?\s*$/) &&
    (($#ARGV == 9) || ($#ARGV == 7)) &&
    ("`pwd`" =~ m!/ppr/?$!)) {
    # PPR calls interfaces with many command line parameters, where
    # the forth and the sixth is a small integer number. In addition,
    # we have 8 (PPR <= 1.31) or 10 (PPR>=1.32) command line parameters.
    # We also check whether the current working directory is a PPR
    # directory.

    # Read interface.sh so we will know the correct exit codes and
    # also signal.sh for the signal codes
    my $pprinstalled = 1; # When one of the files is missing, we assume
                          # that PPR is not installed and our guess
                          # that PPR is the spooler is wrong.
    my @definitions;
    for my $file (("lib/interface.sh", "lib/signal.sh")) {
	
	open FILE, "$file" || do {
	    print $logh "error opening $file.\n";
	    $pprinstalled = 0;
	};
	
	while(my $line = <FILE>) {
	    # Translate the shell script to Perl
	    if (($line !~ m/^\s*$/) && ($line !~ m/^\s*\#/)) {
		$line =~ s/^\s*([^\#\s]*)/\$$1;/;
		push (@definitions, $line);
	    }
	}
	close FILE;
    }

    if ($pprinstalled) {

	# Get all command line parameters
	$ppr_printer = $ARGV[0];
	$ppr_address = $ARGV[1];
	$ppr_options = $ARGV[2];
	$ppr_jobbreak = $ARGV[3];
	$ppr_feedback = $ARGV[4];
	$ppr_codes = $ARGV[5];
	$ppr_jobname = $ARGV[6];
	$ppr_routing = $ARGV[7];
	$ppr_for = $ARGV[8];
	$ppr_filetype = $ARGV[9];

	# Common job parameters
	$printer = $ppr_printer;
	$jobtitle = $ppr_jobname;
	$optstr = "$ppr_options $ppr_routing";

	# Apply  the definitions loaded from PPR
	eval join('',@definitions) || do {
	    print $logh "unable to evaluate definitions\n";
	    rip_die ("Error in definitions evaluation",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	};

	# Get the path of the PPD file from the queue configuration
	$ppdfile = `LANG=en_US; ppad show $ppr_printer | grep PPDFile`;
	$ppdfile =~ s/PPDFile:\s+//;
	if ($ppdfile !~ m!^/!) {
	    $ppdfile = "../../share/ppr/PPDFiles/$ppdfile";
	}

	# We have PPR
	$spooler = 'ppr';
    }
}   

# CUPS
if ($spooler eq 'cups') {
    # Get all command line parameters
    $cups_jobid = $ARGV[0];
    $cups_usr = $ARGV[1];
    $cups_jobtitle = $ARGV[2];
    $cups_copies = $ARGV[3];
    $cups_options = $ARGV[4];
    $cups_filename = $ARGV[5];

    # Common job parameters
    #$printer = $cups_printer;
    $jobtitle = $cups_jobtitle;
    $optstr = $cups_options;

    # Check for and handle inputfile vs stdin
    if ((defined($cups_filename)) && ($cups_filename) &&
	($cups_filename ne '-')) {
	# We get the input from a file
	@filelist = ($cups_filename);
	#print $logh "Getting input from file $cups_filename\n";
	#close STDIN;
	#open STDIN, "< $cups_filename" or
	#    rip_die ("Error opening input file $cups_filename",
	#	     $EXIT_JOBERR);
    }
}

# LPD/LPRng/GNUlpr
if (($spooler eq 'lpd') ||
    ($spooler eq 'lprng') || 
    ($spooler eq 'gnulpr')) {

    # Get PPD file name as the last command line argument
    $ppdfile = $ARGV[$#ARGV];

}

# No spooler
if ($spooler eq 'direct') {
    # Which files do we want to print?
    @filelist = @ARGV;
}



## Additional spooler-specific preparations

# No spooler

if ($spooler eq 'direct') {

    # Path for personal Foomatic configuration
    my $user_default_path = "$ENV{'HOME'}/.foomatic";

    if (!$ppdfile) {
	if (!$printer) {
	    # No printer definition file selected, check whether we have a
	    # default printer defined.
	    for my $conf_file (("./.directconfig",
				"./directconfig",
				"./.config",
				"$user_default_path/directconfig",
				"$user_default_path/direct/.config",
				"$configpath/directconfig",
				"$configpath/direct/.config")) {
		if (open CONFIG, "< $conf_file") {
		    while (my $line = <CONFIG>) {
			chomp $line;
			if ($line =~ /^default\s*:\s*([^:\s]+)\s*$/) {
			    $printer = $1;
			    last;
			}
		    }
		    close CONFIG;
		}
		if (defined($printer)) {
		    last;
		}
	    }
	}

	# Neither in a config file nor on the command line a printer was
	# selected.
	if (!defined($opt_P)) {
	    rip_die("No printer definition (option \"-P <name>\") " .
		    "specified!", $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
	
	# Search the PPD file
	
	# Search also common spooler-specific locations, this way a printer
	# configured under a certain spooler can also be used without
	# spooler
	if (-r $printer) {
	    $ppdfile = $printer;
	} elsif (-r "${printer}.ppd") { # current dir
	    $ppdfile = "${printer}.ppd";
	} elsif (-r "$user_default_path/${printer}.ppd") { # user dir
	    $ppdfile = "$user_default_path/${printer}.ppd";
	} elsif (-r "$configpath/${printer}.ppd") { # system dir
	    $ppdfile = "$configpath/${printer}.ppd";
	} elsif (-r "/etc/cups/ppd/${printer}.ppd") { # CUPS config dir
	    $ppdfile = "/etc/cups/ppd/${printer}.ppd";
	} elsif (-r "/usr/local/etc/cups/ppd/${printer}.ppd") {
	    $ppdfile = "/usr/local/etc/cups/ppd/${printer}.ppd";
	} elsif (-r "/usr/share/ppr/PPDFiles/${printer}.ppd") { # PPR PPDs
	    $ppdfile = "/usr/share/ppr/PPDFiles/${printer}.ppd";
	} elsif (-r "/usr/local/share/ppr/PPDFiles/${printer}.ppd") {
	    $ppdfile = "/usr/local/share/ppr/PPDFiles/${printer}.ppd";
	} else {
	    rip_die ("There is no readable PPD file for the printer " .
		     "$printer, is it configured?",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	}
    }
}



## Files to be printed (can be more than one for spooler-less printing)

# Empty file list -> print STDIN
if ($#filelist < 0) {
    @filelist = ("<STDIN>");
}

# Check file list
my $file;
my $filecnt = 0;
for $file (@filelist) {
    if ($file ne "<STDIN>") {
	if ($file =~ /^-/) {
	    rip_die ("Invalid argument: $file",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	} elsif (! -r $file) {
	    print $logh "File $file does not exist/is not readable\n";
	    splice(@{$dat->{'args'}}, $filecnt, 1);
	    $filecnt --;
	}
    }
    $filecnt ++;
}



## Summary for debugging
print $logh "\nParameter Summary\n";
print $logh "-----------------\n\n";
print $logh "Spooler: $spooler\n";
print $logh "Printer: $printer\n";
print $logh "PPD file: $ppdfile\n";
print $logh "Options: $optstr\n";
print $logh "Job title: $jobtitle\n";
print $logh "File(s) to be printed:\n @filelist\n\n";



## PPD file

# Load the PPD file and build a data structure for the renderer's
# command line and the options
open PPD, "$ppdfile" || do {
    print $logh "error opening $ppdfile.\n";
    rip_die ("Unable to open PPD file $ppdfile",
	     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
};

print $logh "Parsing PPD file ...\n";

my $dat = {};              # data structure for the options
my $currentargument = "";  # We are currently reading this argument

# Parse the PPD file
while(<PPD>) {
    # Parse keywords
    if (m!^\*FoomaticRIPPostPipe:\s*\"(.*)$!) {
	# "*FoomaticRIPPostPipe: <code>"
	my $line = $1;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $cmd = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$cmd .= substr($line, 0, -2);
	    } else {
		# line ends here
		$cmd .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$cmd .= $1;
	$postpipe = unhtmlify($cmd);
    } elsif (m!^\*FoomaticRIPCommandLine:\s*\"(.*)$!) {
	# "*FoomaticRIPCommandLine: <code>"
	my $line = $1;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $cmd = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$cmd .= substr($line, 0, -2);
	    } else {
		# line ends here
		$cmd .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$cmd .= $1;
	$dat->{'cmd'} = unhtmlify($cmd);
    } elsif (m!^\*CustomPageSize\s+True:\s*\"(.*)$!) {
	# "*CustomPageSize True: <code>"
	my $argname = "PageSize";
	my $setting = "Custom";
	my $translation = "Custom Size";
	my $line = $1;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Make sure that the setting is in the data structure
	checksetting ($dat, $argname, $setting);
	$dat->{'args_byname'}{$argname}{'vals_byname'}{$setting}{'comment'} = $translation;
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($code !~ m!^%% FoomaticRIPOptionSetting!m) {
	    $dat->{'args_byname'}{$argname}{'vals_byname'}{$setting}{'driverval'} = $code;
	}
    } elsif (m!^\*OpenUI\s+\*([^:]+):\s*(\S+)\s*$!) {
	# "*OpenUI *<option>[/<translation>]: <type>"
	my $argnametrans = $1;
	my $argtype = $2;
	my $argname;
	my $translation = "";
	if ($argnametrans =~ m!^([^:/\s]+)/([^:]*)$!) {
	    $argname = $1;
	    $translation = $2;
	} else {
	    $argname = $argnametrans;
	}
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'comment'} = $translation;
	# Set the argument type only if not defined yet, a
	# definition in "*FoomaticRIPOption" has priority
	if (!defined($dat->{'args_byname'}{$argname}{'type'})) {
	    if ($argtype eq "PickOne") {
		$dat->{'args_byname'}{$argname}{'type'} = 'enum';
	    } elsif ($argtype eq "PickMany") {
		$dat->{'args_byname'}{$argname}{'type'} = 'pickmany';
	    } elsif ($argtype eq "Boolean") {
		$dat->{'args_byname'}{$argname}{'type'} = 'bool';
	    }
	}
	# Mark in which argument we are currently, so that we can find
	# the entries for the choices
	$currentargument = $argname;
    } elsif (m!^\*CloseUI:\s+\*([^:/\s]+)\s*$!) {
	# "*CloseUI *<option>"
	my $argname = $1;
	# Unmark the current argument to do not mis-interpret any keywords
	# as choices
	$currentargument = "";
    } elsif ((m!^\*FoomaticRIPOption ([^/:\s]+):\s*(\S+)\s+(\S+)\s+(\S)\s*$!) ||
	     (m!^\*FoomaticRIPOption ([^/:\s]+):\s*(\S+)\s+(\S+)\s+(\S)\s+(\S+)\s*$!)){
	# "*FoomaticRIPOption <option>: <type> <style> <spot> [<order>]"
	# <order> only used for 1-choice enum options
	my $argname = $1;
	my $argtype = $2;
	my $argstyle = $3;
	my $spot = $4;
	my $order = $5;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'type'} = $argtype;
	if ($argstyle eq "PS") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'G';
	} elsif ($argstyle eq "CmdLine") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'C';
	} elsif ($argstyle eq "JCL") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'J';
	    $dat->{'pjl'} = 1;
	} elsif ($argstyle eq "Collective") {
	    $dat->{'args_byname'}{$argname}{'style'} = 'X';
	}
	$dat->{'args_byname'}{$argname}{'spot'} = $spot;
	# $order only defined here for 1-choice enum options
	if ($order) {
	    $dat->{'args_byname'}{$argname}{'order'} = $order;
	}
    } elsif (m!^\*FoomaticRIPOptionPrototype\s+([^/:\s]+):\s*\"(.*)$!) {
	# "*FoomaticRIPOptionPrototype <option>: <code>"
	# Used for numerical options only
	my $argname = $1;
	my $line = $2;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the value
	# Code string can have multiple lines, read all of them
	my $proto = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$proto .= substr($line, 0, -2);
	    } else {
		# line ends here
		$proto .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$proto .= $1;
	$dat->{'args_byname'}{$argname}{'proto'} = unhtmlify($proto);
    } elsif (m!^\*FoomaticRIPOptionRange\s+([^/:\s]+):\s*(\S+)\s+(\S+)\s*$!) {
	# "*FoomaticRIPOptionRange <option>: <min> <max>"
	# Used for numerical options only
	my $argname = $1;
	my $min = $2;
	my $max = $3;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'min'} = $min;
	$dat->{'args_byname'}{$argname}{'max'} = $max;
    } elsif (m!^\*OrderDependency:\s*(\S+)\s+(\S+)\s+\*([^:/\s]+)$!) {
	# "*OrderDependency: <order> <section> *<option>"
	my $order = $1;
	my $section = $2;
	my $argname = $3;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the values
	$dat->{'args_byname'}{$argname}{'order'} = $order;
	$dat->{'args_byname'}{$argname}{'section'} = $section;
    } elsif (m!^\*Default([^/:\s]+):\s*([^/:\s]+)\s*$!) {
	# "*Default<option>: <value>"
	my $argname = $1;
	my $default = $2;
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Store the value
	$dat->{'args_byname'}{$argname}{'default'} = $default;
    } elsif (m!^\*$currentargument\s+([^:]+):\s*\"(.*)$!) {
	# "*<option> <choice>[/<translation>]: <code>"
	my $settingtrans = $1;
	my $line = $2;
	my $translation = "";
	if ($settingtrans =~ m!^([^:/\s]+)/([^:]*)$!) {
	    $setting = $1;
	    $translation = $2;
	} else {
	    $setting = $settingtrans;
	}
	# Make sure that the argument is in the data structure
	checkarg ($dat, $currentargument);
	# Make sure that the setting is in the data structure (enum options)
	my $bool =
	    ($dat->{'args_byname'}{$currentargument}{'type'} eq 'bool');
	if ($bool) {
	    if (lc($setting) eq "true") {
		$dat->{'args_byname'}{$currentargument}{'comment'} =
		    $translation;
	    } else {
		$dat->{'args_byname'}{$currentargument}{'comment_false'} =
		    $translation;
	    }
	} else {
	    checksetting ($dat, $currentargument, $setting);
	    $dat->{'args_byname'}{$currentargument}{'vals_byname'}{$setting}{'comment'} = $translation;
	}
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($code !~ m!^%% FoomaticRIPOptionSetting!) {
	    if ($bool) {
		if (lc($setting) eq "true") {
		    $dat->{'args_byname'}{$currentargument}{'proto'} = $code;
		} else {
		    $dat->{'args_byname'}{$currentargument}{'protof'} = $code;
		}
	    } else {
		$dat->{'args_byname'}{$currentargument}{'vals_byname'}{$setting}{'driverval'} = $code;
	    }
	}
    } elsif ((m!^\*FoomaticRIPOptionSetting\s+([^/:=\s]+)=([^/:=\s]+):\s*\"(.*)$!) ||
	     (m!^\*FoomaticRIPOptionSetting\s+([^/:=\s]+):\s*\"(.*)$!)) {
	# "*FoomaticRIPOptionSetting <option>[=<choice>]: <code>"
	# For boolean options <choice> is not given
	my $argname = $1;
	my $setting = $2;
	my $line = $3;
	my $bool = 0;
	if (!$line) {
	    $line = $setting;
	    $bool = 1;
	}
	# Make sure that the argument is in the data structure
	checkarg ($dat, $argname);
	# Make sure that the setting is in the data structure (enum options)
	if (!$bool) {
	    checksetting ($dat, $argname, $setting);
	}
	# Store the value
	# Code string can have multiple lines, read all of them
	my $code = "";
	while ($line !~ m!\"!) {
	    if ($line =~ m!&&$!) {
		# line continues in next line
		$code .= substr($line, 0, -2);
	    } else {
		# line ends here
		$code .= "$line\n";
	    }
	    # Read next line
	    $line = <PPD>;
	    chomp $line;
	}
	$line =~ m!^([^\"]*)\"!;
	$code .= $1;
	if ($bool) {
	    $dat->{'args_byname'}{$argname}{'proto'} = unhtmlify($code);
	} else {
	    $dat->{'args_byname'}{$argname}{'vals_byname'}{$setting}{'driverval'} = unhtmlify($code);
	}
    } elsif (m!^\*CloseUI:\s+\*([^:/\s]+)\s*$!) {
	# "*CloseUI: *<option>"
	my $argname = $1;
	# Unmark the current argument to do not mis-interpret any keywords
	# as choices
	$currentargument = "";
    }
}
close PPD;



## Remove PostScript options, they do not need to be treated by this
## program, they are treated by the spooler-specific filter or by the
## spooler itself.

removepsargs($dat);

my $dontparse = 0;
if ((!defined(@{$dat->{'args'}})) ||
    ($#{$dat->{'args'}} < 0)) {
    # We have no Foomatic options, so we do not need to parse the
    # PostScript data
    $dontparse = 1;
}

# Was the RIP command line defined in the PPD file? If not, we assume a
# PostScript printer and do not render/translate the input data
if (!defined($dat->{'cmd'})) {
    $dat->{'cmd'} = "cat%A%B%C%D%E%F%G%H%I%J%K%L%M%Z";
}



## Let the default value of a boolean option being 0 or 1 instead of
## "True" or "False", range-check the defaults of all options and
## issue warnings if the values are not valid

checkoptions($dat, 'default');



## TODO: Parse options from command line ($optstr)



## Set the $postpipe

# Set up PPR backend.
if ($spooler eq 'ppr') {
    # Put the backend interface into the $postpipe
    $postpipe = "| ( interfaces/$backend \"$ppr_printer\" ".
	"\"$ppr_address\" \"" . join(" ",@backendoptions) .
	"\" \"$ppr_jobbreak\" \"$ppr_feedback\" " .
	"\"$ppr_codes\" \"$ppr_jobname\" \"$ppr_routing\" " .
	"\"$ppr_for\" \"\" )";
}

if ($spooler eq 'cups') {
    # No $postpipe for CUPS, even if one is defined in the PPD file
    $postpipe = "";
}



## Open debug output file
if ($debug) {
    open DRIVERINPUT, "> /tmp/prnjob"
	or rip_die ("error opening /tmp/prnjob",
		    $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
}
    


## From here on we have to repeat all the rest of the program for
## every file to print

for $file (@filelist) {

    print $logh "
================================================

File: $file

================================================

";



    ## If we do not print standard input, open the file to print
    if ($file ne "<STDIN>") {
        close STDIN;
        open STDIN, "< $file" ||
            die "Cannot open $file";
    }



    ## First, for arguments with a default, stick the default in as
    ## the initial value for the "header" option set, this option set
    ## consists of the PPD defaults and the options set in the header
    ## part of the PostScript file (all before the first page begins).

    copyoptions($dat, 'default', 'header');



    ## Next, examine the PostScript job for traces of command-line and
    ## PJL options. The spooler-specific Foomatic filter and filters
    ## of the spooler stuff the settings directly into the file, they
    ## do not send PPD options by the command line.

    # Examination strategy: read lines from STDIN until the first
    # %%Page: comment appears and save them as $psheader. This is the
    # page-independent header part of thr PostScript file. The
    # PostScript interpreter (renderer) must execute this part once
    # before rendering any assortment of pages. Then pages can be
    # printed in any arbitrary selection or order. All option
    # settings we find here will be collected in the default option
    # set for the RIP command line.

    # Now the pages will be read and sent to the renderer, one after
    # the other. Every page is read into memory until the
    # %%EndPageSetup comment appears. So we can get option settings
    # only valid for this page. If we have such settings we set them
    # in the modified command set for this page.

    # If the renderer is not running yet (first page) we start it with
    # the command line built from the current modified command set and
    # send the first page to it, in the end we leave the renderer
    # running and keep input and output pipes open, so that it can
    # accept further pages. If the renderer is still running from
    # the previous page and the current modified command set is the
    # same as the one for the previous page, we send the page. If
    # the command set is different, we close the renderer, re-start
    # it with the command line built from the new modified command
    # set, send the header again, and then the page.

    # After the last page the trailer (%%Trailer) is sent.

    # The output pipe of this program stays open all the time so that
    # the spooler does not assume that the job has finished when the
    # renderer # is re-started.

    # Non DSC-conforming documents will be read until a certain line
    # number is reached. Command line or JCL options inserted later
    # will # be ignored.

    print $logh "Reading PostScript input ...\n";
    my $maxlines = 1000;            # Maximum number of lines to be read
                                    # when the documenent is not
                                    # DSC-conforming. "$maxlines = 0"
                                    # means that all will be read
                                    # and examined. If it is
                                    # discovered that the input file
                                    # is DSC-conforming, this will
                                    # be set to 0.

    my $maxlinestopsstart = 200;    # That many lines are allowed until the
                                    # "%!" indicating PS comes. These
                                    # additional lines in the
                                    # beginning are usually JCL
                                    # commands. The lines will be
                                    # ignored by our parsing but
                                    # passed through.

    my $maxlinesforpageoptions=200; # Unfortunately, CUPS does not bracket
                                    # "PageSetup" option with
                                    # "%%BeginPageSetup" and
                                    # "%%EndPageSetup", so the options
                                    # can simply stand after the
                                    # page header and before the
                                    # page code, without special
                                    # marking. So buffer this amount
                                    # of lines before printing the
                                    # page to check for options.

    my $maxnondsclinesinheader=1000; # If there is a block of more lines
                                    # than this in the document
                                    # header which is not in the
                                    # "%%BeginProlog...%%EndProlog"
                                    # or
                                    # "%%BeginSetup...%%EndSetup"
                                    # sections, the document is not
                                    # considered as DSC-conforming
                                    # and the rest gets passed
                                    # through to the renderer without
                                    # further parsing for options.

    my $nondsclines = 0;            # Amount of lines found which are not in
                                    # a section (see 
                                    # $maxnondsclinesinheader).

    my $nonpslines = 0;             # lines before "%!" found yet.

    my $more_stuff = 1;             # there is more stuff in stdin.

    my $linect = 0;                 # how many lines have we examined?

    my $onelinebefore = "";         # The line before the current line
                                    # (Non-DSC comments are ignored)

    my $twolinesbefore = "";        # The line two lines before the current 
                                    # line (Non-DSC comments are ignored)

    my @psheader;                   # The header of the PostScript file, 
                                    # to be sent after each start of the
                                    # renderer

    my @psfifo;                     # The input FIFO, data which we have
                                    # pulled from stdin for examination,
                                    # but not sent to the renderer yet.

    my $passthru = 0;               # 0: write data into $psfifo; 1: pass
                                    # data directly to the renderer

    my $isdscjob = 0;               # Is the job DSC conforming

    my $inheader = 1;               # Are we still in the header, before
                                    # first "%%Page:" comment?

    my $optionset = 'header';       # Where do the option settings, which 
                                    # we have found, go?

    my $nestinglevel = 0;           # Are we in the main document (0) or
                                    # in an embedded document bracketed by
                                    # "%%BeginDocument" and "%%EndDocument"
                                    # (>0) We do not parse the PostScript
                                    # in an embedded document.

    my $inpageheader = 0;           # Are we in the header of a page,
                                    # between "%%BeginPageSetup" and
                                    # "%%EndPageSetup" (1) or not (0).

    my $lastpassthru = 0;           # State of $passthru in previous line
                                    # (to allow debug output when $passthru
                                    # switches.

    my $ignorepageheader = 0;       # Will be set to 1 as soon as active 
                                    # code (not between "%%BeginPageSetup" 
                                    # and "%%EndPageSetup") appears after a
                                    # "%%Page:" comment. In this case
                                    # "%%BeginPageSetup" and
                                    # "%%EndPageSetup" is not allowed any 
                                    # more on this page and will be ignored.
                                    # Will be set to 0 when a new "%%Page:" 
                                    # comment appears.

    my $printprevpage = 0;          # We set this when encountering
                                    # "%%Page:" and the previous page is not
                                    # printed yet. Then it will printed and 
                                    # the new page will be prepared in the
                                    # next run of the loop (we don't read a
                                    # new line and don't increase the
                                    # $linect then).

    my $rendererhandle;             # File handle to the renderer process\

    my $rendererpid = 0;            # PID of the renderer process

    my $prologfound = 0;            # Did we find the
                                    # "%%BeginProlog...%%EndProlog" section?

    my $setupfound = 0;             # Did we find the
                                    # "%%BeginSetup...%%EndSetup" section?

    my $inprolog = 0;               # We are between "%%BeginProlog" and
                                    # "%%EndProlog".

    my $insetup = 0;                # We are between "%%BeginSetup" and
                                    # "%%EndSetup".

    my $infeature = 0;              # We are between "%%BeginFeature" and
                                    # "%%EndFeature".

    my $nondsclines = 0;            # Number of subsequent lines found which
                                    # are at a non-DSC-conforming place,
                                    # between the sections of the header.

    if ($dontparse) {
	# We do not parse the PostScript to find Foomatic options, we check
	# only whether we have PostScript.
	$maxlines = 1;
    }

    my $line;                       # Line to be read from stdin
    do {
	my $ignoreline = 0;         # Comment line to be ignored when
	                            # determining the last active line 
	                            # and the one before the last

	if (($printprevpage) || ($line=<STDIN>)) {

	    # Debug output
	    if (($debug) && (!$printprevpage)) {
		print DRIVERINPUT $line;
	    }

	    if ($linect == $nonpslines) {
		# In the beginning should be the postscript leader,
                # sometimes after some JCL commands
		if ($line !~ m/^.?%!/) { # There can be a Windows control 
		                         # char before "%!"
		    $nonpslines ++;
		    if ($maxlines == $nonpslines) {
			$maxlines ++;
		    }
		    if ($nonpslines > $maxlinestopsstart) {
			rip_die
			    ('Job does not start with "%!", ' . 
			     'is it PostScript?',
			     $EXIT_JOBERR);
		    }
		} else {
		    # Do we have a DSC-conforming document?
		    if (($line =~ m/^.?%!PS-Adobe-/) && 
			($line !~ m/EPSF/)) {
			# Do not stop parsing the document
			if (!$dontparse) {
			    $maxlines = 0;
			    $isdscjob = 1;
			}
			print $logh 
			    "--> This document is DSC-conforming!\n";
		    }
		}
	    } else {
		if ($line =~ m/\%\%BeginDocument[: ]/) {
		    # Beginning of an embedded document
		    # Note that Adobe Acrobat has a bug and so uses
		    # "%%BeginDocument " instead of "%%BeginDocument:"
		    $nestinglevel ++;
		    print $logh "Embedded document, " .
			"nesting level now: $nestinglevel\n";
		} elsif (($line =~ m/\%\%EndDocument/) &&
			 ($nestinglevel > 0)) {
		    # End of an embedded document
		    $nestinglevel --;
		    print $logh "End of Embedded document, " .
			"nesting level now: $nestinglevel\n";
		} elsif (($line =~ m/\%\%BeginProlog/) &&
			 ($nestinglevel == 0)) {
		    # Beginning of Prolog
		    $prologfound = 1;
		    $inprolog = 1;
		    $nondsclines = 0;
		    # Push options for "Prolog" onto $psfifo here
		} elsif (($line =~ m/\%\%EndProlog/) &&
			 ($nestinglevel == 0)) {
		    # End of Prolog
		    $inprolog = 0;
		} elsif (($line =~ m/\%\%BeginSetup/) &&
			 ($nestinglevel == 0)) {
		    # Beginning of Setup
		    $setupfound = 1;
		    $insetup = 1;
		    $nondsclines = 0;
		    # If there was no "Prolog" but there are options for
		    # the "Prolog", push a "Prolog" with these options onto
		    # the $psfifo here
		    if (!$prologfound) {
			# TODO: Insert prolog
			# Now we have a "Prolog"
			$prologfound = 1;
		    }
		    # Push options for "DocumentSetup" or "AnySetup" onto
		    # $psfifo here
		} elsif (($line =~ m/\%\%EndSetup/) &&
			 ($nestinglevel == 0)) {
		    # End of Setup
		    $insetup = 0;
		} elsif (($line =~ m/\%\%Page:(.*)$/) &&
			 ($nestinglevel == 0)) {
		    if ((!$lastpassthru) && (!$inheader)) {
			# In the last line we were not in passthru mode,
			# so the last page is not printed. Prepare to do
			# it now.
			$printprevpage = 1;
			# Print the previous page
			$passthru = 1;
			print $logh "New page found but previous not " . 
			    "printed, print it now.\n";
		    } else {
			# The previous page is printed, so we can prepare
			# the current one
			$printprevpage = 0;
			print $logh "\n-----------\nNew page: $1\n";
			# Here begins a new page
			if ($inheader) {
			    # If there was no "Prolog" but there are
			    # options for the "Prolog", push a "Prolog"
			    # with these options onto the $psfifo here
			    if (!$prologfound) {
				# TODO: Insert prolog
				# Now we have a "Prolog"
				$prologfound = 1;
			    }
			    # If there was no "Setup" but there are
			    # options for the "Setup", push a "Setup"
			    # with these options onto the $psfifo here
			    if (!$setupfound) {
				# TODO: Insert setup
				# Now we have a "setup"
				$setupfound = 1;
			    }
			    # The first page starts, so the header ends
			    $inheader = 0;
			    $nondsclines = 0;
			    # Option setting should go into the
			    # page-specific option set now
			    $optionset = 'currentpage';
			} else {
			    # Save the option settings of the previous page
			    copyoptions($dat, 'currentpage',
					'previouspage');
			    deleteoptions($dat, 'currentpage');
			}
			# Initialize the option set
			copyoptions($dat, 'header', 'currentpage');
			# Now the page header comes, so buffer the data,
			# because we must perhaps shut down and restart 
			# the renderer
			$passthru = 0;
			$ignorepageheader = 0;
		    }
		} elsif (($line =~ m/\%\%BeginPageSetup/) &&
			 ($nestinglevel == 0) &&
			 (!$ignorepageheader))  {
		    # Start of the page header, up to %%EndPageSetup
		    # nothing of the page will be drawn, page-specific
		    # option settngs (as letter-head paper for page 1)
		    # go here
		    $passthru = 0;
		    $inpageheader = 1;		
		} elsif (($line =~ m/\%\%EndPageSetup/) &&
			 ($nestinglevel == 0) &&
			 (!$ignorepageheader)) {
		    # End of the page header, the page is ready to be
		    # printed
		    print $logh "End of page header\n";
		    $passthru = 1;
		    $inpageheader = 0;
		} elsif ((($line =~ m/\%\%(BeginFeature):\s+\*?([^\s=]+)\s+(\S[^\r\n]*)\r?\n?$/) ||
			  ($line =~ m/\%\%\s*(FoomaticRIPOptionSetting):\s*([^\s=]+)\s*=\s*(\S[^\r\n]*)\r?\n?$/)) &&
			 ($nestinglevel == 0) && 
			 ((!$passthru) || (!$isdscjob))) {
		    my ($linetype, $option, $value) = ($1, $2, $3);
		    
		    # Mark that we are in a "Feature" section
		    if ($linetype eq 'BeginFeature') {
			$infeature = 1;
		    }
		    
		    # OK, we have an option.  If it's not a
		    # *ostscript-style option (ie, it's command-line or
		    # PJL) then we should note that fact, since the
		    # attribute-to-filteroption passing in CUPS is kind of
		    # funky, especially wrt boolean options.  

		    print $logh "Found: $line";
		    if ($arg=argbyname($option)) {
			print $logh "   Option: $option=$value";
			if ($arg->{'style'} ne 'G') {
			    print $logh " --> Setting option\n";
			    if ($arg->{'type'} eq 'bool') {
				# Boolean options are 1 or 0
				if ($value eq 'True') {
				    $arg->{$optionset} = 1;
				} elsif ($value eq 'False') {
				    $arg->{$optionset} = 0;
				} else {
				    print $logh "job contained boolean " .
					"option with neither True nor " .
					"False value!?";
				}
			    } elsif (($arg->{'type'} eq 'enum') ||
				     ($arg->{'type'} eq 'int') ||
				     ($arg->{'type'} eq 'float')) {
				# enum options go as the value, unless 
				# they were Unknown...
				# Same with numerical options.
				
				if (lc($value) eq 'unknown') {
				    # Ignore "unknown" settings
				    #$arg->{$optionset} = undef;
				} else {
				    if ((($option eq 'PageSize') ||
					 ($option eq 'PageRegion')) &&
					($value =~ /^Custom/)) {
					if ($linetype eq 'FoomaticRIPOptionSetting') {
					    $twolinesbefore =~
						/^\s*([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)\s*$/;
					    my ($w, $h) = ($1, $2);
					    if (($w) && ($h) && 
						($w != 0) && ($h != 0)) {
						$arg->{$optionset} =
						    "$value.$wx$h";
					    }
					}
				    } else {
					$arg->{$optionset} = $value;
				    }
				}
			    }
			} else {
			    # it is a postscript style option, presuemably
			    # all applied for us and such...
			    print $logh 
				" --> Option will be set by PostScript " .
				"interpreter\n";
			}
		    } else {
			# This option is unknown to us.  WTF?
			print $logh "unknown option $option=$value found " .
			    "in the job\n";
		    }
		} elsif (($line =~ m/\%\%EndFeature/) &&
			 ($nestinglevel == 0)) {
		    # End of Feature
		    $infeature = 0;
		} elsif (($line =~ m/^\s*\%/) || ($line =~ m/^\s*$/)) {
		    # This is an unknown PostScript comment or a blank line,
		    # no active code
		    $ignoreline = 1;
		} else {
		    # This line is active PostScript code
		    if ($inheader) {
			if ((!$inprolog) && (!$insetup)) {
			    # Outside the "Prolog" and "Setup" section
			    # a correct DSC-conforming document has no
			    # active PostScript code, so consider the
			    # file as non-DSC-conforming when there are
			    # too many of such lines.
			    $nondsclines ++;
			    if ($nondsclines > $maxnondsclinesinheader) {
				# Consider document as not DSC-conforming
				print $logh "This job seems not to be " .
				    "DSC-conforming, DSC-comment for " .
				    "next section not found, stopping " .
				    "to parse the rest, passing it " .
				    "directly to the renderer.\n";
				# Stop scanning for further option settings
				$maxlines = 1;
				$isdscjob = 0;
			    }
			}
		    } else {
			if (!$inpageheader) {
			    # PostScript code inside a page, but not between
			    # "%%BeginPageSetup" and "%%EndPageSetup", so 
			    # we are perhaps already drawing onto a page now
			    if ($onelinebefore =~ m/\%\%Page:/) {
				print $logh "No page header or page " .
				    "header not DSC-conforming\n";
			    }
			    # Stop buffering lines to search for options 
			    # placed not DSC-conforming
			    if (scalar(@psfifo) >= 
				$maxlinesforpageoptions) {
				$passthru = 1;
				# If there comes a page header now, ignore 
				# it
				$ignorepageheader = 1;
			    }
			}
		    }
		}
	    }
	    
	    # Debug info
	    if ($lastpassthru != $passthru) {
		if ($passthru) {
		    print $logh "Found:\n   $twolinesbefore" .
			"   $onelinebefore   $line" . 
			" --> Output goes directly to the renderer now.\n";
		} else {
		    print $logh "Found:\n   $twolinesbefore" .
			"   $onelinebefore   $line" . 
			" --> Output goes to the FIFO buffer now.\n";
		}
	    }

	    # Store or send the current line
	    if (($inheader) && ($isdscjob)) {
		# We are still in the PostScript header, collect all lines 
		# in $psheader
		push (@psheader, $line);
	    } else {
		if (($passthru) && ($isdscjob)) {
		    if (!$lastpassthru) {
			# We enter passthru mode with this line, so the
			# command line can have changed, check it and
			# close the renderer if needed
			if (($rendererpid) &&
			    (!optionsequal($dat, 'currentpage',
					   'previouspage'))) {
			    print $logh "Command line/JCL options " .
				"changed, restarting renderer\n";
			    $retval = closerendererhandle
				($rendererhandle, $rendererpid);
			    if ($retval != $EXIT_PRINTED) {
				rip_die ("Error closing renderer",
					 $retval);
			    }
			    $rendererpid = 0;
			}
		    }
		    # Flush $psfifo and send line directly to the renderer
		    if (!$rendererpid) {
			# No renderer running, start it
			($rendererhandle, $rendererpid) =
			    getrendererhandle
			    ($dat, join('', @psheader, @psfifo));
			if ($retval != $EXIT_PRINTED) {
			    rip_die ("Error opening renderer",
				     $retval);
			}
			# $psfifo is sent out, flush it.
			@psfifo = ();
		    }
		    if ($#psfifo >= 0) {
			# Send $psfifo to renderer
			print $rendererhandle join('', @psfifo);
			# flush $psfifo
			@psfifo = ();
		    }
		    # Send line to renderer
		    if (!$printprevpage) {
			print $rendererhandle $line;
		    }
		} else {
		    # Push the line onto the stack for later spitting up...
		    push (@psfifo, $line);
		}
	    }
	    
	    if (!$printprevpage) {
		$linect++;
	    }

	} else {
	    # EOF!
	    $more_stuff = 0;
	}

	$lastpassthru = $passthru;
	
	if ((!$ignoreline) && (!$printprevpage)) {
	    $twolinesbefore = $onelinebefore;
	    $onelinebefore = $line;
	}

    } while ((($maxlines == 0) or ($linect < $maxlines)) and
	     ($more_stuff != 0));

    if (($more_stuff != 0) || ($#psfifo >= 0)) {
	# Flush $psfifo and send the remaining data to the renderer, this
	# only happens with non-DSC-conforming jobs or non-Foomatic PPDs
	if ($more_stuff) {
	    print $logh "Stopped parsing the PostScript data, ".
		"sending rest directly to renderer.\n";
	} else {
	    print $logh "Flushing FIFO.\n";
	}
	if ($inheader) {
	    # No page initialized yet? Copy the "header" option set into the
	    # "currentpage" option set, so that the renderer will find the
	    # options settings.
	    copyoptions($dat, 'header', 'currentpage');
	}
	($rendererhandle, $rendererpid) =
	    getrendererhandle($dat, join('', @psheader, @psfifo));
	if ($retval != $EXIT_PRINTED) {
	    rip_die ("Error opening renderer",
		     $retval);
	}
	if ($more_stuff) {
	    while (<STDIN>) {
		print $rendererhandle $_;
		if ($debug) {
		    print DRIVERINPUT $_;
		}
	    }
	}
    }
    
    # Close the renderer
    if ($rendererpid) {
	$retval = closerendererhandle ($rendererhandle, $rendererpid);
	if ($retval != $EXIT_PRINTED) {
	    rip_die ("Error opening renderer",
		     $retval);
	}
    }
}
   


## Close last input file
close STDIN;



## Close debug output file
if ($debug) {
    close DRIVERINPUT 
	or rip_die ("error closing /tmp/prnjob",
		    $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
}



## Only for debugging
if ($debug) {
    use Data::Dumper;
    local $Data::Dumper::Purity=1;
    local $Data::Dumper::Indent=1;
    print $logh Dumper($dat);
}



## The End
print $logh "Closing foomatic-rip.";

exit $retval;



## This function runs the renderer command line and returns a file handle
## for stuffing in the PostScript data.

sub getrendererhandle {

    my ($dat, $prepend) = @_;

    print $logh "\nStarting renderer\n";

    # Catch signals

    $retval = $EXIT_PRINTED;
    use sigtrap qw(handler set_exit_prnerr USR1 
		   handler set_exit_prnerr_noretry USR2
		   handler set_exit_engaged TTIN);

    # Variables for the kid processes reporting their state

    # Set up a pipe for the kids to pass their exit stat to the main process
    pipe KID_MESSAGE, KID_MESSAGE_IN;

    # When one kid fails put the exit stat here
    $kidfailed = 0;

    # When a kid exits successfully, mark it here
    $kid3finished = 0;
    $kid4finished = 0;

    # Build the command line and get the PJL commands
    buildcommandline($dat, 'currentpage');
    $commandline = $dat->{'currentcmd'};
    @pjlprepend = @{$dat->{'pjlprepend'}};
    @pjlappend = @{$dat->{'pjlappend'}};

    use IO::Handle;
    pipe KID3_IN, KID3;
    KID3->autoflush(1);
    my $pid3 = fork();
    if (!defined($pid3)) {
        print $logh "$0: cannot fork for kid3!\n";
	rip_die ("can't fork for kid3",
		 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
    }
    if ($pid3) {

        # we are the parent; return a glob to the filehandle
        close KID3_IN;

	# Feed in the PostScript header and the FIFO contents
	print KID3 $prepend;

        KID3->flush();
        return ( *KID3, $pid3 );

    } else {
        close KID3;

        pipe KID4_IN, KID4;
	KID4->autoflush(1);
        my $pid2 = fork();
        if (!defined($pid2)) {
            print $logh "$0: cannot fork for kid4!\n";
	    close KID_MESSAGE;
	    print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
	    rip_die ("can't fork for kid4",
		     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
        }
        
        if ($pid2) {
            # parent, child of primary task; we are |commandline|
            close KID4_IN;

            print $logh "renderer PID pid2=$pid2\n";
	    print $logh "renderer command: $commandline\n";
            
            if (!close STDIN) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		rip_die ("Couldn't close STDIN in $pid2",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!open (STDIN, "<&KID3_IN")) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		rip_die ("Couldn't dup KID3_IN",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!close STDOUT) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		rip_die ("Couldn't close STDOUT in $pid2",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
            if (!open (STDOUT, ">&KID4")) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		rip_die ("Couldn't dup KID4",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
	    if ($debug) {
		if (!open (STDERR, ">&$logh")) {
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		    rip_die ("Couldn't dup logh to stderr",
			     $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
		}
	    }

	    # Massage commandline to execute foomatic-gswrapper
	    my $havewrapper = 0;
	    for (split(':', $ENV{'PATH'})) {
		if (-x "$_/foomatic-gswrapper") {
		    $havewrapper=1;
		    last;
		}
	    }
	    if ($havewrapper) {
		$commandline =~ s!^\s*gs !foomatic-gswrapper !;
		$commandline =~ s!(\|\s*)gs !\|foomatic-gswrapper !;
		$commandline =~ s!(;\s*)gs !; foomatic-gswrapper !;
	    }
	    
	    # Actually run the thing...
	    system("$commandline");
            if ($? != 0) {
		my $rendererretval = $? >> 8;
		print $logh "renderer return value: $rendererretval\n";
		my $renderersignal = $? & 127;
		print $logh "renderer received signal: $rendererretval\n";
		# Handle signals
		if ($renderersignal == $SIGUSR1) {
		    $retval = $EXIT_PRNERR;
		} elsif ($renderersignal == $SIGUSR2) {
		    $retval = $EXIT_PRNERR_NORETRY;
		} elsif ($renderersignal == $SIGTTIN) {
		    $retval = $EXIT_ENGAGED;
		}
		if ($retval != $EXIT_PRINTED) {
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $retval\n";
		    exit $retval;
		}
		# Evaluate renderer result
		if ($rendererretval == 0) {
		    # Success, exit with 0 and inform main process
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRINTED\n";
		    exit $EXIT_PRINTED;
		} elsif ($rendererretval == 1) {
		    # Syntax error? PostScript error?
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_JOBERR\n";
		    rip_die ("Possible error on renderer command line or PostScript error. Check options.",
			     $EXIT_JOBERR);
		} elsif ($rendererretval == 139) {
		    # Seems to indicate a core dump
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_JOBERR\n";
		    rip_die ("The renderer may have dumped core.",
			     $EXIT_JOBERR);
		} elsif ($rendererretval == 141) {
		    # Broken pipe, presumably additional filter interface
		    # exited.
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRNERR\n";
		    rip_die ("A filter used in addition to the renderer itself may have failed.",
			     $EXIT_PRNERR);
		} elsif (($rendererretval == 243) || ($retval == 255)) {
		    # PostScript error?
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_JOBERR\n";
		    exit $EXIT_JOBERR;
		} else {
		    # Unknown error
		    close KID_MESSAGE;
		    print KID_MESSAGE_IN "3 $EXIT_PRNERR\n";
		    rip_die ("The renderer command line returned an unrecognized error code $retval.",
			     $EXIT_PRNERR);
		}
	    }
	    close STDOUT;
	    close KID4;
	    close STDIN;
	    close KID3_IN;
	    # When arrived here the renderer command line was successful
	    # So exit with zero exit value here and inform the main process
	    close KID_MESSAGE;
	    print KID_MESSAGE_IN "3 $EXIT_PRINTED\n";
	    close KID_MESSAGE_IN;
	    # Wait for output child
	    waitpid($pid2, 0);
	    print $logh "KID3 finished\n";
	    exit $EXIT_PRINTED;
        } else {
            # child, trailing task on the pipe; we write pjl stuff
            close KID4;
	    close KID3_IN;

            my $fileh = *STDOUT;

	    # Debug output
	    print $logh "PJL: " . join("", @pjlprepend) . "<job data>\n" .
		join("", @pjlappend) . "\n";

            # wrap the PJL around the job data, if there are any
            # options specified...
	    if ( @pjlprepend > 1 ) {
		print $fileh @pjlprepend;
	    }
            while (<KID4_IN>) {
                print $fileh $_;
            }
	    if ( @pjlprepend > 1 ) {
		print $fileh @pjlappend;
	    }
            
            if (!close $fileh) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "4 $EXIT_PRNERR_NORETRY_BAD_SETTINGS\n";
		rip_die ("error closing $fileh",
			 $EXIT_PRNERR_NORETRY_BAD_SETTINGS);
	    }
	    close KID4_IN;

            print $logh "tail process done writing data to $fileh\n";

	    # Handle signals of the backend interface
	    if ($retval != $EXIT_PRINTED) {
		close KID_MESSAGE;
		print KID_MESSAGE_IN "4 $retval\n";
		exit $retval;
	    }

	    # Successful exit, inform main process
	    close KID_MESSAGE;
	    print KID_MESSAGE_IN "4 $EXIT_PRINTED\n";
	    close KID_MESSAGE_IN;

	    print $logh "KID4 finished\n";
            exit($EXIT_PRINTED);
        }
    }
}



## Close the renderer process and wait untill all kid processes
## finish.

sub closerendererhandle {

    my ($rendererhandle, $rendererpid) = @_;

    print $logh "\nClosing renderer\n";

    # Do it!
    close $rendererhandle;

    # Wait for all kid processes to finish or one kid process to fail
    close KID_MESSAGE_IN;
    while ((!$kidfailed) &&
	   !(($kid3finished) &&
	     ($kid4finished))) {
	my $message = <KID_MESSAGE>;
	chomp $message;
	if ($message =~ /(\d+)\s+(\d+)/) {
	    my $kid_id = $1;
	    my $exitstat = $2;
	    print $logh "KID$kid_id exited with status $exitstat\n";
	    if ($exitstat > 0) {
		$kidfailed = $exitstat;
	    } elsif ($kid_id == 3) {
		$kid3finished = 1;
	    } elsif ($kid_id == 4) {
		$kid4finished = 1;
	    }
	}
    }

    close KID_MESSAGE;

    # If a kid failed, return the exit stat of this kid
    if ($kidfailed != 0) {
	$retval = $kidfailed;
    }

    print $logh "Renderer exit stat: $retval\n";
    # Wait for renderer child
    waitpid($rendererpid, 0);
    print $logh "Renderer process finished\n";
    return ($retval);
}

# Find an argument by name in a case-insensitive way
sub argbyname {
    my $name = @_[0];

    my $arg;
    for $arg (@{$dat->{'args'}}) {
        return $arg if (lc($name) eq lc($arg->{'name'}));
    }

    return undef;
}

sub valbyname {
    my ($arg,$name) = @_;

    my $val;
    for $val (@{$arg->{'vals'}}) {
        return $val if (lc($name) eq lc($val->{'value'}));
    }

    return undef;
}

# Write a Good-Bye letter before committing suicide (send error
# message to caller)

sub rip_die {
    my ($message, $exitstat) = @_;

    print $logh "Process dieing with \"$message\", exit stat: $exitstat\n";
    if ($spooler eq 'ppr') {
	$message =~ s/\\/\\\\/;
	$message =~ s/\"/\\\"/;
	@messagelines = split("\n", $message);
	my $firstline = "TRUE";
	for $line (@messagelines) {
	    system("lib/alert $printer $firstline \"$line\"");
	    $firstline = "FALSE";
	}
    } else {
	print STDERR $message . "\n";
    }
    exit $exitstat;
}

# Signal handling routines

sub set_exit_prnerr {
    $retval = $EXIT_PRNERR;
}

sub set_exit_prnerr_noretry {
    $retval = $EXIT_PRNERR_NORETRY;
}

sub set_exit_engaged {
    $retval = $EXIT_ENGAGED;
}

sub readConfFile {
    my ($file) = @_;

    my %conf;
    # Read config file if present
    if (open CONF, "< $file") {
	while (<CONF>)
	{
	    $conf{$1}="$2" if (m/^\s*([^\#\s]\S*)\s*:\s*(.*)\s*$/);
	}
	close CONF;
    }

    return %conf;
}

sub unhtmlify {
    # Replace HTML/XML entities by the original characters
    my $str = $_[0];
    $str =~ s/\&apos;/\'/g;
    $str =~ s/\&quot;/\"/g;
    $str =~ s/\&gt;/\>/g;
    $str =~ s/\&lt;/\</g;
    $str =~ s/\&amp;/\&/g;
    return $str;
}

sub undossify {
    # Remove "dossy" line ends ("\r\n") from a string
    my ($str) = @_;
    $str =~ s/\r\n/\n/gs;
    $str =~ s/\r$//s;
    return $str;
}

sub checkarg {
    # Check if there is already an argument record $argname in $dat, if
    # create one
    my ($dat, $argname) = @_;
    return if defined($dat->{'args_byname'}{$argname});
    # argument record
    my $rec;
    $rec->{'name'} = $argname;
    # Insert record in 'args' array for browsing all arguments
    push(@{$dat->{'args'}}, $rec);
    # 'args_byname' hash for looking up arguments by name
    $dat->{'args_byname'}{$argname} = $dat->{'args'}[$#{$dat->{'args'}}];
    # Default execution style is 'G' (PostScript) since all arguments for
    # which we don't find "*Foomatic..." keywords are usual PostScript
    # options
    $dat->{'args_byname'}{$argname}{'style'} = 'G';
    # Default prototype for code to insert, used by enum options
    $dat->{'args_byname'}{$argname}{'proto'} = '%s';
    print $logh "Added option $argname\n";
}

sub checksetting {
    # Check if there is already an argument record $argname in $dat, if
    # create one
    my ($dat, $argname, $setting) = @_;
    return if 
	defined($dat->{'args_byname'}{$argname}{'vals_byname'}{$setting});
    # setting record
    my $rec;
    $rec->{'value'} = $setting;
    # Insert record in 'vals' array for browsing all settings
    push(@{$dat->{'args_byname'}{$argname}{'vals'}}, $rec);
    # 'vals_byname' hash for looking up settings by name
    $dat->{'args_byname'}{$argname}{'vals_byname'}{$setting} = 
	$dat->{'args_byname'}{$argname}{'vals'}[$#{$dat->{'args_byname'}{$argname}{'vals'}}];
}

sub removearg {
    # remove the argument record $argname from $dat
    my ($dat, $argname) = @_;
    return if !defined($dat->{'args_byname'}{$argname});
    # Remove 'args_byname' hash for looking up arguments by name
    delete $dat->{'args_byname'}{$argname};
    # Remove argument itself
    for (my $i = 0; $i <= $#{$dat->{'args'}}; $i ++) {
	if ($dat->{'args'}[$i]{'name'} eq $argname) {
	    print $logh "Removing option " .
		$argname . "\n";
	    splice(@{$dat->{'args'}}, $i, 1);
	    last;
	}
    }
}

sub removepsargs {
    # remove all records of PostScript arguments from $dat
    my ($dat) = @_;
    return if !defined($dat);
    for (my $i = 0; $i <= $#{$dat->{'args'}}; $i ++) {
	if ($dat->{'args'}[$i]{'style'} eq 'G') {
	    print $logh "Removing PostScript option " .
		$dat->{'args'}[$i]{'name'} . "\n";
	    # Remove 'args_byname' hash for looking up arguments by name
	    delete $dat->{'args_byname'}{$dat->{'args'}[$i]{'name'}};
	    # Remove argument itself
	    splice(@{$dat->{'args'}}, $i, 1);
	    $i --;
	}
    }
}

sub checkoptions {

    ## Let the values of a boolean option being 0 or 1 instead of
    ## "True" or "False", range-check the defaults of all options and
    ## issue warnings if the values are not valid

    # Option set to be examined
    my ($dat, $optionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if (defined($arg->{$optionset})) {
	    if ($arg->{'type'} eq 'bool') {
		if (lc($arg->{$optionset}) eq 'true') {
		    $arg->{$optionset} = 1;
		} elsif (lc($arg->{$optionset}) eq 'false') {
		    $arg->{$optionset} = 0;
		} else {
		    my $name = $arg->{'name'};
		    my $default = $arg->{$optionset};
		    # This maps Unknown to mean False.  Good?  Bad?
		    # It was done so in Foomatic 2.0.x, too.
		    $arg->{$optionset} = 0;
		    print $logh 
			"PPD default value $default for $name is not a " .
			"choice!\n" .
			" --> Using False instead!\n";
		}
	    } elsif ($arg->{'type'} eq 'enum') {
		if (!defined($arg->{'vals_byname'}{$arg->{$optionset}})) {
		    # wtf!?  that's not a choice!
		    my $name = $arg->{'name'};
		    my $default = $arg->{$optionset};
		    $arg->{$optionset} = $arg->{'vals'}[0]{'value'};
		    print $logh 
			"PPD default value $default for $name is not a " .
			"choice!\n" .
			" --> Using $arg->{$optionset} instead!\n";
		}
	    } elsif (($arg->{'type'} eq 'int') ||
		     ($arg->{'type'} eq 'float')) {
		if (($arg->{$optionset} > $arg->{'max'}) ||
		    ($arg->{$optionset} < $arg->{'min'})) {
		    my $name = $arg->{'name'};
		    my $default = $arg->{$optionset};
		    if ($arg->{$optionset} > $arg->{'max'}) {
			$arg->{$optionset} = $arg->{'max'}
		    } elsif ($arg->{$optionset} < $arg->{'min'}) {
			$arg->{$optionset} = $arg->{'min'}
		    }
		    print $logh 
			"PPD default value $default for $name is out of " .
			"range!\n" .
			" --> Using $arg->{$optionset} instead!\n";
		}
	    }
	}
    }
}

sub copyoptions {

    ## Copy one option set into another one

    # Source and destination option sets
    my ($dat, $srcoptionset, $destoptionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if (defined($arg->{$srcoptionset})) {
	    $arg->{$destoptionset} = $arg->{$srcoptionset};
	}
    }
}

sub deleteoptions {

    ## Delete an option set

    # option set to be removed
    my ($dat, $optionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if (defined($arg->{$srcoptionset})) {
	    delete($arg->{$optionset});
	}
    }
}

sub optionsequal {

    ## Compare two option sets, if they are equal, return 1, otherwise 0

    # Option sets to be compared
    my ($dat, $firstoptionset, $secondoptionset) = @_;

    for $arg (@{$dat->{'args'}}) {
	if ((defined($arg->{$firstoptionset})) &&
	    (defined($arg->{$secondoptionset}))) {
	    # Both entries exist
	    return 0 if $arg->{$firstoptionset} ne $arg->{$secondoptionset};
	} elsif ((defined($arg->{$firstoptionset})) ||
		 (defined($arg->{$secondoptionset}))) {
	    # One entry exists
	    return 0;
	}
	# If no entry exists, the non-existing entries are considered as
	# equal
    }
    return 1;
}

sub buildcommandline {

    ## Build a renderer command line, based in the given option set

    # Foomatic data and name of the option set to apply
    my ($dat, $optionset) = @_;

    # Construct the proper command line.
    $dat->{'currentcmd'} = $dat->{'cmd'};
    my @pjlprepend;
    my @pjlappend;
    my $arg;

    for $arg (sort { $a->{'order'} <=> $b->{'order'} } 
	      @{$dat->{'args'}}) {
	
	my $name = $arg->{'name'};
	my $spot = $arg->{'spot'};
	my $cmd = $arg->{'proto'};
	my $type = $arg->{'type'};
	my $cmdvar = "";
	my $userval = $arg->{$optionset};
        
	if ($type eq 'bool') {

	    # If true, stick the proto into the command line
	    if (defined($userval) && $userval == 1) {
		$cmdvar = $cmd;
	    }

	} elsif ($type eq 'int' or $type eq 'float') {

	    # If defined, process the proto and stick the result into
	    # the command line or postscript queue.
	    if (defined($userval)) {
		my $min = $arg->{'min'};
		my $max = $arg->{'max'};
		if ($userval >= $min and $userval <= $max) {
		    my $sprintfcmd = $cmd;
		    $sprintfcmd =~ s!\%([^s])!\%\%$1!g;
		    $cmdvar = sprintf($sprintfcmd,
				      ($type eq 'int' 
				       ? sprintf("%d", $userval)
				       : sprintf("%f", $userval)));
		} else {
		    print $logh "Value $userval for $name is out of range $min<=x<=$max.\n";
		}
	    }

	} elsif ($type eq 'enum') {

	    # If defined, stick the selected value into the proto and
	    # thence into the commandline
	    if (defined($userval)) {
		# CUPS assumes that options with the choises "Yes", "No",
		# "On", "Off", "True", or "False" are boolean options and
		# maps "-o Option=On" to "-o Option" and "-o Option=Off"
		# to "-o noOption", which cupsomatic maps to "0" and "1".
		# So when "0" or "1" is unavailable in the option, we try
		# "Yes", "No", "On", "Off", "True", and "False".
		my $found = 0;
		my $val;
		if ($val=valbyname($arg,$userval)) {
		    $found = 1;
		} elsif ($userval =~ /^Custom\.[\d\.]+x[\d\.]+[A-Za-z]*$/) {
		    # Custom paper size
		    $val = valbyname($arg,"Custom");
		    $found = 1;
		} elsif ($userval eq '0') {
		    foreach (qw(No Off False None)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		} elsif ($userval eq '1') {
		    foreach (qw(Yes On True)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		} elsif ($userval eq 'LongEdge') {
		    # Handle different names for the choices of the
		    # "Duplex" option
		    foreach (qw(LongEdge DuplexNoTumble)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		} elsif ($userval eq 'ShortEdge') {
		    foreach (qw(ShortEdge DuplexTumble)) {
			if ($val=valbyname($arg,$_)) {
			    $userval = $_;
			    $arg->{$optionset} = $userval;
			    $found = 1;
			    last;
			}
		    }
		}
		if ($found) {
		    my $sprintfcmd = $cmd;
		    $sprintfcmd =~ s!\%([^s])!\%\%$1!g;
		    $cmdvar = sprintf($sprintfcmd,
				      (defined($val->{'driverval'})
				       ? $val->{'driverval'}
				       : $val->{'value'}));
		    # Custom paper size
		    if ($userval =~ /^Custom\.([\d\.]+)x([\d\.]+)([A-Za-z]*)$/) {
			my $width = $1;
			my $height = $2;
			my $unit = $3;
			# convert width and height to PostScript points
			if (lc($unit) eq "in") {
			    $width *= 72.0;
			    $height *= 72.0;
			} elsif (lc($unit) eq "cm") {
			    $width *= (72.0/2.54);
			    $height *= (72.0/2.54);
			} elsif (lc($unit) eq "mm") {
			    $width *= (72.0/25.4);
			    $height *= (72.0/25.4);
			}
			# Round width and height
			$width =~ s/\.[0-4].*$// or
			    $width =~ s/\.[5-9].*$// and $width += 1;
			$height =~ s/\.[0-4].*$// or
			    $height =~ s/\.[5-9].*$// and $height += 1;
			# Insert width and height into the prototype
			$cmdvar =~ s/\%0/$width/ or
			    $cmdvar =~ s/(\W)0(\W)/$1$width$2/ or
			    $cmdvar =~ s/^0(\W)/$width$1/m or
			    $cmdvar =~ s/(\W)0$/$1$width/m or
			    $cmdvar =~ s/^0$/$width/m;
			$cmdvar =~ s/\%1/$height/ or
			    $cmdvar =~ s/(\W)0(\W)/$1$height$2/ or
			    $cmdvar =~ s/^0(\W)/$height$1/m or
			    $cmdvar =~ s/(\W)0$/$1$height/m or
			    $cmdvar =~ s/^0$/$height/m;
		    }
		} else {
		    # User gave unknown value?
		    print $logh "Value $userval for $name is not a valid choice.\n";
		}
	    }

	} else {
                    
	    print $logh "unknown type for argument $name!?\n";
	    # die "evil type!?";
                    
	}
        
	if ($arg->{'style'} eq 'G') {
	    # Place this Postscript command onto the prepend queue.
	    push (@prepend, "$cmdvar\n") if $cmdvar;

	} elsif ($arg->{'style'} eq 'J') {

	    if (defined($dat->{'pjl'})) {
		# put PJL commands onto PJL stack...
		push (@pjlprepend, "\@PJL $cmdvar\n") if $cmdvar;
	    }

	} elsif ($arg->{'style'} eq 'C') {
	    # command-line argument

	    # Insert the processed argument in the commandline
	    # just before the spot marker.
	    $dat->{'currentcmd'} =~ s!\%$spot!$cmdvar\%$spot!;
	}
        
    }
    

    ### Tidy up after computing option statements for all of P, J, and
    ### C types:

    ## C type finishing
    # Pluck out all of the %n's from the command line prototype
    my @letters = qw/A B C D E F G H I J K L M Z/;
    for $spot (@letters) {
	# Remove the letter marker from the commandline
	$dat->{'currentcmd'} =~ s!\%$spot!!;
    }

    ## J type finishing
    # Compute the proper stuff to say around the job

    if (defined($dat->{'pjl'})) {

	# PJL "frame" with "JOB" and "EOJ" commands

	# Stick beginning of job cruft on the front of the pjl stuff...
	#unshift (@pjlprepend,
	#         "\033%-12345X\@PJL JOB NAME=\"FOOMATIC-RIP\"\n");

	# Arrange for PJL EOJ command at end of job
	#push (@pjlappend,
	#      "\33%-12345X\@PJL RESET\n\@PJL EOJ\n");

	# PJL "frame" without "JOB" and "EOJ" commands. We use this because
	# some printers do not support these commands

	# Stick beginning of job cruft on the front of the pjl stuff...
	unshift (@pjlprepend,
             "\033%-12345X\@PJL\n");

	# Arrange for PJL RESET command at end of job
	push (@pjlappend,
	      "\33%-12345X\@PJL RESET\n");

	# Put the PJL stuff into the data structure
	@{$dat->{'pjlprepend'}} = @pjlprepend;
	@{$dat->{'pjlappend'}} = @pjlappend;
    }
}



# Emacs tabulator/indentation

### Local Variables:
### tab-width: 8
### perl-indent-level: 4
### End:
