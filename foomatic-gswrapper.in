#!@PERL@
# -*- perl -*-
# $Revision$

# This is a little Ghostscript regularization script.  It massages
# arguments to make Ghostscript execute properly as a filter, with
# output on stdout and errors etc on stderr.

# Arbitrary other option processing could happen here, too.

# IT WOULD BE WRONG to have this file do any processing of the input
# or output data.  Such job transforms belong in actual filters, or
# inside Ghostscript itself.

my $prefix = "@prefix@";
my $configpath = "@sysconfdir@/foomatic";
# Read config file if present
%conf = readConfFile("$configpath/filter.conf");

# Set GhostScript path
my $gspath = "gs";
$gspath = $conf{gspath} if defined(%conf) and defined $conf{gspath};
my $execpath = "@EXECPATH@";
# Get execution path from config file
$execpath = $conf{execpath} if defined(%conf) and defined $conf{execpath};
$ENV{'PATH'} = $execpath;

# Check whether we have a GhostScript version with redirection of the
# standard output of the PostScript programs via '-sstdout=%stderr'
my $gswithstdoutredirection = 0;
if (`$gspath -dQUIET -dPARANOIDSAFER -dNOPAUSE -dBATCH -dNOMEDIAATTRS -sDEVICE=pswrite -sstdout=%stderr -sOutputFile=/dev/null -c '(hello\n) print flush' 2>&1` =~ /hello/) {
    $gswithstdoutredirection = 1;
}

grep (m!\-sOutputFile=\-! 
      && do {
	  # If GhostScript does not support redirecting the standard output
	  # of the PostScript program to standard error with
	  # '-sstdout=%stderr', sen the job output data to fd 3; errors 
	  # will be on 2(stderr) and job ps program interpreter output on 
	  # 1(stdout).
	  $_ = ($gswithstdoutredirection ?
		'-sOutputFile=%stdout' : '-sOutputFile=/dev/fd/3');
	  # quoted properly below...
      }, @ARGV);

if (!$gswithstdoutredirection) {
    grep (((m!^\-$!) || (m!^\-_$!))
	  && do {
	      # Get the input from fd 0.
	      $_ = "/dev/fd/0";
	  }, @ARGV);
}

# Turn *off* -q (quiet!); now that stderr is useful! :)
my @myargs = grep (! m!^\-q$!, @ARGV);

# Escape any quotes, and then quote everything just to be sure...

# Escaping a single quote inside single quotes is a bit complex as the shell
# takes everything literal there. So we have to assemble it by concatinating
# different quoted strings.
# Finally we get e.g.: 'x'"'"'y' or ''"'"'xy' or 'xy'"'"'' or ...
grep (s/\'/\'\"\'\"\'/g, @myargs);
my $args = "'" . join("' '", @myargs) . "'";

# Execute Ghostscript, with both job and gs errors on stderr, and job
# output on stdout...

if ($gswithstdoutredirection) {
    $args = "'-sstdout=\%stderr' $args";
    print STDERR "foomatic-gswrapper: $gspath $args\n";
    exec "$gspath $args";
} else {
    print STDERR "foomatic-gswrapper: $gspath $args 3>&1 1>&2\n";
    exec "$gspath $args 3>&1 1>&2";
}

die "Failed to execute Ghostscript?!";

# Read the config file

sub readConfFile {
    my ($file) = @_;

    my %conf;
    # Read config file if present
    if (open CONF, "< $file") {
	while (<CONF>)
	{
	    $conf{$1}="$2" if (m/^\s*([^\#\s]\S*)\s*:\s*(.*?)\s*$/);
	}
	close CONF;
    }

    return %conf;
}
