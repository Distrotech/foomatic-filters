#!@PERL@
# -*- perl -*-
# $Revision$

# This is a little Ghostscript regularization script.  It massages
# arguments to make Ghostscript execute properly as a filter, with
# output on stdout and errors etc on stderr.

# Arbitrary other option processing could happen here, too.

# IT WOULD BE WRONG to have this file do any processing of the input
# or output data.  Such job transforms belong in actual filters, or
# inside Ghostscript itself.

my $prefix = "@prefix@";
my $configpath = "@sysconfdir@/foomatic";
# Read config file if present
%conf = readConfFile("$configpath/filter.conf");

# Set GhostScript path
my $gspath = "gs";
$gspath = $conf{gspath} if defined(%conf) and defined $conf{gspath};
my $execpath = "@prefix@/bin:/usr/local/bin:/usr/bin:/bin";
# Get execution path from config file
$execpath = $conf{execpath} if defined(%conf) and defined $conf{execpath};
$ENV{'PATH'} = $execpath;

grep (m!\-sOutputFile=\-! 
      && do {
	  # Send the job to fd 3; errors will be on 2(stderr) and job
	  # ps program interpreter output on 1(stdout).
	  $_ = '-sOutputFile=/dev/fd/3';
	  # quoted properly below...
      }, @ARGV);

grep (((m!^\-$!) || (m!^\-_$!))
      && do {
	  # Get the input from fd 0.
	  $_ = "/dev/fd/0";
      }, @ARGV);

# Turn *off* -q (quiet!); now that stderr is useful! :)
my @myargs = grep (! m!^\-q$!, @ARGV);

# Escape any quotes, and then quote everything just to be sure...
grep (s!\'!\\\'!g, @myargs);
my $args = "'" . join("' '", @myargs) . "'";

# Execute Ghostscript, with both job and gs errors on stderr, and job
# output on stdout...

print STDERR "foomatic-gswrapper: $gspath $args 3>&1 1>&2\n";
exec "$gspath $args 3>&1 1>&2";

die "Failed to execute Ghostscript?!";

# Read the config file

sub readConfFile {
    my ($file) = @_;

    my %conf;
    # Read config file if present
    if (open CONF, "< $file") {
	while (<CONF>)
	{
	    $conf{$1}="$2" if (m/^\s*([^\#\s]\S*)\s*:\s*(.*)\s*$/);
	}
	close CONF;
    }

    return %conf;
}
